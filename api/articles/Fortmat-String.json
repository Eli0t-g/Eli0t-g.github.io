{"title":"Fortmat String","uid":"ce1b126727eaab3b04a4b3e82a32db07","slug":"Fortmat-String","date":"2021-10-01T03:26:49.000Z","updated":"2021-11-22T23:23:39.994Z","comments":true,"path":"api/articles/Fortmat-String.json","keywords":null,"cover":"https://i.loli.net/2021/11/23/P7KR1YUzVl8Ha9n.jpg","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。会触发该漏洞的函数很有限。主要就是<code>printf</code>还有<code>sprintf</code>，<code>fprintf</code>等等c库中print家族的函数。因为主要是考查printf函数所以我就直接拿printf函数做讲解。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>在前面介绍中提到过，printf函数会将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。printf函数会将第一个参数地址压入栈中读取时，会跳转到字符串的地址，之后再逐字节输出，如果遇到%就会根据%后面的字符进行判断并按指定规则输出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s %d %c&quot;</span>,<span class=\"string\">&quot;hello&quot;</span>,<span class=\"number\">12</span>,<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用gdb调试</p>\n<p><img src=\"https://i.loli.net/2021/11/14/Zom9XOhRK6rwgjU.png\" alt=\"屏幕截图 2021-11-14 123407.png\"></p>\n<p>因为是64位程序，所以调用printf前会将printf的参数压入指定指定寄存器。C语言默认调用协议是__cdecl，所以传参方式是从右到左。传参方面，如果参数是字符串，程序会将该字符串的地址作为参数传入到寄存器。</p>\n<p><strong>程序是如何判断参数是在哪一个位置？</strong>其实很简单，程序会先找到字符串的位置并逐字节读取，在读取过程中会判断该字节是否是%，如果是就会根据下一字节来确定以何种方式输出后面的参数。</p>\n<p><strong>所以说漏洞在哪里？</strong>当后面的参数不够时，也就是参数位大于参数时，printf就会输出最后一个参数后面地址里面的值输出出去，以此类推，这样就可以泄露地址了。</p>\n<p><strong>所以我们应该如何利用呢？</strong>首先，我们可利用这个方式来泄露某个函数的got表。比如，我们如果将printf的参数修改成某个函数的got表地址，当printf输出时就可以把这个函数got表的内容输出出来从而造成地址泄露。其次，我们还可以利用printf修改某个参数的值。先补充一个知识点，**%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。**我们可以利用这一点来修改某个地址里面的值，首先我们可以将对应地址作为参数，在读取到这个参数之前先输出与我们想要修改值等数量的字符个数，最后用%n来修改这个值。这里可以参考我写的一篇文章<a href=\"https://eli0t-g.github.io/post/BUU-PWN\">pwn5</a>。</p>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"覆盖小数\"><a href=\"#覆盖小数\" class=\"headerlink\" title=\"覆盖小数\"></a>覆盖小数</h2><p>有些时候我们需要覆盖的值可能较小，只需要改动一个字节，而%n一次性会修改4或8字节，会导致覆盖了我们不想覆盖的值从而出现错误。为了解决这个问题，我们可以采用%hn或者%hhn修改两字节或者一字节。这样就可以避免不必要的覆盖。</p>\n<h2 id=\"泄露指定的参数\"><a href=\"#泄露指定的参数\" class=\"headerlink\" title=\"泄露指定的参数\"></a>泄露指定的参数</h2><p>我们可以通过不断使用%x来泄露指定内存，但是如果程序限制了字节数那该怎么办。比如</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">10</span>];</span><br><span class=\"line\">read(<span class=\"number\">0</span>,str,<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(str);</span><br></pre></td></tr></table></figure>\n\n<p>我们最多只能输出5个%x，如果要泄露的地址在后面怎么办？我们可以通过%n$x来泄露对应的参数（n代表对应参数的位置）</p>\n","text":"介绍格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。会触发该漏洞的函数很有限。主要就是printf还有sprintf，fprintf等等c库中print家族的函数。因为主要是考查printf函数所以我就直接拿printf函数做讲解。...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"pwn","slug":"pwn","count":2,"path":"api/categories/pwn.json"}],"tags":[{"name":"笔记","slug":"笔记","count":2,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">补充</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A6%86%E7%9B%96%E5%B0%8F%E6%95%B0\"><span class=\"toc-text\">覆盖小数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%84%E9%9C%B2%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">泄露指定的参数</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ROP-x86","uid":"a1737faa9c5d2f3d8075974e9ccad146","slug":"ROP-x86","date":"2021-10-05T10:23:30.000Z","updated":"2021-11-06T02:26:24.004Z","comments":true,"path":"api/articles/ROP-x86.json","keywords":null,"cover":"https://i.loli.net/2021/06/06/3ZBmwPkcIXjUE17.jpg","text":"ROP原理随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadge...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":3,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":7,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"延迟绑定","uid":"a4072082096b626cb339c7cf12b546b7","slug":"plt、got和延迟绑定","date":"2021-10-01T02:26:57.000Z","updated":"2021-11-06T02:17:25.499Z","comments":true,"path":"api/articles/plt、got和延迟绑定.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/upPzYdZFfJ1scaH.jpg","text":"程序运行时，printf的地址就会被存储到data段，call c &lt;hello+0xc&gt;就会跳转到call printf_stub 123printf_stub: mov rax,[printf函数地址] jmp rax 程序在编译的时候会采用两种表进行辅助，即pl...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"心得","slug":"心得","count":3,"path":"api/categories/心得.json"}],"tags":[{"name":"pwn","slug":"pwn","count":7,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}