{"title":"延迟绑定","uid":"a4072082096b626cb339c7cf12b546b7","slug":"plt、got和延迟绑定","date":"2021-10-17T02:26:57.000Z","updated":"2021-10-21T11:34:25.880Z","comments":true,"path":"api/articles/plt、got和延迟绑定.json","keywords":null,"cover":[],"content":"<p>程序运行时，printf的地址就会被存储到data段，call   c &lt;hello+0xc&gt;就会跳转到call printf_stub</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf_stub:</span><br><span class=\"line\">\tmov rax,[printf函数地址]</span><br><span class=\"line\">\tjmp rax</span><br></pre></td></tr></table></figure>\n\n\n\n<p>程序在编译的时候会采用两种表进行辅助，即plt表和got表。</p>\n<ul>\n<li>plt表为（Procedure Link Table），是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定</li>\n<li>got表为（Global Offset Table），是Linux ELF文件中用于定位全局变量和函数的一个表。</li>\n</ul>\n<h1 id=\"延迟绑定\"><a href=\"#延迟绑定\" class=\"headerlink\" title=\"延迟绑定\"></a>延迟绑定</h1><p>程序在执行前，如果对整个动态链接库函数进行符号解析的话，是非常浪费资源的，因为一个程序不可能调用动态链接库中所有的函数。我们最好能做到只对用到的函数进行函数解析，这样可以大大提高文件链接的效率，加快程序的启动速度。</p>\n<p>为提高CPU的利用效率，动态链接器默认采用延迟链接方式，动态链接器不会在程序加载时解析每一个函数，而是在调用时通过plt和got来对函数进行解析，然后会将解析获得函数地址存放在got中，下一次调用时会直接使用got中的函数地址对函数进行调用。</p>\n<h2 id=\"第一次调用\"><a href=\"#第一次调用\" class=\"headerlink\" title=\"第一次调用\"></a>第一次调用</h2><p>第一次调用某个函数时，会经历以下过程:</p>\n<p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve -&gt; 函数地址</p>\n<p>第一次调用时，由于延迟绑定，所以got表里面并没有函数的真正地址，此时got表存储的是函数的plt表下一命令地址。但是在plt跳转到got时还会将某个数压入栈中，这个数可以看出这个函数的ID，之后进入到公共@plt跳转执行_dl_runtime_resolve函数，这个函数的作用是根据函数ID来寻找对应函数，并改变got表地址为函数真正地址。</p>\n<p><img src=\"https://i.loli.net/2021/10/17/eGA5HxQEUOrCDlf.png\" alt=\"image.png\"></p>\n<h2 id=\"第二次调用\"><a href=\"#第二次调用\" class=\"headerlink\" title=\"第二次调用\"></a>第二次调用</h2><p>因为第一次调用已经将got表和函数进行绑定，所以调用某个函数时的流程就变成如下：</p>\n<p>xxx@plt -&gt; xxx@got -&gt; 函数地址</p>\n<h1 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h1><p>以下面代码为例进行调试</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\thello();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用命令编译查看： </p>\n<ul>\n<li>gcc -Wall -g -o try.o -c try.c -m32                </li>\n<li>objdump -d try.o</li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/17/54RpjzwcThrgbkP.png\" alt=\"屏幕截图 2021-10-17 143320.png\"></p>\n<p>程序运行时，printf的地址就会被存储到data段，call   c &lt;hello+0xc&gt;就会变成call printf_stub，printf_stub就会跳转到data段中printf地址，最后跳转到printf函数。printf_stub就相当于printf的plt表，data段中存储printf地址就相当于printf的got表。</p>\n<p><img src=\"https://i.loli.net/2021/10/17/2UnLBCaiQbRkMtv.png\" alt=\"image.png\"></p>\n","feature":true,"text":"程序运行时，printf的地址就会被存储到data段，call c &lt;hello+0xc&gt;就会跳转到call printf_stub 123printf_stub: mov rax,[printf函数地址] jmp rax 程序在编译的时候会采用两种表进行辅助，即pl...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"心得","slug":"心得","count":3,"path":"api/categories/心得.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">延迟绑定</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">第一次调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">第二次调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">调试</span></a></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ROP-x64","uid":"2d83114abbe0d2e1d7c9af7e01c50ee1","slug":"ROP-x64","date":"2021-10-18T03:29:10.000Z","updated":"2021-10-18T03:31:59.023Z","comments":true,"path":"api/articles/ROP-x64.json","keywords":null,"cover":[],"text":" 之前在前面写了一篇介绍ROP的，不过是32位的，因为64位和32位多多少少有不同点，所以这次就介绍64位下的ROP pwn07做法和之前32位的ret2libc3思路是一致的，泄露puts函数地址找到libc计算出system函数地址从而获取shell。64位是通过寄存器传递参...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":2,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"ctfshow-pwn","uid":"52662f34cef48ec0871eed4c3bef0137","slug":"ctfshow-pwn","date":"2021-10-16T09:55:50.000Z","updated":"2021-10-17T02:23:57.761Z","comments":true,"path":"api/articles/ctfshow-pwn.json","keywords":null,"cover":[],"text":"pwn03将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用 所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤： 泄露 puts地址 获取 libc 版本 获取 system 地址与 /bin/s...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}