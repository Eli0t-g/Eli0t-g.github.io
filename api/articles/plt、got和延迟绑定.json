{"title":"延迟绑定","uid":"a4072082096b626cb339c7cf12b546b7","slug":"plt、got和延迟绑定","date":"2021-10-17T02:26:57.000Z","updated":"2021-10-17T05:39:33.569Z","comments":true,"path":"api/articles/plt、got和延迟绑定.json","keywords":null,"cover":[],"content":"<p>程序在编译的时候会采用两种表进行辅助，即plt表和got表。</p>\n<ul>\n<li><p>plt表为（Procedure Link Table），是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定</p>\n</li>\n<li><p>got表为（Global Offset Table），是Linux ELF文件中用于定位全局变量和函数的一个表。</p>\n<h1 id=\"延迟绑定\"><a href=\"#延迟绑定\" class=\"headerlink\" title=\"延迟绑定\"></a>延迟绑定</h1><p>为提高CPU的利用效率，动态链接器默认采用延迟链接方式，动态链接器不会在程序加载时解析每一个函数，而是在调用时通过plt和got来对函数进行解析，然后会将解析获得函数地址存放在got中，下一次调用时会直接使用got中的函数地址对函数进行调用。</p>\n<h2 id=\"第一次调用\"><a href=\"#第一次调用\" class=\"headerlink\" title=\"第一次调用\"></a>第一次调用</h2><p>第一次调用某个函数时，会经历以下过程:</p>\n<p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve -&gt; 函数地址</p>\n<p>第一次调用时，由于延迟绑定，所以got表里面并没有函数的真正地址，此时got表存储的是函数的plt表下一命令地址。但是在plt跳转到got时还会将某个数压入栈中，这个数可以看出这个函数的ID，之后进入到公共@plt跳转执行_dl_runtime_resolve函数，这个函数的作用是根据函数ID来寻找对应函数，并改变got表地址为函数真正地址。</p>\n</li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/17/eGA5HxQEUOrCDlf.png\" alt=\"image.png\"></p>\n<h2 id=\"第二次调用\"><a href=\"#第二次调用\" class=\"headerlink\" title=\"第二次调用\"></a>第二次调用</h2><p>因为第一次调用已经将got表和函数进行绑定，所以调用某个函数时的流程就变成如下：</p>\n<p>xxx@plt -&gt; xxx@got -&gt; 函数地址</p>\n","feature":true,"text":"程序在编译的时候会采用两种表进行辅助，即plt表和got表。 plt表为（Procedure Link Table），是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定 got表为（Global Offset Table），是Linux ELF文件中用...","link":"","photos":[],"count_time":{"symbolsCount":650,"symbolsTime":"1 mins."},"categories":[{"name":"心得","slug":"心得","count":3,"path":"api/categories/心得.json"}],"tags":[{"name":"pwn","slug":"pwn","count":4,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">延迟绑定</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">第一次调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">第二次调用</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"ctfshow-pwn","uid":"52662f34cef48ec0871eed4c3bef0137","slug":"ctfshow-pwn","date":"2021-10-16T09:55:50.000Z","updated":"2021-10-17T02:23:57.761Z","comments":true,"path":"api/articles/ctfshow-pwn.json","keywords":null,"cover":[],"text":"pwn03将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用 所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤： 泄露 puts地址 获取 libc 版本 获取 system 地址与 /bin/s...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"pwn","slug":"pwn","count":4,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true}}