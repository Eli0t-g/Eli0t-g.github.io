{"title":"延迟绑定","uid":"a4072082096b626cb339c7cf12b546b7","slug":"plt、got和延迟绑定","date":"2021-10-01T02:26:57.000Z","updated":"2021-11-06T02:17:25.499Z","comments":true,"path":"api/articles/plt、got和延迟绑定.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/upPzYdZFfJ1scaH.jpg","content":"<p>程序运行时，printf的地址就会被存储到data段，call   c &lt;hello+0xc&gt;就会跳转到call printf_stub</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf_stub:</span><br><span class=\"line\">\tmov rax,[printf函数地址]</span><br><span class=\"line\">\tjmp rax</span><br></pre></td></tr></table></figure>\n\n\n\n<p>程序在编译的时候会采用两种表进行辅助，即plt表和got表。</p>\n<ul>\n<li>plt表为（Procedure Link Table），是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定</li>\n<li>got表为（Global Offset Table），是Linux ELF文件中用于定位全局变量和函数的一个表。</li>\n</ul>\n<h1 id=\"延迟绑定\"><a href=\"#延迟绑定\" class=\"headerlink\" title=\"延迟绑定\"></a>延迟绑定</h1><p>程序在执行前，如果对整个动态链接库函数进行符号解析的话，是非常浪费资源的，因为一个程序不可能调用动态链接库中所有的函数。我们最好能做到只对用到的函数进行函数解析，这样可以大大提高文件链接的效率，加快程序的启动速度。</p>\n<p>为提高CPU的利用效率，动态链接器默认采用延迟链接方式，动态链接器不会在程序加载时解析每一个函数，而是在调用时通过plt和got来对函数进行解析，然后会将解析获得函数地址存放在got中，下一次调用时会直接使用got中的函数地址对函数进行调用。</p>\n<h2 id=\"第一次调用\"><a href=\"#第一次调用\" class=\"headerlink\" title=\"第一次调用\"></a>第一次调用</h2><p>第一次调用某个函数时，会经历以下过程:</p>\n<p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve -&gt; 函数地址</p>\n<p>第一次调用时，由于延迟绑定，所以got表里面并没有函数的真正地址，此时got表存储的是函数的plt表下一命令地址。但是在plt跳转到got时还会将某个数压入栈中，这个数可以看出这个函数的ID，之后进入到公共@plt跳转执行_dl_runtime_resolve函数，这个函数的作用是根据函数ID来寻找对应函数，并改变got表地址为函数真正地址。</p>\n<p><img src=\"https://i.loli.net/2021/10/17/eGA5HxQEUOrCDlf.png\" alt=\"image.png\"></p>\n<h2 id=\"第二次调用\"><a href=\"#第二次调用\" class=\"headerlink\" title=\"第二次调用\"></a>第二次调用</h2><p>因为第一次调用已经将got表和函数进行绑定，所以调用某个函数时的流程就变成如下：</p>\n<p>xxx@plt -&gt; xxx@got -&gt; 函数地址</p>\n<h1 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h1><p>以下面代码为例进行调试</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\thello();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用命令编译查看： </p>\n<ul>\n<li>gcc -Wall -g -o try.o -c try.c -m32                </li>\n<li>objdump -d try.o</li>\n</ul>\n<p><img src=\"https://i.loli.net/2021/10/17/54RpjzwcThrgbkP.png\" alt=\"屏幕截图 2021-10-17 143320.png\"></p>\n<p>程序运行时，printf的地址就会被存储到data段，call   c &lt;hello+0xc&gt;就会变成call printf_stub，printf_stub就会跳转到data段中printf地址，最后跳转到printf函数。printf_stub就相当于printf的plt表，data段中存储printf地址就相当于printf的got表。</p>\n<p><img src=\"https://i.loli.net/2021/10/17/2UnLBCaiQbRkMtv.png\" alt=\"image.png\"></p>\n","text":"程序运行时，printf的地址就会被存储到data段，call c &lt;hello+0xc&gt;就会跳转到call printf_stub 123printf_stub: mov rax,[printf函数地址] jmp rax 程序在编译的时候会采用两种表进行辅助，即pl...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"心得","slug":"心得","count":3,"path":"api/categories/心得.json"}],"tags":[{"name":"pwn","slug":"pwn","count":7,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">延迟绑定</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">第一次调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">第二次调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">调试</span></a></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Fortmat String","uid":"ce1b126727eaab3b04a4b3e82a32db07","slug":"Fortmat-String","date":"2021-10-01T03:26:49.000Z","updated":"2021-11-22T23:23:39.994Z","comments":true,"path":"api/articles/Fortmat-String.json","keywords":null,"cover":"https://i.loli.net/2021/11/23/P7KR1YUzVl8Ha9n.jpg","text":"介绍格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。会触发该漏洞的函数很有限。主要就是printf还有sprintf，fprintf等等c库中print家族的函数。因为主要是考查printf函数所以我就直接拿printf函数做讲解。...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"pwn","slug":"pwn","count":3,"path":"api/categories/pwn.json"}],"tags":[{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"CISCN复现","uid":"dde0577c288faf648c0d6f90bbb39dc6","slug":"CISCN复现","date":"2021-05-18T11:25:16.000Z","updated":"2021-05-23T05:52:38.991Z","comments":true,"path":"api/articles/CISCN复现.json","keywords":null,"cover":"https://i.loli.net/2021/05/18/oDJvw6ieQjbXmrq.jpg","text":"前言初次参加这种大型比赛，给我的感觉就是题目出的挺不错（一题都没做出来），但是这个比赛形式着实令人不解。不仅如此，在写完选择题后系统崩溃也是我没想得到（虽然没有停滞很久，但是感觉很意外，毕竟是国赛）。 MISC隔空传话附件是一个txt文件，里面全是十六进制码，根据题目搜索发现是P...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"MISC","slug":"MISC","count":2,"path":"api/categories/MISC.json"}],"tags":[{"name":"wp","slug":"wp","count":2,"path":"api/tags/wp.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}