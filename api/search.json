[{"id":"20bf7105b3d9595b11047eca410abfeb","title":"C语言函数调用与常见调用约定","content":"函数调用下面代码展示了一个简单的加法子函数调用\n12345678910#include&lt;stdio.h&gt;int plus (int a,int b)&#123;    return a+b;&#125;void main()&#123;    int a=1,b=2,c;    c=plus(a,b);&#125;\n\n进入反汇编查看\n\n首先，系统会将1，2分别移动到a，b对应的地址中，之后从右至左将b，a对应地址的值移动到eax，ecx中，之后进行跳转到plus函数的plt表\n\n再跳转到plus函数的实际中\n\n子函数先是把ebp保存在栈中，之后通过mov指令将ebp指向esp指向的位置，esp再进行抬栈处理，然后保存现场（将ebx，esi，edi存储的值保存在堆栈中）,接下来把ebp-0ch对应的地址移动到edi中。之后向ecx赋30h，向eax赋0CCCCCCCCh，然后对es:edi对应的地址开始循环赋值（整个过程就是对缓冲区初始化）。（后面两个不知道是什么，太菜了😅）\n\n接下来就是将a的值移动到eax中再加b的值，后面再恢复现场，再内平栈（add esp 0C0h）,之后比较esp，ebp是否相同，（如果相同我也不知道会怎么样，😅），然后将esp指向ebp指向的位置，将ebp返回到原来的地方。\n\n最后外平栈（add esp,8），将计算结果从eax移到变量c对应的地址中，至此完成函数调用\n\n常见的三种调用约定（32位）\n第一种就是系统默认的调用约定，调用者清理栈，就是和上面外平栈（add esp,8）差不多\n第二种就是在返回时对ret进行处理，使栈指针指向调用参数前的地址（如：ret 8）\n第三种就是通过寄存器传参，但如果寄存器不够还是得借助栈来传参，因为cpu与寄存器之间传递相对于cpu与内存更快，所以第三种方法在参数较少时，更加高效。\n","slug":"C语言函数调用与常见调用约定","date":"2021-04-25T14:02:30.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"6ab7ba8971edf760af996dc2bda9f711","title":"switch语句高效的原因","content":"switch语句和if语句都是条件判断语句，但是switch语句更加高效，因而许多公司在设计时大多采用switch语句\n\n当分支语句较少时，switch与if语句并没有什么区别都是先判断，之后再跳转\n\n\n\n当分支较多时，switch语句就发生变化，并没有挨个判断再跳转，只跳转了一次\n\n\n\n\nswitch语句会维护一张跳转表，不管case判断语句的值是不是按照顺序的，内存中的地址表都会按照顺序进行排列。分析汇编代码会发现，编译器先是将x的值赋给ecx寄存器，之后ecx减去case中最小值并与case中最大值比较，大于就会跳转到default，不大于就会将ecx寄存器中的值移到edx中,之后跳转到edx * 4+14191Ch对应的地址，查看地址发现ABCD四个字符存放的位置就是相差4个字节。所以，当分支较多时，switch-case不用像if-else if那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位到分支。从数据结构与算法的角度来看，switch 语句相当于一个数组，其查询时间复杂度为 O(1)；而 if-lese 语句相当于一个链表，其时间复杂度为 O(n)\n\n总结使用switch语句时，程序首先判断switch变量是否大于（小于）最大（最小）case 常量，若大于（小于），则跳到default分支处理；否则取得索引号为switch变量大小的跳表项的地址（即跳表的起始地址＋表项大小＊索引号），程序接着跳到此地址执行，到此完成了分支的跳转。。即使case情况不连续或者case情况相差较大时，也能达到相应的效果。\n\n参考文章：https://blog.csdn.net/zbw1185/article/details/103359426\n","slug":"switch语句高效的原因","date":"2021-04-25T04:48:37.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"49b5f2dc0a9e31a5cb54c844157811ae","title":"Linux常见的保护机制","content":"checksec（gdb安装好就有）gdb动态调试软件，必备。\n安装：\n1apt-get install gdb\n\n用法作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。\n用法：checksec filename\n例子：\n123456gdb-peda$ checksec startCANARY    : disabled(这个选项表示栈保护功能有没有开启。)FORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : disabled\n\nCANNARY(栈保护)栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。**\ngcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。\n因此在编译时可以控制是否开启栈保护以及程度，例如：\n123gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F;禁用栈保护gcc -fstack-protector -o test test.c   &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码\n\nFORTIFY(轻微的检查)fority其实是非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memepy,stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf， vsprintf，vsnprintf, gets以及宽字符的变体。FORTIFY_ SOURCE设为1,并且将编译器设置为优化1(gcc -01)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能。\n1234gcc -o test test.c &#x2F;&#x2F; 默认情况下，不会开这个检查 gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查 gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进⾏检查 (特别像某些头⽂件 #include &lt;str _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编 gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查 gcc -D_FORTIFY_SOURCE&#x3D;2 程序执⾏时也会有检查 (如果检查到缓冲区溢出，就终⽌程序) _FORTIFY_SOURCE设为2，有些检查功能会加⼊，但是这可能导致程序崩溃。\n\n\n\nNX（DEP）N X （ D E P）的基本原理是将数据所在内存⻚标识为不可执⾏,当程序溢出成功转⼊shellcode时，程序会尝试在数据⻚⾯上执⾏指令，此时CPU就会抛出异常 ,⽽不是去执⾏恶意指令 。 \n123gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护gcc -z execstack -o test test.c &#x2F;&#x2F; 禁⽤NX保护 gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护\n\n在Windows下，类似的概念为DEP（数据执行保护）,数据执⾏保护( D E P ) （ Data Execution Prevention ） 是⼀套软硬件技术，能 够 在 内 存上执⾏额外检查以帮助防⽌在系统上运⾏恶意代码 ,在最新版的Visual Studio中默认开启了DEP编译选项。\nPIE（ASLR）可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。PIE和ASLR不是一样的作用，ASLR只能对堆、栈,ibc和mmap随机化，而不能对代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。联系点在于在开启ASLR之后，PIE才会生效。\n12345gcc -o test test.c &#x2F;&#x2F; 默认情况下，不开启PIE gcc -fpie -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时强度为1 gcc -fPIE -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时为最⾼强度2 gcc -fpic -o test test.c &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIEgcc -fPIC -o test test.c &#x2F;&#x2F; 开启PIC，此时为最⾼强度2，不会开启PIE\n\n\n\nASLR (Address Space Layout Randomization)ASLR是⼀种针对缓冲区溢出的安全保护技术,通过对堆栈 、共享库映射等线性区布局的随机化，通过增加攻击者预测⽬的地址的难度,防⽌攻击者直接定位攻击代码位置,达到阻⽌溢出攻击的⽬的。 \n参考文章：https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/\n","slug":"linux程序的常⽤保护机制","date":"2021-04-09T13:14:59.000Z","categories_index":"PWN","tags_index":"基础知识","author_index":"Krito"},{"id":"8c5e835735464cb680ea7b5b166e5319","title":"解决hexo博客图片无法加载问题","content":"起初搭建好博客时，发现照片无法上传本地照片，\n\n根据网上的方法整了半天也没整好，最后还是室友告诉我通过下面的方法才可以引用本地照片\n1&lt;img src&#x3D;&quot;path&quot; height&#x3D;&quot;xxx&quot; width&#x3D;&quot;xxx&quot; &#x2F;&gt;\n\n但是用这个方法需要在source目录下创建一个目录来存储照片，后面写多了博客，发现这样会特别杂乱，而且最最重要的是虽然能在博客上显示，但是不能在本地显示，操作起来非常不方便。\n\n于是在网上找了半天，各种方法都是了一遍终于发现解决办法\n参考链接\n首先下载插件：\n1yarn add https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image\n\n之后修改博客根目录文件_config.yml中的 post_asset_folder: false，将其改成post_asset_folder: true（注意冒号后面有个空格）,然后就可以通过markdown语法正常上传照片了\n这个方法不仅支持使用markdown语法，而且写博客会创建一个同名文件夹来存放照片，非常方便，而且最重要的是可以在本地预览\n","slug":"解决hexo博客图片无法加载问题","date":"2021-04-20T08:51:23.000Z","categories_index":"问题","tags_index":"博客","author_index":"Krito"},{"id":"4c0cb40856baa1e8384c37c457fb63f6","title":"指针","content":"\n\n\n\n\n\n\n\n\n指针，并不像一些书上写的只是用于存储地址，它是一种类型数据，存储什么都可以，并不是只能存储地址。\n指针大小常见的指针有：char *，int *，float * …，但char * * *，int * * *…同样也是指针(多级指针)，同时虽然指针类型有很多种，但是无论是什么指针，它的大小都是4字节\n\n\n\n可以看到没有声明指针时抬栈40字节，声明以后抬栈44字节，说明声明变量消耗0x50-0x44h也就是12字节，也就是说每个指针占4字节空间\n指针运算指针只能进行加减法运算，不能乘除运算，同时加法运算并不是普通加法运算，其中遵守着一些规则\n\n如上，左边的输出：101  101  101 ，右边输出：104  104  104，因为右边去掉一个* 还是指针类型数据，如果去掉 * 是char或者int等就是加或减那个类型的大小。\n12345678910#include&lt;stdio.h&gt;void main()&#123;\tint *a;         char *b;\ta=100;         b=100;        printf(&quot;%d &quot;,++a);        printf(&quot;%d &quot;,++b);&#125;\n\n输出结果：104 101\n实例12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#define N 10void swap1(int a,int b);void swap2(int *a,int *b);void swap3(int *a,int *b);int main()&#123;  int c=1,d=2;  swap1(c,d);  printf(&quot;%d %d\\n&quot;,c,d);  swap2(&amp;c,&amp;d);  printf(&quot;%d %d\\n&quot;,c,d);  swap3(&amp;c,&amp;d);  printf(&quot;%d %d\\n&quot;,c,d);  return 0;&#125;void swap1(int a,int b)&#123;  int t;  t=a;  a=b;  b=t;&#125;void swap2(int *a,int *b)&#123;  int t;  t=a;  a=b;  b=t;&#125;void swap3(int *a,int *b)&#123;  int t;  t=*a;  *a=*b;  *b=t;&#125;\n\n这段代码中就只有swap3成功交换了c与d的值，首先每个全局变量或者被调用的变量都有个地址，变量被修改其实就是变量对应的地址的值被修改，如果被修改的值不能返回到地址中，变量就不会改变。在swap1(c,d)中，c与d的值被压入栈中，swap1(c,d)只是处理栈中的值，被修改的值并不会返回到c和d的地址中，所以函数里面再怎么交换也不会影响变量c与d，而swap2(c,d)虽然可以运行，但是是错误的写法，int与int*不能相互赋值，系统并不会执行，同时还会产生警告\n\n而最后的swap3函数则是处理c与d的地址，先将a地址对应的值赋给t，在将b地址的值存入a地址中，最后向b地址存入t值（也就是a的值），符合编译器的调用约定，系统可以执行\n通过这个可知，如果只是将变量的值传入子函数中，并不会影响变量，要想通过子函数修改子函数外的变量，需要找出变量的地址，并将修改的值存入变量地址中。\n1234567891011121314151617#include&lt;stdio.h&gt;void add(int a[],int b,int c);int main()&#123;  int i,a[5]=&#123;1,2,3,4,5&#125;;  add(a,1,5);  for(i=0;i&lt;5;i++)    printf(&quot;%d&quot;,a[i]);  return 0;&#125;void add(int a[],int b,int c)&#123;  int i=0;  for (;i&lt;c;i++)    a[i]+=b;&#125;\n\n这段代码是处理数组的，子函数调用数组时，传入的其实就是该数组的首地址，所以会直接修改数组的值。（为了防止数组被函数修改，可以在调用数组前加const，只要函数修改数组，编译器就会报错。）\n","slug":"指针","date":"2021-03-28T02:54:43.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"0b2fb954c183833919bf074ef85f5195","title":"Assembly Language（32位）","content":"\n重新复习了一遍汇编，这次看的是32位的，有了一点点收获，就随便写写\n\n寄存器\n\nx86的寄存器包括8位、16位、32位，其中32位寄存器可以分为16位或者8位，如EAX可以分为16位AX或者8位AH、AL，但是EBX以后的寄存器就不可以了，虽然是通用寄存器但是每个通用寄存器都有一些特殊的用途\nEAXEAX与STOS指令相关，STOS会将EAX的值存进EDI指定的内存单元中，同时还经常存储计算结果\nECXECX与REP指令相关，用于记录指令循环次数\nEDI和ESIEDI和ESI用于做地址复制，将ESI指定的地址中的值赋值到EDI指定的地址中，与movs指令有很大关系\n\n\nESPESP用于存储当前栈堆用到的地址\nEFL（标志寄存器）EFI的第十位（DF）如果是零，使用push，pop指令后ESP会加相应数值，如果是一，则减去相应数值。\nEIPEIP用于存储计算机执行下一个指令的地址\n堆栈\n堆栈本质就是一段内存，在程序启动前就已经被分配好了，堆栈会存储程序重要的信息，被称为“程序的心脏”\n\n32位上的应用大部分采用小端模式，手机上的应用大部分采用大端模式\n小段模式从高地址开始存放，往低地址去\n大端模式从低地址开始存放，往高地址去\n指令MOV(移动指令)将指定的值移动指定位置（内存地址或寄存器）\nADD(加法指令)将指定的两个值相加，结果返回到指定位置（内存地址或寄存器）\nSUB(减法指令)将指定的两个值相减，结果返回到指定位置（内存地址或寄存器）\nAND(与运算指令)与运算：两个为一才为一\n将指定的两个值进行与运算，结果返回到指定位置（内存地址或寄存器）\nOR(或运算指令)或运算：有一就为一\n将指定的两个值进行或运算，结果返回到指定位置（内存地址或寄存器）\nXOR(异或运算指令)异或运算：不一样为一\n将指定的两个值进行异或运算，结果返回到指定位置（内存地址或寄存器）\nNOT(非运算指令)非运算：一为零，零为一\n将指定的一个值进行非运算，结果返回原位置（内存地址或寄存器）\nSHL(左移指令)shl（C语言：&lt;&lt;）\n高位丢弃,低位补零\n右移指令汇编 shr：高位补零，低位丢弃\n​         sar：高位补符号位，地位丢弃（就是补最高位的数字）\nC语言 &gt;&gt; 无符号数：高位补零，低位丢弃\n​                 有符号数：高位补符号位，低位丢弃\n","slug":"Assembly Language（32位）","date":"2021-03-22T12:41:01.000Z","categories_index":"基础知识","tags_index":"Assembly Language","author_index":"Krito"},{"id":"9f625a615c8ebfb571548bd146557e6b","title":"SSH连接失败及hexo命令失效","content":"\n闲的无聊就整了一下博客，结果出大问题了，之前的备份又删了，所以不得不重建，这次重建花了整整一天，虽说浪费时间但是还是有所收获\n\n搭建博客视频网上一大堆，这里就不多讲了，这里就讲一些错误和如何解决\nssh: connect to host github.com port 22: Connection timed out这个问题烦了我几个小时，网上的解决方法参差不齐（反正我通过网上的方法没用解决），最后还是看官方的解决方法（官方是真的牛逼）Using SSH over the HTTPS port。\n出现这个问题是因为22端口被占用或者防火墙不允许ssh连接。解决方法是通过通过HTTPS启用SSH连接，命令：ssh -T -p 443 &#103;&#105;&#x74;&#64;&#115;&#115;&#x68;&#46;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;，运行时输入yes，这样可以强制连接，连接成功后就可以进行下一步操作了（不成功可以看官方给的故障排除指南），成功后，在.ssh文件夹中创建一个config文件（千万千万别加后缀名！）内容如下：\n1234Host github.com  Hostname ssh.github.com  Port 443  User git\n\n最后输入：ssh -T &#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;看是否成功连接\n成功连接如下：\n123$ ssh -T git@github.com&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not&gt; provide shell access.\n\n简单介绍一下SSH，博客上传时，如果没用通过ssh连接的话，需要输入密码，通过ssh远程连接以后就不需要了\nhexo命令失效原本搭建好了但是不知道为什么突然hexo一些命令失效了，在网上找了发现可能有几种原因：\n\n检查_config.yml中的内容:后面没有有一个空格。\n`package.json’，没有添加hexo信息用来标识这是一个hexo目录：\n\n12345&#123;  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;&quot;  &#125;&#125;\n\n如果实在不行就重新进行hexo init（最有效最直接的方法）\n或者看看是不是不在博客根目录\nhexo d命令报错 ERROR Deployer not found: git上网搜了一下，就是没安装好hexo-deployer-git插件，重新安装一下就好了。（命令：npm install hexo-deployer-git –save）\n","slug":"SSH连接失败及hexo命令失效","date":"2021-03-15T13:29:03.000Z","categories_index":"问题","tags_index":"博客","author_index":"Krito"},{"id":"87c5f340a99857dbb6ed12c46a0d0a8b","title":"python学习心得","content":"\n寒假学习python是我没想到的，但是的确学到了不少知识。在这里分享一下我所学到的与我总结一些的关于python内置函数的知识\n\n函数与字符相关的函数isinstance() \n作用：判断一个对象是否是一个已知的类型，类似 type()。\n用法：isinstance(object, classinfo)\n实例：\n1234567&gt;&gt;&gt;a = 2&gt;&gt;&gt; isinstance (a,int)True&gt;&gt;&gt; isinstance (a,str)False&gt;&gt;&gt; isinstance (a,(str,int,list))    # 是元组中的一个返回 TrueTrue\n\n\ndivmod()  \n作用：输入除数和余数，返回商和余数  \n用法：divmod(number,number)\n实例：\n12&gt;&gt;&gt; divmod(7,3)(2, 1)\n\n\nord()  \n作用：返回指定对象的ASCII码对应的十进制  \n用法：ord(object)\n实例：\n12&gt;&gt;&gt;ord(&#x27;a&#x27;) 97\n\n与字符串相关的函数eval()\n作用：用来执行一个字符串表达式，并返回表达式的值\n用法：eval(string)\n12&gt;&gt;&gt;eval(&#x27;5+3&#x27;)8\n\n\nformat() 函数\n作用：格式化字符串  \n用法：str.format()\n实例：\n123456&gt;&gt;&gt;print(&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)&quot;)   # 不设置指定位置&#x27;hello world&#x27;&gt;&gt;&gt;print(&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)&quot;)  # 设置指定位置&#x27;world hello world&#x27;  &gt;&gt;&gt;print(&#x27;Hello &#123;w&#125;&#x27;.format(w=&#x27;World&#x27;)) # 指定参数Hello World\n\n与列表相关的函数enumerate()  函数\n作用：遍历的数据对象组合为一个索引序列，同时列出数据和数据下标  \n用法：enumerate(sequence, [start=0])\n实例：\n123a = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]for x,y in enumerate(a):    print(x,y)\n\n输出：\n0 a\n1 b\n2 c\n\nsort() 函数\n作用：列表进行排序，如果指定参数，则使用比较函数指定的比较函数\n用法：list.sort(key=None, reverse=False)\n\nkey：主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。\nreverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）\n\n实例：\n123456789101112def takeSecond(elem):    return elem[1] # 列表random = [(2, 2), (3, 4), (4, 1), (1, 3)] # 指定第二个元素排序random.sort(key=takeSecond) # 输出类别print(&#x27;排序列表：&#x27;)print(random)\n\n输出：\n12排序列表：[(4, 1), (2, 2), (1, 3), (3, 4)]\n\n123456789# 列表vowels = [&#x27;e&#x27;, &#x27;a&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27;i&#x27;] # 降序vowels.sort(reverse=True) # 输出结果print(&#x27;降序输出:&#x27;)print( vowels )\n\n输出：\n12降序输出:[&#39;u&#39;, &#39;o&#39;, &#39;i&#39;, &#39;e&#39;, &#39;a&#39;]\n\n\nzip()\n作用：用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。\n用法：zip(iterable, …)\n实例：\n123456789&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式[(1, 2, 3), (4, 5, 6)]\n\n\nall()\n作用：用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。\n用法：all(iterable)\n实例：\n123456789101112131415161718&gt;&gt;&gt; all([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])  # 列表list，元素都不为空或0True&gt;&gt;&gt; all([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;])   # 列表list，存在一个为空的元素False&gt;&gt;&gt; all([0, 1，2, 3])          # 列表list，存在一个为0的元素False   &gt;&gt;&gt; all((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;))  # 元组tuple，元素都不为空或0True&gt;&gt;&gt; all((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;))   # 元组tuple，存在一个为空的元素False&gt;&gt;&gt; all((0, 1, 2, 3))          # 元组tuple，存在一个为0的元素False   &gt;&gt;&gt; all([])             # 空列表True&gt;&gt;&gt; all(())             # 空元组True\n\n\nsort()和sorted()\n作用：对所有可迭代的对象进行排序操作。\n用法：sorted(iterable, cmp=None, key=None, reverse=False)(sort也是一样)\n区别：sort会改变原对象的序列而sorted不会\n实例：\n1234567891011121314151617181920&gt;&gt;&gt;a = [5,7,6,3,4,1,2]&gt;&gt;&gt; b = sorted(a)       # 保留原列表&gt;&gt;&gt; a [5, 7, 6, 3, 4, 1, 2]&gt;&gt;&gt; b[1, 2, 3, 4, 5, 6, 7] &gt;&gt;&gt; L=[(&#x27;b&#x27;,2),(&#x27;a&#x27;,1),(&#x27;c&#x27;,3),(&#x27;d&#x27;,4)]&gt;&gt;&gt; sorted(L, cmp=lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数[(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3), (&#x27;d&#x27;, 4)]&gt;&gt;&gt; sorted(L, key=lambda x:x[1])               # 利用key[(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3), (&#x27;d&#x27;, 4)]  &gt;&gt;&gt; students = [(&#x27;john&#x27;, &#x27;A&#x27;, 15), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;dave&#x27;, &#x27;B&#x27;, 10)]&gt;&gt;&gt; sorted(students, key=lambda s: s[2])            # 按年龄排序[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)] &gt;&gt;&gt; sorted(students, key=lambda s: s[2], reverse=True)       # 按降序[(&#x27;john&#x27;, &#x27;A&#x27;, 15), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;dave&#x27;, &#x27;B&#x27;, 10)]\n\n\nset()\n作用：删除列表里面重复的元素，（不会改变原有序列）\n用法：set(iterable)\n实例：\n123456789101112list1=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;zhang&#x27;,&#x27;kang&#x27;,&#x27;a&#x27;]list2=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]s1=set(list1)s2=set(list2)print(s1)print(s2)print(list1)输出：&#123;&#x27;b&#x27;, &#x27;kang&#x27;, &#x27;zhang&#x27;, &#x27;a&#x27;&#125;&#123;&#x27;b&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;a&#x27;&#125;[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;zhang&#x27;, &#x27;kang&#x27;, &#x27;a&#x27;]\n\n\n","slug":"python","date":"2021-02-16T11:15:39.000Z","categories_index":"基础知识","tags_index":"python","author_index":"Krito"},{"id":"ffd87d4d875bb16286fecb1469508ba7","title":"bugku","content":"BUGKU misc部分1 这是一张单纯的图片先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样，\n\n\n直接丢winhex，拖至最底，发现是unicode加密\n\n\n发现是unicode加密，直接解码成ASCII，得到flag\n\n\n\n2 隐写看到题目就知道是图片隐写，对图片进行校验和，发现结果有问题，说明照片高度被修改了\n\n\n修改高度得到flag\n\n\n\n3 telnet下载附件后打开，直接追踪TCP流就得到了flag\n\n\n\n4 眼见非实打开后发现文件是损坏的而且出现了PK字符，猜测里面藏有压缩包，于是改成压缩包形式打开\n\n\n在word里面的document.xml里面发现了flag\n\n\n\n5 啊哒老规矩，打开照片看属性，发现照相机型号有东西，之后应该用得上\n\n\n用binwalk查看，发现里面藏有一个压缩包，用foremost进行分离得到压缩包，打开发现是加密的，尝试了照相机型号，发现密码错误，分析了一下那串照相机型号，发现是十六进制，之后解码得到密码\n\n\n打开得到flag\n\n\n\n6 ping用wireshark打开后发现十六进制旁边一个f，打开其它的发现组合起来是flag\n\n\n\n7 赛博朋克打开后发现就一个光秃秃的加密文件，不用猜都知道是伪加密，丢进winhex修改一下就可以打开了\n\n\n打开文件后发现是一堆乱码，丢进winhex发现是png格式照片\n\n\n修改一下后缀名图片就出来了，不过好像flag还没出来，属性里面也没什么东西，校验和也正确，binwalk也没查出问题\n\n\n\n\n最后推测一个是lsb隐写，果不其然，得到flag\n\n\n\n8 贝斯手打开介绍发现是对图片上人物介绍，刚想关闭发现最下面还有东西，发现密码是四位数和这个贝斯手有关\n\n\n懒得搜直接暴力破解\n\n\n打开后发现是一串加密字符，5+58应该加密方式MD5和base58\n\n\n解码得到flag\n\n\n\n\n\n9 又一张图片，还单纯吗打开属性发现没有有用的信息，丢进winhex里面也没发现什么，用binwalk查看发现照片里面有其它jpg照片，用forem分离\n\n\n发现图片里面有flag（不过这个flag有点长，有点离谱）\n\n\n\n10 猜签到题，百度识图，发现是刘亦菲，得到flag（注意flag格式）\n\n11 宽带信息泄露下载RouterPassView，用这个搜索username（用户名）\n\n\n\n12 隐写2直接丢进winhex，发现jpg图片结尾后面有压缩包的字符\n\n\n用foremost分离得到一个加密的文件和密码提示，解密（直接爆破，反正是三位数）得到一张图片\n\n\n老规矩丢winhex，发现最后有flag\n\n\n\n13 多种方法解决这道题提示说有二维码，打开附件发现是一个exe可执行文件（尝试打开发现无法运行），直接丢winhex\n\n\n发现是旁边是加密的图片编码，直接在线解码得到flag\n\n\n\n14 闪的好快emmmm，这道题挺简单的就是好烦，用Stegsolve.jar一帧一帧看，扫码，flag就出来了\n\n15 come_game打开后是个游戏，每次死亡都会多个文件，找到save1将它丢尽winhex里面，将2AC改成5AC在进游戏就可以得到flag，当然如果觉得能闯过去也应该能得到flag。（我没试过，不确定能不能行，提醒一下这个游戏打开了好像不能关闭）\n\n\n\n16 白哥的鸽子直接丢进winhex里面，发现照片结尾后面多出一些字符，分析一下就知道是栅栏加密\n\n\n解密（密匙我是一个一个试的，不过还好就是3，后面才知道那个提示“咕咕咕”好像就代表key=3）\n\n\n17 linux看到题目就知道要用Linux系统\n","slug":"bugku","date":"2021-02-02T13:24:11.000Z","categories_index":"MISC","tags_index":"wp","author_index":"Krito"},{"id":"ea7bb1240e1dab8cf5209f8a8c9f1924","title":"快乐周五","content":"\n这是这几个月最值得纪念的周五，体验了脱离学校的快乐\n\n2020.12.13\n  晚上和社团其它人一起谋划着“出校大计”，原本定在周六，但是由于学校要体测（挺佩服学校挑时间的能力🤬），不得不将时间改成周五，让快乐减少了一半😔\n2020.12.15\n  果然到了周末就会发现屁事很多😔，一个个周末都有事，只剩几个大男人可以出去，这次出校也变成了“罗汉出行”，照这样下去，不知道之后几天会发生什么😱\n2020.12.17\n  原本课上得好好的，突然一个朋友说周六体测取消了，改了时间，我直接当场爆炸🤬，没办法假条都上交了，时间也不能修改，只能认命\n2020.12.18\n  原本计划好的五个人，要走的时候最后一个人掉链子😔，最后变成四罗汉出行。\n开始打算看电影，但是觉得没什么好看的电影加上时间不够，所以改成了密室逃脱（补充一下，有个当地人带路非常重要😃）\n\n\n\n\n\n\n游戏体验还不错（除了那个怕鬼的师兄），还送了一个纪念品（下面的是买奶茶送的纪念品）😃\n\n\n最后去吃了碗拉面，味道还是相当不错的，就是价格有点小贵/(ㄒoㄒ)/~~\n饭后去逛了一下，带点东西给室友，最后打的回校\n\n\n  这次行程还是不错的（比呆在学校好多了），发现南昌还是蛮好玩的，但就是不知道下次出去是什么时候了😔\n","slug":"tuoli","date":"2020-12-19T02:48:28.000Z","categories_index":"生活","tags_index":"娱乐","author_index":"Krito"},{"id":"062329fe746a623bd0d6f959084d4dc0","title":"C语言基础知识","content":"原本早就开始学习C语言，但是因为过于心急直接开始实操（如果只是对C语言感兴趣或者想要了解一下C语言，个人推荐《啊哈C》），最后发现学习难以进行下去，于是重新开始再学一遍。在学习C语言之前，个人建议先学习汇编语言，汇编语言可以加深对计算机的理解，方便日后的学习。\n初步认识C 语言是一种通用的、面向过程式的计算机程序设计语言，C 语言是一种通用的高级语言。C语言的特点有：\n\n易于学习\n结构化语言\n它产生高效率的程序\n它可以处理底层的活动\n它可以在多种计算机平台上编译\n\n\nC语言程序的结构C语言程序主要是有函数构成，函数是C语言程序的基本单位。一个C语言源程序必须有一个main函数（也叫主函数），其中可以包含一个main函数和若干个其他函数，但C语言程序主函数只能有1个。C程序中main()称之为主函数，是所有程序运行的入口。同时，程序执行总是从main函数开始，如果有有其他函数，则完成对其他函数的调用后再返回到主函数，最后由main函数结束整个程序。\n函数组成函数首部，函数体\n1234567891011121314151617#include &lt;stdio.h&gt;int main ()                  //主函数&#123;    int max(int x,int y);    //对调用函数max的声明    int x,y,z;               //定义整数型变量x,y,z    scanf(&quot;%d%d&quot;,&amp;x,&amp;y);      //输入变量x,y的值    z=max (x,y);             //调用函数max，将得到的值赋给z    printf(&quot;Max is %d\\n&quot;,z); //输出z    return 0;&#125;int max(int x,int y)         //定义max函数&#123;                            //定义变量z为整数型    int z;                   //如果x&gt;y，则将x的值赋给变量z    if (x&gt;y) z=x;            //否则，将y的值赋给变量z     else z=y;                //将z的值返回到主函数中调用函数的位置    return (z);&#125;\n\n\nint main()和int max(int x,int y)都是函数首部\n\n函数下面的{}内的部分是函数体。函数体包括声明部分和执行部分\n\n\n运行C程序的步骤1、上机输入和编辑源程序\n2、对源程序进行编译\n3、进行连接处理\n4、运行可执行程序，得到运行结果\n\n\n\n程序算法+数据结构=程序\n\n数据结构\n在程序中要指定用哪些数据和这些数据的类型以及数据的组织形式，这就是数据结构\n\n算法\n算法是解决“做什么”和“怎么做”的问题。程序中的操作语句，就是算法的体现\n表示算法的方法：自然语言、传统流程图、结构化流程图、伪代码等\n\n\n数型类型（64位）\n\n\n类型\n字节数\n取值范围\n\n\n\nchar(字符型)\n1\n\n\n\nfloat(浮点型)\n4\n\n\n\ndouble(浮点型)\n8\n\n\n\n[ signed] int (基本整型)\n4\n-2^31~2^31-1\n\n\nunsigned int (无符号基本整型)\n4\n0~2^31-1）\n\n\n[ signed ]short [ int ] (短整型)\n2\n-2^15~2^15-1\n\n\nunsigned short [ int ] (无符号短整型)\n2\n0~2^16-1\n\n\nlong [int] (长整型)\n4\n-2^31~2^31-1\n\n\nunsigned long [ int ] (无符号长整型)\n4\n0~4294967295\n\n\nlong long [ int ] (双长型)(c99支持)\n8\n-2^63~2^63-1\n\n\nunsigned long long [ int ] (无符号双长整型)\n8\n0~2^64-1\n\n\nlong int(long)和int的区别：虽然都是4字节没什么区别，但是这是在64位的标准，如果在16位或者在32位的电脑上面就不一定是都是4字节，16位机：int的取值位16位，long int的取值为32位；32位机：int的取值位32位，long int的取值为32位；64位机：int的取值位32位，long int的取值为32位，所以会满足下面的关系。\nlong≥int≥short\n格式化输入输出输出数据输出字符串需要%s (%5.2s其中5的意思是长度，2的意思是保留个数) //比如输出hello字符串，%5.2s就会输出：   he\n输出 char 类型数据需要  %c\n输出 float 类型数据需要  %f (默认是六位小数，如果想控制保留的位数需加“.x”x是所要保留的位数，如保留两位小数：%.2f)\n输出 double 类型数据需要  %f\n输出 int 类型数据需要  %d (如果d前面加数字意思时补位)\n输出 unsigned int 类型数据需要  %u\n输出 short 类型数据需要  %hd\n输出 unsigned short 类型数据需要  %u\n输出 long 类型数据需要  %ld(也可以使用%d，但是这会给程序移植到其他系统（这两种数据类型的长度不一样的系统）带来麻烦，所以建议使用%ld)\n输出 unsigned long 类型数据需要  %lu\n输出 long long 类型数据需要  %lld\n输出 unsigned long long 类型数据需要  %llu\n输出 变量地址需要%p\n*在%后面加 * 是指宽度（自己决定），例如：printf(“%d”,width,a)\nfloat 和 double 虽然类型都是浮点型，但是double双精度更为精确，但是double更占内存，所以要根据情况而定。\n不同位数计算机中数据类型所占字节数有些不同，上述所述为32位计算机\n如果规定输出格式，如输出的数据必须为八进制或十六进制则需要以下方式输出\n按特定格式输出八进制：%o  %#o(格式化)\n十六进制：%x  %#x(格式化)\n12345678910#include&lt;stdio.h&gt;int main()&#123;\tint a;\ta=100;\tprintf(&quot;%O  %#o \\n&quot;,a,a);\tprintf(&quot;%X  %#x&quot;,a,a);\tgetchar(); \treturn 0;&#125;\n\n输出\n\n\n特殊字符输出“ ？”：/？\n输出 “/” ：//\n输出 “%” ：%%\n断行（就是输出太多，一行放不下，需要另起一行）：/\n返回值printf返回值一般是用于检测是否打印错误，返回值是输出字符的个数（scanf的返回值也是如此）\n123456789#include&lt;stdio.h&gt;int main()&#123;    int rv;    rv=printf(&quot;Hello World\\n&quot;);    printf(&quot;%d&quot;,rv);    getchar();    return 0;&#125;\n\n输出\n\n\nrv=printf(“Hello World”)这一行的作用一是打印Hello World,而是将printf的返回值赋给rv（“\\n”算一个）\nscanf输入scanf用法和printf类似，要注意的是scanf读取一个数的时候要加地址符&amp;，但如果是数组则不需要加（因为数组的名字就是地址，不需要再寻找\n输入double时不是 ”%f“ 而是 ”%lf“，而float则是 “%f”\n输入时读取到空格和回车视为读取结束\n如果输入时一开始就是空格，那么计算机就会一直往后读取直到遇到数字或者符号（例外%c可以读取空格）\n%后面加 “ * ” 意思是丢弃不读入，如：scanf(“%*d %c”,&amp;a)，其中a的值是读入的%c，前面的直接被丢弃\n\n输入、输出函数前面讲了格式化输入输出，但发现仅仅使用格式化输入输出有时会显得十分繁琐，所以需要我们学习其它的输入输出函数\n字符输入输出（getchar/putchar）\n有些时候，仅仅为了在显示器屏幕上打印或从控制台获取一个字符，此时使用功能强大的printf与scanf函数，则显得过于繁琐，C提供了一个库函数putchar/getchar来完成这个简单的任务。\n\ngetchar()函数只能读取单个字符，有时只读取一个字符（注意是以字符的形式存储）时较为方便，例：a=getchar();scanf(“%c”,&amp;a);\nputchar()函数是字符输出函数， 其功能是在显示器上打印单个字符。putchar函数是一个标准的C语言库函数，它的函数原型在头文件“stdio.h”中。\nscanf与getchar\n首先，我们输入时，比没有直接被读取，而是先存放在缓冲区，在被读取。知道这个原理后就可以比较scanf和getchar，拿一个例子来讲解\n1234567891011#include &lt;stdio.h&gt;int main()&#123;    int a,b;    char c;    scanf(&quot;%d&quot;,&amp;a);    scanf(&quot;%d&quot;,&amp;b);    c=getchar();    printf(&quot;%d %d %c&quot;,a,b,c);    return 0;&#125;\n\n输入：1 &lt;回车&gt;2\n输出结果是：第一行：1 2  第二行： \n首先，输入1 回车后，1会存进变量a中，而回车还会停留在缓冲区，之后输入2，此时缓冲区存放了回车和2，但是scanf是无法读取回车，所以回车被跳过，2存进了变量b中，因为scanf可以读取回车（即换行），所以缓冲区的回车就会进入c中，最后就会输出如上结果\n字符串输入输出函数 （gets与puts）gets函数从标准输入设备读字符串函数。可以无限读取，不会判断上限，以回车结束读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。此函数在stdio.h头文件中定义的。当然，scanf也可以做到。例如：gets(a);scanf(“%[ ^\\n ]”,a)（其中a是数组）\nputs函数功能非常单一，在显示器屏幕上输出一个字符串，并换行。\ndefine\n之所以单独拿出来讲，是因为容易出错\n\n用法**#define 标识符 常量 ** //注意, 最后没有分号，同时标识符和常量间只有一个空格\n作用define作用类似于赋值，但它更加灵活，可以将用一些字符代替字符串，如：\n#define A “nihao”；#define A 0；#define A ‘a’\n因为nihao是字符串，所以需要加双引号，如果只是数字就不需要，如果是字符就需要单引号。除此之外，虽然没有硬性规定define后面定义的字符要大写，但一般都是要遵守的\n易错点12345678910#include&lt;stdio.h&gt;#define M 3+1int main()&#123;    int a;    a=M*M/2;    printf(&quot;%d&quot;,a);    getchar();    return 0;&#125;\n\n上面代码输出结果很容易被认为是8，但实际输出结果是6\n错误原因：\n首先，M被定义为3+1，在计算a前不会编译器不会先计算3+1而是直接将3+1带入进去，所以a=M * M/2就变成了a=3+1 * 3+1,之后因为M是整型数据，所以会把小数点后面的数丢弃所以最终答案为6\n与const的区别\n编译器处理方式不同 　#define宏是在预处理阶段展开。　const常量是编译运行阶段使用。\n\n\n类型和安全检查不同 　#define宏没有类型，不做任何类型检查，仅仅是展开。　const常量有具体的类型，在编译阶段会执行类型检查。\n\n\n存储方式不同 　#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）　const常量会在内存中分配(可以是堆中也可以是栈中)。\n\n\nconst  可以节省空间，避免不必要的内存分配。 例如： #define NUM 3.14159  //常量宏 const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 …… double i = Num; //此时为Pi分配内存，以后不再分配！ double  I= NUM; //编译期间进行宏替换，分配内存 double j = Num; //没有内存分配 double J = NUM; //再进行宏替换，又一次分配内存！ const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。\n提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。\n宏替换只作替换，不做计算，不做表达式求解; 宏预编译时就替换了，程序运行时，并不分配内存。\n\n运算符i++与++i的区别（i–和–i同理）：\n12345678910#include&lt;stdio.h&gt;int main()&#123;    int i;    i=1;    printf(&quot;%d %d&quot;,i++,++i);    printf(&quot;%d %d&quot;,i,i);    getchar();    return 0;&#125;\n\n输出：\n1 2\n2 2\ni++是运行这条指令后加一，而++i是运行前加一，所以会出现一开始输出1 2这种情况，同时，递增（递减）的运算优先级很高，只有圆括号比它高，所以使用时需注意，例如，a * b++不会等于a*b+1而是（a) * （b+1）。\n不同类型数据运算：\n不同类型数据进行计算时，编译器会将低精度数据转化为高精度，如\n123456789#include&lt;stdio.h&gt;int main()&#123;\tint a;    float b;    print(&quot;%d&quot;,a/b);    getchar();    return 0;&#125;\n\n在运算a/b时，a会自动升级为float型，当然，也可以强制转化，在a前面加（float）就可以使a转换为float型\n定义函数无参数有返回值如果函数不接收用户传递的数据，那么定义时可以不带参数。如下所示：\n1234dataType functionName()&#123;  &#x2F;&#x2F;body&#125;\n\n\ndataType 是返回值类型，它可以是C语言中的任意数据类型，例如 int、float、char 等。\n\nfunctionName 是函数名，它是标识符的一种，命名规则和标识符相同。函数名后面的括号( )不能少。\n\nbody 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由&#123; &#125;包围。\n\n如果有返回值，在函数体中使用 return 语句返回。return 出来的数据的类型要和 dataType 一样。\n例：\n12345678int sum()&#123;    int i, sum=0;    for(i=1; i&lt;=100; i++)&#123;        sum+=i;    &#125;    return sum;&#125;\n\n无返回值函数有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，例如：\n1234void hello()&#123;\tprintf (&quot;Hello,world \\n&quot;);    //没有返回值就不需要 return 语句&#125;\n\n有参函数的定义如果函数需要接收用户传递的数据，那么定义时就要带上参数。如下所示：\n1234dataType functionName( dataType1 param1, dataType2 param2 ... )&#123;  //body&#125;\n\ndataType1 param1, dataType2 param2 ...是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由,分隔。参数本质上也是变量，定义时要指明类型和名称。与无参函数的定义相比，有参函数的定义仅仅是多了一个参数列表。\n例：\n123456789101112131415161718192021#include &lt;stdio.h&gt;//计算从m加到n的值int sum(int m, int n) &#123;    int i;    for (i = m+1; i &lt;= n; ++i) &#123;        m += i;    &#125;    return m;&#125;int main() &#123;    int a, b, total;    printf(&quot;Input two numbers: &quot;);    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);    total = sum(a, b);    printf(&quot;a=%d, b=%d\\n&quot;, a, b);    printf(&quot;total=%d\\n&quot;, total);    return 0;\n\n函数定义处的 m、n 是形参，函数调用处的 a、b 是实参\n","slug":"C","date":"2020-12-10T02:18:47.000Z","categories_index":"基础知识","tags_index":"C","author_index":"Krito"},{"id":"663c77d5ec7d7de4374e915594360d5a","title":"Assembly Language","content":"学习目的通过用汇编语言进行编程而深入地理解计算机底层的基本工作机理，达到随心所欲地控制计算机的目的\n汇编语言的由来对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。\n\n汇编语言的特点\n机器相关性：\n一种面向机器的低级语言，几乎接近机器语言\n\n不可移植：\n不同类型的CPU有不同的机器指令系统，也就有不同的汇编语言\n\n操作对象：\n汇编语言是直接面向处理器（Processor）的程序设计语言，它所操作的对象不是具体的数据,而是寄存器或者存储器\n\n高速度和高效率：\n汇编语言保持了机器语言的优点，具有直接和简捷的特点，可有效地访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等，且占用内存少，执行速度快，是高效的程序设计语言\n\n编写和调试的复杂性\n由于是直接控制硬件，且简单的任务也需要很多汇编语言语句，因此在进行程序设计时必须面面俱到，需要考虑到一切可能的问题，合理调配和使用各种软、硬件资源。这样，就不可避免地加重了程序员的负担。与此相同，在程序调试时，一旦程序的运行出了问题，就很难发现\n\n\n\n汇编语言的组成汇编指令\n机器码的助记符，有对应的机器码，最终被cpu执行\n\n具体请参考网页链接\n伪指令\n没有对应的机器码，由编译器执行，计算机不执行\n\n其它符号\n如+、-、*、/等，由编译器识别，没有对应的机器码\n\n以下为一段简单的汇编语言源程序\n1234567891011assume cs:codesgcodesg segment       mov ax,0123H       mov bx,0456H       add ax,bx       add ax,ax              mov ax,4c00       int 21Hcodesg endsend\n\n\nXXX segment,XXX ends,end,assume都是伪指令\n\nmov,add，int 21H都是汇编指令\n\n补上一个注意细节：汇编语言时不允许数据用字母开头（重要！！）\n12mov AX, FFFFH\t;这是错误写法，会报错！！mov AX, 0FFFFH\t;这样写就对了，写个0为了使数据开头不是字母\n\n\n编译器编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。\n\n\n\n\n\n寄存器(8086CPU)\nCPU 还自带寄存器（register），用来储存最常用的数据。那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。\n\n\n所有寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW\n\nAX、BX、CX、DX\n\n存放一般性数据的通用寄存器\n可分为两部分，如AX可以为AH和AL\n\n\nCS、DS、SS、ES都是段寄存器\n\n在8086cpu中不支持将数据直接送入段寄存器中\n\n\nCS和IP\n\nCS为代码段寄存器\nIP为指令指针寄存器\nCS和IP使cpu读取指定单元\n\n\nDS\nDS通常用来存放要访问数据的段地址\n比如要读取10000H单元的数据，可以按如下程序段进行：\n12345mov bx,1000Hmov ds, bx(bx起中转作用)mov al,[0]([]代表一个内存单元，[]里面的数代表偏移地址，段地址默认为ds中的数据)\nSS和SP\n\n栈顶的段地址存放在段寄存器SS中\n栈顶的偏移地址存放在寄存器SP中\n任何时候，SS：SP指向栈顶元素\n当有元素入栈后，SP=SP－2；当有元素出栈后,SP=SP＋2\n执行t命令时，执行与ss相关的指令后自动执行与sp相关的指令\n\n\n\n\n内存模型\n寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。\n\nHeap（堆）\n用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。\nHeap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。\n\n程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。\n\n\n程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。\n\n\nStack(栈)\n除了内存模型 (Heap) 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。\n栈是一种具有特殊的访问方式的存储空间。特点为“先进后出，后进先出”\n\n栈顶超界问题当栈顶超过了栈空间，栈外面的数据将被覆盖\n\n\n栈段\n在编程时，可以根据需要，将一组内存单元定义为一个段\n\n一个栈段最大可设为64KB（因为一个栈段最多从0~FFFFH）\n\n数据宽度\n在计算机中，由于受硬件的制约，数据都是有长度限制的，超过最多宽度的数据会被丢弃\n\n\n计算机中常见的数据宽度\n\n位（bit）、字节（byte）、字（word）、双字（doubleword）\n\n存储范围\n\n字节：0~0×FF\n字：0~0×FFFF\n双字：0~0×FFFFFFFF\n(“0×”代表十六进制)\n\n存储单元\n电子计算机最小信息单位是bit,也就是一个二进制位\n\n存储单元可以存储1byte，即两个十六进制位\n\n存储单元从零开始顺序编号\n\n\n\n总线\n地址总线\n\nN根地址线，则地址总线的宽度为N，寻址能力为2^N Byte\n内存地址空间大小受cpu地址总线宽度的限制\n\n\n数据总线\nN根数据总线一次传输N个二进制位\n\n控制总线\n控制总线的宽度决定了cpu对外部器件的控制能力\n\n\n\n存储器\n从读写属性分类\n\n\n随机存储器(RAM)\n用于存放供cpu使用的绝大部分程序和数据(可随时读写，但一旦断电，数据就会消失)\n\n只读存储器(ROM)\n只能读出无法写入信息，信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器\n\n\n\ndebug命令\ndebug是一个DOS实用程序，是供程序员使用的程序调试工具，可以用它检查内存中任何地方的字节以及修改任何地方的字节。它可以用于逐指令执行某个程序以验证程序运行的正确性，也可以追踪执行过程、比较一个指令执行前后的值以及比较与移动内存中数据的范围，读写文件与磁盘\n\n具体请参考网页连接\n\n由于win10不再像win7可以直接进入debug模式，所以需要其它方法进入\n\n如何进入debug模式请参考我的另一篇文章\nwin64位系统进入debug\n\n程序从写出到执行的过程\n编写\n在上编写代码，结果是产生了一个存储源代码的文本文件\n编译器是一种特殊的程序，它可以把以特定编程语言写成的程序变为机器可以运行的机器码。\n\n编译链接\n\n编译\n编译的意思就是把程序语言写成机器可以运行的机器码的过程，此过程需要用到编译器。\n\n连接\n在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。\n对于连接的过程，可执行文件是我们要得到的最终结果\n其作用：\n\n当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件\n程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行 文件\n一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。\n\n\n\n\n执行\n操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化，然后由CPU执行程序\n\n\n","slug":"Assembly Language","date":"2020-12-08T12:45:27.000Z","categories_index":"基础知识","tags_index":"Assembly Language","author_index":"Krito"},{"id":"53611955a6f979c71a5255210a5666f4","title":"markdown语法","content":"\n搭建好博客后没有直接开始写文章是因为写文章时遇到了很多问题，之后去b站和百度上了解了一下，学到了一些关于markdown语法的使用方法，在此分享一下\n\n标题“#”一级标题\n“##”二级标题\n……（共六级标题，“#”后面要空一格）\n效果如图\n\n\n\n\n引用&lt;一级引用\n&lt;&lt;二级引用\n&lt;&lt;&lt;三级引用\n……(可不断嵌套）\n效果如图\n\n\n字体斜体要加粗的文字左右分别用两个*号包起来\n加粗要加粗的文字左右分别用两个*号包起来\n斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来\n删除线要加删除线的文字左右分别用两个~号包起来\n1234**这是加粗的文字***这是倾斜的文字*&#96;***这是斜体加粗的文字***~~这是加删除线的文字~~\n\n字体与颜色12345678&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;&lt;font color&#x3D;red&gt;我是红色&lt;&#x2F;font&gt;&lt;font color&#x3D;#008000&gt;我是绿色&lt;&#x2F;font&gt;&lt;font color&#x3D;Blue&gt;我是蓝色&lt;&#x2F;font&gt;&lt;font size&#x3D;5&gt;我是尺寸&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;黑体&quot; color&#x3D;green size&#x3D;5&gt;我是黑体，绿色，尺寸为5&lt;&#x2F;font&gt;\n\n\n\n分割线可用三个或三个以上“ - ”或者“ _ ”生成分割线（两个个效果都一样)\n隐藏内容(隐藏内容不会直接显示在博客主页，需要点进去看)\n1在&lt;!--more--&gt;输入的文章内容不会直接显示在博客页面\n\n\n\n\n\n图片引用链接引用在src=后面加入照片地址，width指照片宽度，height指照片高度\n例如\n1&lt;img src=&quot;http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg&quot; width=&quot;251&quot; height=&quot;350&quot; &gt;\n\n本地引用与链接引用类似，不过需要将网址改为路径（如果在相同目录里面，只需要将填写对应文件夹即可）\n1&lt;img src&#x3D;&quot;&#x2F;images&#x2F;1.jpg&quot; height&#x3D;&quot;400&quot; width&#x3D;&quot;350&quot; &#x2F;&gt;\n\n\n\n\n\n照片居中1&lt;div align&#x3D;right&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;pic11.photophoto.cn&#x2F;20090626&#x2F;0036036341009653_b.jpg&quot; width&#x3D;&quot;50%&quot; height&#x3D;&quot;50%&quot;&gt;&lt;&#x2F;div&gt;\n\n\n\n\n\n超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加\n\n\n\n\n\n列表无序列表12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格\n\n三个效果都一样\n有序列表数字加点\n列表嵌套上一级和下一级之间敲三个空格即可\n例如\n\n一级无序列表内容\n\n二级无序列表内容\n\n\n二级无序列表内容\n二级无序列表内容\n\n\n一级无序列表内容\n\n二级有序列表内容\n二级有序列表内容\n二级有序列表内容\n\n\n\n\n一级有序列表内容\n二级无序列表内容\n二级无序列表内容\n二级无序列表内容\n\n\n一级有序列表内容\n二级有序列表内容\n二级有序列表内容\n二级有序列表内容\n\n\n\n视频引用与照片引用类似\n12&lt;video src&#x3D;&#39;&#x2F;视频路径&#x2F;选择视频&#39; heigth&#x3D;&#39;高度&#39; controls&gt;例如：&lt;video src&#x3D;&#39;&#x2F;video&#x2F;1.mp4&#39; heigth&#x3D;&#39;500px&#39; controls&gt;\n\n\n\n\n\n","slug":"markdown","date":"2020-12-07T12:33:55.000Z","categories_index":"笔记","tags_index":"学习","author_index":"Krito"},{"id":"ebab8c4f399bfb20ac63ab99ee74d493","title":"debug安装与配置","content":"win64位系统进入debug\n最近一直在看汇编语言，想要实操，于是要进入debug模式，但是发现win64位系统无法直接进入，但最后经过几次尝试终于成功进入\n\n安装1、首先要下载安装DOSBox，也就是下面这个东西\n\n\n安装地址：链接：https://pan.baidu.com/s/1B0dzSc--Ok_ds67ai4flmQ     提取码：a7tp \n2、因为软件比较小，为了避免麻烦，我直接默认安装在C:\\Program Files (x86)中\n3、找到 debug.exe，并把你喜欢的位置上，记住目录（等会用到）这里我放在D:\\Debug目录下\n配置打开DOSBox.exe，输入以下指令\n123mount c d:\\debugc:debug\n\n\n\n之后就进入了debug模式\n调试如果嫌每次进入都需要输入很麻烦，可以在DOSBox 0.74 Options.bat的脚本文件进行修改，步骤如下：\n1、找到DOSBox 0.74 Options.bat，双击点开\n2、点开后拉至最底下输入\n12mount c d:\\debugc:\n\n3、保存退出\n\n\n注意开 DOSBox 会同时打开两个窗口，其中一个是黑色的控制台窗口，在控制台窗口中指明了配置文件的绝对路径\n","slug":"debug安装与配置","date":"2020-12-06T12:33:40.000Z","categories_index":"笔记","tags_index":"学习","author_index":"Krito"},{"id":"ce9156f0e3c852946bbfbbd9e0a335db","title":"我的第一篇文章","content":"新的开始这是本人第一次搭博客，走了许多弯路，经过了无数次的失败，浪费了大量的时间，但最终还是搭建完成。在这其中，我请教了石师兄和高师兄，借鉴了B站的视频，才最终成功。最后，我希望迈出这一小步后能够继续向前，并成为我想成为的人。\n\n\n音频测试照片\n\n音乐\n\n视频\n\n\n\n","slug":"My-First-Post","date":"2020-11-21T07:48:03.000Z","categories_index":"心得","tags_index":"感想","author_index":"Krito"}]