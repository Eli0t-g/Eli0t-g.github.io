[{"id":"9ff0661d271d78f07f1daca34ed70245","title":"nc使用与堆栈溢出","content":"test_your_nc思路考察nc使用，直接nc连接就可以得到flag了\n\nnc介绍nc 是 netcat 的简写，有着网络界的瑞士军刀美誉。因为它短小精悍、功能实用，被设计为一个简单、可靠的网络工具。比如大家很熟悉使用 telnet 测试 tcp 端口，而 nc 可以支持测试 linux 的 tcp 和 udp 端口，而且也经常被用于端口扫描，甚至把 nc 作为 server 以 TCP 或 UDP 方式侦听指定端口做简单的模拟测试。\nnc使用1nc [-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...]\n\nnc 的作用：\n\n实现任意 TCP/UDP 端口的侦听，nc 可以作为 server 以 TCP 或 UDP 方式侦听指定端口\n端口的扫描，nc 可以作为 client 发起 TCP 或 UDP 连接\n机器之间传输文件\n机器之间网络测速\n\nnc 的控制参数不少，常用的几个参数如下所列：\n\n-l ：用于指定 nc 将处于侦听模式。指定该参数，则意味着 nc 被当作 server，侦听并接受连接，而非向其它地址发起连接。\n\n-p：暂未用到（老版本的 nc 可能需要在端口号前加 - p 参数）\n\n-s：指定发送数据的源 IP 地址，适用于多网卡机\n\n-u：指定 nc 使用 UDP 协议，默认为 TCP\n\n-v：输出交互或出错信息，新手调试时尤为有用\n\n-w：超时秒数，后面跟数字\n\n-z：表示 zero，表示扫描时不发送任何数据\n\n\nrip思路首先查看附件，发现没开什么保护，丢进IDA里面看一下\n\n发现可疑fun函数，点进去可以发现函数调用了/bin/sh，于是我们可以利用这个函数得到flag\n接下来就可以开始调试了。首先创造一个长度为150的字符串，运行该程序，将那个字符串输入进去\n之后程序直接报错，因为return地址处不是一个正确的地址值，无法跳转。通过return的那个地址值，我们可以计算return距离输入点的长度。使用cyclic计算偏移量\n得到偏移量就可以写exp了\n编写EXP123456from pwn import *p = remote(&#x27;node3.buuoj.cn&#x27;,28652)fun = 0x401186payload = &#x27;a&#x27;*23+p64(fun+1)p.sendline(payload)p.interactive()\n\n分析EXP解释一下fun加一的原因：首先要明确使用完堆栈需要将堆栈恢复，也就是堆栈平衡，如果堆栈没有平衡就会发生一系列错误。明确以后就可以往下看了，首先了解一下ret指令的工作原理：执行ret指令系统会将esp指向堆栈的值赋给eip之后esp会增加。如下图：\n我们可以看堆栈图表，正常情况下，执行完ret指令esp最终会指向参数区，而溢出情况一个是跳过push ebp一个没有跳过，而没跳过就会导致堆栈不平衡就会报错。\n为什么会有push ebp呢？这就要看fun函数对应的汇编代码，如下图，如果我们直接跳转到fun函数第一条指令就是push rbp（忘了是64位，加上比较懒就没改了），所以就会导致堆栈不平衡，导致出错。所以为了解决这个问题，可以选择跳过这条指令，这也就是fun地址加一的原因\n","slug":"nc使用与堆栈溢出","date":"2021-05-23T05:47:11.000Z","categories_index":"PWN","tags_index":"wp","author_index":"Krito"},{"id":"dde0577c288faf648c0d6f90bbb39dc6","title":"CISCN复现","content":"前言初次参加这种大型比赛，给我的感觉就是题目出的挺不错（一题都没做出来），但是这个比赛形式着实令人不解。不仅如此，在写完选择题后系统崩溃也是我没想得到（虽然没有停滞很久，但是感觉很意外，毕竟是国赛）。\nMISC隔空传话附件是一个txt文件，里面全是十六进制码，根据题目搜索发现是PDU编码解码，解码发现前面四行得到有用的信息：flag前面一部分是15030442和w465。而后面则是一堆十六进制码，但是发现在第一行十六进制码的开头几个十六进制码正好是png十六进制文件头，猜测这些应该是png图片的十六进制码，利用脚本将其导出：\n1234567891011121314151617181920212223242526272829303132333435363738394041from selenium import webdriver# 打开读取data.txt文件with open(&#x27;../data.txt&#x27;, &#x27;r&#x27;) as f:    data = f.read()data = data.splitlines()[4:]  # 前四条不是十六进制# 启动谷歌browser = webdriver.Chrome()url = &quot;http://www.sendsms.cn/pdu/&quot;browser.get(url)output = &#x27;&#x27;  # 用于接收结果for i in data:    browser.find_element_by_name(&quot;smsText2&quot;).clear()  # 清空转换框里面的内容    browser.find_element_by_name(&quot;smsText2&quot;).send_keys(i)  # 输入要翻译的内容    browser.find_element_by_xpath(&quot;//input[@name=&#x27;checkButton&#x27;]&quot;).click()  # 点击翻译    recv = browser.find_element_by_name(&quot;smsOut&quot;).get_attribute(&#x27;value&#x27;)  # 获取翻译内容    recv = recv.split()  # 将获得内容按空格分开    n = 0    txt = &#x27;&#x27;    for j in recv:  # 读取需要的信息        if n == 3:  # 获取时间戳            txt += j        if n == 13:            txt += j  # 获取十六进制码            txt += &#x27;\\n&#x27;  # 分行        n += 1    output += txtbrowser.quit()  # 退出浏览器output = output.splitlines()result = &#x27;&#x27;time = []data = []for i in output:  # 按时间戳进行排序    time.append(int(i[3:5]) * 60 + int(i[6:8]) - 1800)    data.append(i[8:])for i in range(0, 1200):    for j in range(len(data)):        if i == time[j]:            result += data[j]with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f:  # 将结果保存到out.txt文件中    f.write(result)\n\n之后导出图片，发现图片乱七八糟，想到之前w465应该是width465转成十六进制码就是1D1，得到图片\n\n结合前面得到flag：CISCN{15030442_b586_4c9e_b436_26def12293e4}\n","slug":"CISCN复现","date":"2021-05-18T11:25:16.000Z","categories_index":"MISC","tags_index":"wp","author_index":"Krito"},{"id":"7ceb9bfebefe73ecc89b8753e3a43190","title":"pygame使用","content":"\n\n\n\n\n\n\n\n\n了解，学习一个第三方模块，最好是去官网学习，因为官方有第一手资料，而在其他人手里则是第二手，使用要学好还是得去官网。在这里我就直接拿实例讲pygame\n安装pygame (windows)1python -m pip install -U pygame --user\n\n可能的报错：\n\n输入python可能会报错，改成python3\n无法下载，检查网络是否正常，确认无误还是无法下载，查看是否使用了梯子，如果使用就关闭。\n\n设计思路设计一个游戏必须先有思路，这里我引用了一个大佬的图片，基本思路差不多，接下来就根据这个思路开始设计这个游戏\n\n首先，在设计时要明确游戏有哪些元素，从而创建对应的类。在飞机大战中，要创建以下几个类：\n\n用于管理游戏资源和行为的类（我是将它放在alien_invasion.py文件中，作为游戏的入口）\n\n存储游戏设置的类（settings.py）\n\n存储飞机的类（ship.py）\n\n存储子弹的类（bullet.py）\n\n存储敌机的类（Alien.py）\n\n存储游戏初始数据的类（game_stats.py）\n\n存储得分的类（scoreboard.py）\n\n存储初始游戏界面的类（bottom.py）\nalien_invasion.py首先要初始化要显示的窗口或屏幕\n12345678910111213141516import sysimport pygameclass AlienInvasion:    def __init__(self):                                    pygame.init()                                                                                   #pygame.init()安全地初始化了所有导入的pygame模块        self.screen = pygame.display.set_mode((1200,800))         #初始屏幕，1200是屏幕宽度，800是屏幕高度        pygame.display.set_caption(&quot;Alien Invasion&quot;)                      #在屏幕边框上面添加游戏名Alien Invasion    def run_game(self):                                                                         #游戏主循环，让游戏不断持续下去        while True:            for event in pygame.event.get():                if event.type == pygame.QUIT:                                          # 如果用户输入q游戏就结束                    sys.exit()            pygame.display.flip()if __name__ == &#x27;__main__&#x27;:      ai = AlienInvasion()    ai.run_game()\n\n相关代码解释：\n**if __ name __ == ‘ __ main ： ‘**： name __ 是当前模块名，当模块被直接运行时模块名为 __ main __ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。（如果还是有疑惑查看链接）\nfor event in pygame.event.get()：Pygame会接受用户的各种操作（比如按键盘，移动鼠标等）产生事件，事件随时可能发生，而且量也可能会很大，Pygame的做法是把一系列的事件存放一个队列里，逐个的处理。这行代码就是将事件逐一读取。\nsettings.py存储游戏元素属性\n123456789101112131415161718192021222324252627282930class Settings:    def __init__(self):        self.screen_width = 1200                 #屏幕宽度        self.screen_height = 600                 #屏幕高度        self.bg_color = (230, 230, 230)      #背景颜色        self.ship_speed = 1.5              \t        #飞船移动速度        self.bullet_speed = 1.5          \t     #子弹速度        self.bullet_width = 3            \t      #子弹宽度        self.bullet_height = 15           \t      #子弹长度        self.bullet_color = (60,60,60)        #子弹颜色        self.bullet_allowed = 5           \t     #子弹数量        self.alien_speed = 1.0            \t     #外星人移动速度        self.fleet_drop_speed = 10           #外星人设置        self.fleet_direction = 1          \t     #1是右移，-1是左移动        self.ship_limit = 3                           #设置生命次数        self.speedup_scale = 1.1               #游戏运行的速度        self.score_scale = 1.5                    #根据游戏速度提高外星人的分数    def initialize_dynamic_settings(self):                              #初始化在整个游戏中更改的设置        self.ship_speed = 1.5                                                         #飞船移动速度        self.bullet_speed = 3.0                                                     #子弹移动速度        self.alien_speed = 1.0                                                       #外星人移动速度        self.fleet_direction = 1                                                       #外星人移动方向        self.alien_points = 50                                                         #每个外星人的分数    def increase_speed(self):                                                                       #提高速度设置和外星人分数        self.ship_speed *= self.speedup_scale        self.bullet_speed *= self.speedup_scale        self.alien_speed *= self.speedup_scale        self.alien_points = int(self.alien_points * self.score_scale)\n\n\n\nship.py\n\n1234567891011121314151617181920212223import pygameclass Plane:    def __init__(self,ai_game):        # 初始化小飞机并设置其初始位置        self.screen = ai_game.screen                                                              #加载图像，并获得其矩形区域        self.settings = ai_game.settings                                                         #读取设置里面的信息        self.img_plane = pygame.image.load(&quot;images/ship.bmp&quot;)          #加载飞船照片        self.screen_rect = ai_game.screen.get_rect()                              #得到飞船的的矩形区域        self.screen_rect = self.screen.get_rect()                                        #得到screen的矩形区域        self.rect.midbottom = self.screen_rect.midbottom                      # 将飞船放到底部中央        self.x = float(self.rect.x)                                                                        #存储飞机的位置    def blitme(self):        # 在指定位置绘制小飞机        self.screen.blit(self.image, self.rect)    def update(self):                                                                                                       #根据运动标记更新飞船的位置        if self.moving_right and self.rect.right &lt; self.screen_rect.right:            #如果飞船向右移动没有超过边界，飞船就向右移动x（x大小根据设置里面的飞船速度）            self.x += self.settings.ship_speed        if self.moving_left and self.rect.left &gt; 0:                                                        #如果飞船向左移动没有超过边界，飞船就向左移动x             self.x -= self.settings.ship_speed             self.rect.x = self.x                                                                                             #更新飞船位置    def center_ship(self):                                                                                 #将飞船居中        self.rect.midbottom = self.screen_rect.midbottom                       #定义飞船居中位置为屏幕下面底部中央        self.x = float(self.rect.x)                                                                         #更新飞船位置\n\nbullet.py123456789101112131415161718import pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    def __init__(self, ai_game):                                                                   #在舰船的当前位置创建一个子弹对象        super().__init__()                                                                                   #继承        self.screen = ai_game.screen        self.settings = ai_game.settings        self.color = self.settings.bullet_color        self.rect = pygame.Rect(0, 0, self.settings.bullet_width,self.settings.bullet_height)              #创建一个子弹并放置在正确位置        self.rect.midtop = ai_game.ship.rect.midtop        self.y = float(self.rect.y)                                                                          #存储子弹的位置    def update(self):                                                                                            #更新子弹位置        self.y -= self.settings.bullet_speed        self.rect.y = self.y    def draw_bullet(self):                                                                                   #在屏幕上绘制子弹        pygame.draw.rect(self.screen, self.color, self.rect)\n\ngame_stats.py1234567891011121314class GameStats:    &quot;&quot;&quot;Track statistics for Alien Invasion.&quot;&quot;&quot;        def __init__(self, ai_game):        &quot;&quot;&quot;Initialize statistics.&quot;&quot;&quot;        self.settings = ai_game.settings        self.reset_stats()        self.game_active = False                                           #自动开启游戏        self.high_score = 0\t\t\t\t\t\t       #高分永远不要重置。            def reset_stats(self):\t\t\t\t\t\t    #初始化游戏数据        self.ships_left = self.settings.ship_limit        self.score = 0        self.level = 1\n\nscoreboard.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import pygame.fontfrom pygame.sprite import Groupfrom ship import Shipclass Scoreboard:    def __init__(self, ai_game):                       #初始化得分属性        self.ai_game = ai_game        self.screen = ai_game.screen        self.screen_rect = self.screen.get_rect()        self.settings = ai_game.settings                self.stats = ai_game.stats                                      #得分信息的字体设置        self.text_color = (30, 30, 30)        self.font = pygame.font.SysFont(None, 48)        self.prep_score()                                                       #初始乐谱图像        self.prep_high_score()        self.prep_level()        self.prep_ships()    def prep_score(self):        &quot;&quot;&quot;Turn the score into a rendered image.&quot;&quot;&quot;        rounded_score = round(self.stats.score, -1)        score_str = &quot;&#123;:,&#125;&quot;.format(rounded_score)        self.score_image = self.font.render(score_str, True,                self.text_color, self.settings.bg_color)                self.score_rect = self.score_image.get_rect()               #在屏幕右上方显示分数        self.score_rect.right = self.screen_rect.right - 20        self.score_rect.top = 20    def prep_high_score(self):                                                     #将高分转换为图像        high_score = round(self.stats.high_score, -1)        high_score_str = &quot;&#123;:,&#125;&quot;.format(high_score)        self.high_score_image = self.font.render(high_score_str, True,                self.text_color, self.settings.bg_color)                    self.high_score_rect = self.high_score_image.get_rect()          #将高分居中显示在屏幕顶部        self.high_score_rect.centerx = self.screen_rect.centerx        self.high_score_rect.top = self.score_rect.top    def prep_level(self):                                                                      #将等级转换为渲染的图像。        level_str = str(self.stats.level)        self.level_image = self.font.render(level_str, True,                self.text_color, self.settings.bg_color)            self.level_rect = self.level_image.get_rect()                 #将级别定位在分数下方        self.level_rect.right = self.score_rect.right        self.level_rect.top = self.score_rect.bottom + 10    def prep_ships(self):                                                                 #显示生命值        self.ships = Group()        for ship_number in range(self.stats.ships_left):            ship = Ship(self.ai_game)            ship.rect.x = 10 + ship_number * ship.rect.width            ship.rect.y = 10            self.ships.add(ship)    def check_high_score(self):                                               #检查是否有新高分        if self.stats.score &gt; self.stats.high_score:            self.stats.high_score = self.stats.score            self.prep_high_score()    def show_score(self):                                                            #在屏幕上面绘制分数和其它信息        self.screen.blit(self.score_image, self.score_rect)        self.screen.blit(self.high_score_image, self.high_score_rect)        self.screen.blit(self.level_image, self.level_rect)        self.ships.draw(self.screen)\n\nbotto.py123456789101112131415161718192021222324252627import pygame.font class Button:     def __init__(self, ai_game, msg):                 #初始化        self.screen = ai_game.screen        self.screen_rect = self.screen.get_rect()                self.width, self.height = 200, 50               #设置按钮的尺寸和属性        self.button_color = (0, 255, 0)        self.text_color = (255, 255, 255)        self.font = pygame.font.SysFont(None, 48)                self.rect = pygame.Rect(0, 0, self.width, self.height)    #放置play图标        self.rect.center = self.screen_rect.center                self._prep_msg(msg)                                  #该按钮仅需准备一次    def _prep_msg(self, msg):                              #将其转换为渲染的图像，然后在按钮上居中显示文本。        self.msg_image = self.font.render(msg, True, self.text_color,                self.button_color)        self.msg_image_rect = self.msg_image.get_rect()        self.msg_image_rect.center = self.rect.center    def draw_button(self):                                     #在屏幕上面绘制        self.screen.fill(self.button_color, self.rect)        self.screen.blit(self.msg_image, self.msg_image_rect)\n\n重构alien_invasion.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252import sysfrom time import sleepimport pygamefrom settings import Settingsfrom game_stats import GameStatsfrom scoreboard import Scoreboardfrom button import Buttonfrom ship import Shipfrom bullet import Bulletfrom alien import Alien&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;class AlienInvasion:    def __init__(self):        &quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;        pygame.init()        self.settings = Settings()        self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)        self.settings.screen_width = self.screen.get_rect().width        self.settings.screen_height = self.screen.get_rect().height        pygame.display.set_caption(&quot;Alien Invasion&quot;)        &quot;&quot;&quot;创建一个实例来存储游戏统计信息，并创建一个记分板。&quot;&quot;&quot;        self.stats = GameStats(self)        self.sb = Scoreboard(self)        self.ship = Ship(self)        self.bullets = pygame.sprite.Group()        self.aliens = pygame.sprite.Group()        self._create_fleet()        &quot;&quot;&quot;设置play&quot;&quot;&quot;        self.play_button = Button(self, &quot;Play&quot;)    &quot;&quot;&quot;开启游戏并循环&quot;&quot;&quot;    def run_game(self):        while True:            self._check_events()            if self.stats.game_active:                self.ship.update()                self._update_bullets()                self._update_aliens()            self._update_screen()    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    def _check_events(self):        for event in pygame.event.get():            if event.type == pygame.QUIT:                sys.exit()            elif event.type == pygame.KEYDOWN:                self._check_keydown_events(event)            elif event.type == pygame.KEYUP:                self._check_keyup_events(event)            elif event.type == pygame.MOUSEBUTTONDOWN:                mouse_pos = pygame.mouse.get_pos()                self._check_play_button(mouse_pos)    &quot;&quot;&quot;当玩家单击播放时开始新游戏&quot;&quot;&quot;    def _check_play_button(self, mouse_pos):        &quot;&quot;&quot;Start a new game when the player clicks Play.&quot;&quot;&quot;        button_clicked = self.play_button.rect.collidepoint(mouse_pos)        if button_clicked and not self.stats.game_active:            #重置游戏设置            self.settings.initialize_dynamic_settings()            #重置游戏统计信息            self.stats.reset_stats()            self.stats.game_active = True            self.sb.prep_score()            self.sb.prep_level()            self.sb.prep_ships()            #摆脱任何剩余的外星人和子弹            self.aliens.empty()            self.bullets.empty()                        #建立一个新的舰队并集中舰船            self._create_fleet()            self.ship.center_ship()            #隐藏鼠标光标            pygame.mouse.set_visible(False)    &quot;&quot;&quot;响应按键&quot;&quot;&quot;    def _check_keydown_events(self, event):        if event.key == pygame.K_RIGHT:            self.ship.moving_right = True        elif event.key == pygame.K_LEFT:            self.ship.moving_left = True        elif event.key == pygame.K_q:            sys.exit()        elif event.key == pygame.K_SPACE:            self._fire_bullet()        &quot;&quot;&quot;释放按键&quot;&quot;&quot;    def _check_keyup_events(self, event):        if event.key == pygame.K_RIGHT:            self.ship.moving_right = False        elif event.key == pygame.K_LEFT:            self.ship.moving_left = False    &quot;&quot;&quot;创建一个新的项目符号并将其添加到项目符号组&quot;&quot;&quot;    def _fire_bullet(self):        if len(self.bullets) &lt; self.settings.bullets_allowed:            new_bullet = Bullet(self)            self.bullets.add(new_bullet)    &quot;&quot;&quot;更新项目符号的位置并摆脱旧项目符号&quot;&quot;&quot;    def _update_bullets(self):        # 更新子弹位置        self.bullets.update()        # 消除子弹        for bullet in self.bullets.copy():            if bullet.rect.bottom &lt;= 0:                 self.bullets.remove(bullet)        self._check_bullet_alien_collisions()    &quot;&quot;&quot;子弹与外星人的碰撞&quot;&quot;&quot;    def _check_bullet_alien_collisions(self):        # 消除被打到的子弹和外星人        collisions = pygame.sprite.groupcollide(                self.bullets, self.aliens, True, True)        if collisions:            for aliens in collisions.values():                self.stats.score += self.settings.alien_points * len(aliens)            self.sb.prep_score()            self.sb.check_high_score()        if not self.aliens:            # 销毁现有子弹并建立新的舰队            self.bullets.empty()            self._create_fleet()            self.settings.increase_speed()            # Increase level.            self.stats.level += 1            self.sb.prep_level()    &quot;&quot;&quot;检查舰队是否处于边缘，然后更新舰队中所有外星人的位置。&quot;&quot;&quot;    def _update_aliens(self):        self._check_fleet_edges()        self.aliens.update()        # 寻找与外星人的碰撞        if pygame.sprite.spritecollideany(self.ship, self.aliens):            self._ship_hit()        # 寻找外星人撞到屏幕底部        self._check_aliens_bottom()    &quot;&quot;&quot;检查是否有任何外星人到达屏幕底部&quot;&quot;&quot;    def _check_aliens_bottom(self):        screen_rect = self.screen.get_rect()        for alien in self.aliens.sprites():            if alien.rect.bottom &gt;= screen_rect.bottom:                # Treat this the same as if the ship got hit.                self._ship_hit()                break    &quot;&quot;&quot;被外星人击中&quot;&quot;&quot;    def _ship_hit(self):        if self.stats.ships_left &gt; 0:            # 减少生命，并更新记分板.            self.stats.ships_left -= 1            self.sb.prep_ships()                        # 摆脱任何剩余的外星人和子弹.            self.aliens.empty()            self.bullets.empty()                        # 建立一个新的舰队并集中舰船.            self._create_fleet()            self.ship.center_ship()                        # 暂停            sleep(0.5)        else:            self.stats.game_active = False            pygame.mouse.set_visible(True)    &quot;&quot;&quot;建立外星人的舰队&quot;&quot;&quot;    def _create_fleet(self):        # 创建一个外星人并连续查找外星人的数量。        # 每个外星人之间的间距等于一个外星人的宽度。        alien = Alien(self)        alien_width, alien_height = alien.rect.size        available_space_x = self.settings.screen_width - (2 * alien_width)        number_aliens_x = available_space_x // (2 * alien_width)                # 确定适合屏幕的外星人行数        ship_height = self.ship.rect.height        available_space_y = (self.settings.screen_height -                                (3 * alien_height) - ship_height)        number_rows = available_space_y // (2 * alien_height)                # 建立完整的外星人舰队.        for row_number in range(number_rows):            for alien_number in range(number_aliens_x):                self._create_alien(alien_number, row_number)    &quot;&quot;&quot;创建外星人并将其放置在行中&quot;&quot;&quot;    def _create_alien(self, alien_number, row_number):        alien = Alien(self)        alien_width, alien_height = alien.rect.size        alien.x = alien_width + 2 * alien_width * alien_number        alien.rect.x = alien.x        alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number        self.aliens.add(alien)    &quot;&quot;&quot;如果有任何外星人到达边缘，请做出适当的反应&quot;&quot;&quot;    def _check_fleet_edges(self):        for alien in self.aliens.sprites():            if alien.check_edges():                self._change_fleet_direction()                break                def _change_fleet_direction(self):        &quot;&quot;&quot;放下整个舰队并更改舰队的方向.&quot;&quot;&quot;        for alien in self.aliens.sprites():            alien.rect.y += self.settings.fleet_drop_speed        self.settings.fleet_direction *= -1    &quot;&quot;&quot;更新屏幕上的图像，然后切换到新屏幕&quot;&quot;&quot;    def _update_screen(self):        &quot;&quot;&quot;Update images on the screen, and flip to the new screen.&quot;&quot;&quot;        self.screen.fill(self.settings.bg_color)        self.ship.blitme()        for bullet in self.bullets.sprites():            bullet.draw_bullet()        self.aliens.draw(self.screen)        # 绘制分数信息.        self.sb.show_score()        #如果游戏处于非活动状态，请绘制播放按钮.        if not self.stats.game_active:            self.play_button.draw_button()        pygame.display.flip()if __name__ == &#x27;__main__&#x27;:    # 运行游戏    ai = AlienInvasion()    ai.run_game()\n\n总结在设计时是需要不断对每个模块进行重构，重构的目的一是为了使代码看起来更简洁，而是优化代码，减少不必要的代码。除此之外，还需要对项目进行不断检查，检查是否有bug，对bug要进行即使修改。还有，python虽然使用起来非常方便，但是需要记住的函数却很多，要熟练的使用，必须要能够熟悉相关的第三方库，这样才能做到游刃有余。\n","slug":"pygame使用","date":"2021-05-12T12:25:39.000Z","categories_index":"心得","tags_index":"python","author_index":"Krito"},{"id":"1521d5bfeaaa79eb316ce7916671f885","title":"蓝帽杯MISC","content":"冰墩墩拿到附件拖进虚拟机中使用binwalk查看\n\n发现里面存在rar压缩包，使用foremost进行分离\n\n\n发现音频和提示\n将音频放进010，在结尾发现cipher\n将对应的十六进制码复制下来，搜索以0~F编码的加密方式，发现是url编码。\n对十六进制码进行处理\n解码后发现是一堆表情包\n对表情包进行解码发现无法翻译，搜索了一下发现可能是emoji-aes加密，但缺少密匙，之后回去在看mp3文件，想到misc里面有一个MP3stego的工具，但是还需要一个密码才有行，想到之前的eight numbers，加上题目名称，猜测可能是冬奥会举办日期20220204\n得到一个txt文件，发现是python里面的一种编码方式\n发现是wingdings图标，在线解码，得到密匙How_6ad_c0uld_a_1cePeak_be?   之后进行emoji-aes解码得到flag\n","slug":"蓝帽杯MISC","date":"2021-05-04T02:34:09.000Z","categories_index":"MISC","tags_index":"write up","author_index":"Krito"},{"id":"af7567a01704ef88a3107a466485b1d6","title":"程序员的自我修养","content":"分段基本思路使把一段与程序所需的内存空间大小的虚拟空间映射到某个地址空间。采用分段的方法可以解决以下几个问题\n\n地址空间不隔离。如果不同程序间地址连续很容易被恶意程序通过溢出手段使其它程序崩溃或者产生严重后果，而分段可以避免这种情况，比如此时有A,B两个程序，此时操作系统会分配两个虚拟地址，初始地址都是0x00000000，终止地址为程序的大小，一旦该程序访问超过了这个虚拟地址空间，操作系统就会抛出拒绝访问，如果正常访问，操作系统就会将虚拟地址映射到空闲物理地址中。\n\n\n解决运行地址不确定。每次程序装载运行时，操作系统为其分配的空闲地址是不确定的，比如这次是0x00000000 ~ 0x00A00000，下一次可能就是0x00200000 ~ 0x00C00000，但是采用分段的方法，在虚拟内存中程序起始地址和终止地址不会发生改变，很好的解决了解决运行地址不确定这一问题。\n\n对不同的段设置不同的权限。比如数据段就不会有执行权限，只读段只有读取的权限，有效的防止了溢出攻击，加大程序被攻破的难度\n\n适应CPU的缓存体系。CPU缓存体系被分为数据缓存和指令缓存，采用分段的方法极大地提高了缓存的命中率。\n\n有利于共享空间，节约内存。比如系统在运行某一个程序时，可能出现多个该程序的多个副本，这些副本代码是一样的且只可读，所以可以采取共享一个段的方法来节约内存。\n当然，分段并不是完美无缺的，当内存不够时，操作系统会将一些在内存中进程存进磁盘，采用分段的方法，由于映射的单位是程序，所以换入换出的是整个程序，粒度较大，严重影响了运行速度\n\n\n不要让CPU打盹CPU的价值巨大，为了充分利用CPU，早期采用多道程序的方法利用CPU，就是当某个程序不再需要CPU时，监控程序就会将需要CPU的程序自动开启，虽然提高CPU利用率，但是不能很好满足用户需求，比如用户要启动一个程序，可能要等待上一个程序上一个程序完成才行，这是极为致命，所以改进为分时系统，分时系统能够较好的改良这个问题，如果有个程序在使用CPU，但此时用户要启动另一个程序，系统就会暂停这个程序，去完成用户指定的程序，但这个办法缺点是，如果有个程序霸占CPU，那么即使用户要启动另一个程序依旧要等待，因为所有的优先级是一样的，为了解决这个问题，改进为如今的多任务系统，这个系统中操作系统有了最高权限，接管了所有的硬件资源，且受硬件保护，应用程序都是以进程的运行，它们的权限会比操作系统低，同时，每个进程都会有独立的地址空间，让进程相互分开。不仅如此，每个进程都有有个优先级，能够有序的运行，万一优先级较高的进程霸占了CPU，操作系统就会“出手”暂停这个进程将CPU分给下一个进程，也就是所谓的抢占式。\n进程与线程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程被称为轻量级进程是程序执行流的最小单元，由线程ID，当前指令指针，寄存器集合和堆栈组成。线程可以访问进程内存里面所有数据，甚至包括其他线程等等堆栈(要知道其他线程堆栈的地址，很少见的情况)，当然线程也有私有内存空间，如栈(并非完全私有)，线程局部存储，寄存器。而在Linux下没有线程与进程的概念，但是有类似作用的任务，任务相当于线程，但是任务之间可以选择共享内存空间，这些任务组合起来就相当于Windows下的进程。\n线程同步二元信号量　　是最简单的一种锁，适合只能被唯一一个线程独占访问的资源；对于允许多个线程并发访问的资源，多元信号量简称信号量；\n互斥量　　和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统可以被任意线程获取并释放；也就是说哪个线程锁的，要哪个线程解锁。\n临界区　　是比互斥量更加严格的同步手段。在术语中，把临界区的获取称为进入临界区，而把锁的释放称为离开临界区。与互斥量和信号量的区别：\n　　(1)互斥量和信号量字系统的任何进程都是可见的。\n　　(2)临界区的作用范围仅限于本进程，其他进程无法获取该锁。\n","slug":"程序员的自我修养","date":"2021-05-02T07:24:45.000Z","categories_index":"读书笔记","tags_index":"程序员的自我修养","author_index":"Krito"},{"id":"20bf7105b3d9595b11047eca410abfeb","title":"C语言函数调用与常见调用约定","content":"函数调用下面代码展示了一个简单的加法子函数调用\n12345678910#include&lt;stdio.h&gt;int plus (int a,int b)&#123;    return a+b;&#125;void main()&#123;    int a=1,b=2,c;    c=plus(a,b);&#125;\n\n进入反汇编查看\n\n首先，系统会将1，2分别移动到a，b对应的地址中，之后从右至左将b，a对应地址的值移动到eax，ecx中，之后进行跳转到plus函数的plt表\n\n再跳转到plus函数的实际中\n\n子函数先是把ebp保存在栈中，之后通过mov指令将ebp指向esp指向的位置，esp再进行抬栈处理，然后保存现场（将ebx，esi，edi存储的值保存在堆栈中）,接下来把ebp-0ch对应的地址移动到edi中。之后向ecx赋30h，向eax赋0CCCCCCCCh，然后对es:edi对应的地址开始循环赋值（整个过程就是对缓冲区初始化）。（后面两个不知道是什么，太菜了😅）\n补：缓冲区用于存储函数调用里面申请的变量，因为这些变量存放在缓冲区，当调用完成后缓冲区会被丢弃，所以函数调用里面的变量无法被函数外面访问到\n\n接下来就是将a的值移动到eax中再加b的值，后面再恢复现场，再内平栈（add esp 0C0h）,之后比较esp，ebp是否相同，（如果相同我也不知道会怎么样，😅），然后将esp指向ebp指向的位置，将ebp返回到原来的地方。\n\n最后外平栈（add esp,8），将计算结果从eax移到变量c对应的地址中，至此完成函数调用\n\n常见的三种调用约定（32位）\n第一种就是系统默认的调用约定，调用者清理栈，就是和上面外平栈（add esp,8）差不多\n第二种就是在返回时对ret进行处理，使栈指针指向调用参数前的地址（如：ret 8）\n第三种就是通过寄存器传参，但如果寄存器不够还是得借助栈来传参，因为cpu与寄存器之间传递相对于cpu与内存更快，所以第三种方法在参数较少时，更加高效。\n","slug":"C语言函数调用与常见调用约定","date":"2021-04-25T14:02:30.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"6ab7ba8971edf760af996dc2bda9f711","title":"switch语句高效的原因","content":"switch语句和if语句都是条件判断语句，但是switch语句更加高效，因而许多公司在设计时大多采用switch语句\n\n当分支语句较少时，switch与if语句并没有什么区别都是先判断，之后再跳转\n\n\n\n当分支较多时，switch语句就发生变化，并没有挨个判断再跳转，只跳转了一次\n\n\n\n\nswitch语句会维护一张跳转表，不管case判断语句的值是不是按照顺序的，内存中的地址表都会按照顺序进行排列。分析汇编代码会发现，编译器先是将x的值赋给ecx寄存器，之后ecx减去case中最小值并与case中最大值比较，大于就会跳转到default，不大于就会将ecx寄存器中的值移到edx中,之后跳转到edx * 4+14191Ch对应的地址，查看地址发现ABCD四个字符存放的位置就是相差4个字节。所以，当分支较多时，switch-case不用像if-else if那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位到分支。从数据结构与算法的角度来看，switch 语句相当于一个数组，其查询时间复杂度为 O(1)；而 if-lese 语句相当于一个链表，其时间复杂度为 O(n)\n\n总结使用switch语句时，程序首先判断switch变量是否大于（小于）最大（最小）case 常量，若大于（小于），则跳到default分支处理；否则取得索引号为switch变量大小的跳表项的地址（即跳表的起始地址＋表项大小＊索引号），程序接着跳到此地址执行，到此完成了分支的跳转。。即使case情况不连续或者case情况相差较大时，也能达到相应的效果。\n\n参考文章：https://blog.csdn.net/zbw1185/article/details/103359426\n","slug":"switch语句高效的原因","date":"2021-04-25T04:48:37.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"33eb1f0294c927088b5a7d2617a42d07","title":"从源文件到可执行文件","content":"从源文件到可执行文件C源文件到可执行文件共经历了4个过程，包括预处理、编译、汇编、链接。这里在Linux环境下展示此过程，源代码如下：\n1234567#include&lt;stdio.h&gt;#define hello &quot;Hello World&quot;int main()&#123;\tprintf(hello);    return 0;&#125;\n\n预处理在这个阶段，编译器会做以下事情：\n\n将所有的#define删除，并将宏定义展开。\n处理一些条件预编译指令如#ifndef,#ifdef,#elif,#else,#endif等。将不必要的代码过滤掉。\n处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，因为被包含的文件可能也包含其他文件。\n预处理过程还会过滤掉所有注释/**/和//里面的内容。\n另外还会添加行号和文件名标识。\n最后会保留#pragma编译器指令，因为编译器需要使用它们。\n\n补充：#include&lt;&gt; ，从标准库中寻找头文件，#include””，从当前目录开始寻找头文件。查看预处理后的文件在.i文件中#include&lt;stdio.h&gt;展开，输出里面的宏定义hello也被替换成Hello World\n编译编译阶段，C语言每条语句都以一种标准的文件格式确切地描述了一条低级机器语言指令生成编译后的文件\n\n可以看到C语言文件被翻译成汇编代码，每条语句都以一种标准的文件格式确切地描述了一条低级机器语言指令\n汇编汇编阶段，编译器将hello.s翻译成机器语言指令, 把这些指令打包成一种可重定位目标程序的格式, 并把结果保存在hello.o中, hello.o是一个二进制文件, 它的字节编码是机器语言指令, 而不是字符通过以下指令查看汇编后的文件\n链接在这个阶段，编译器会将含有调用函数的目标文件以某种方式合并起来生成可以执行文件（比如printf函数的目标文件就在printf.o），命令：gcc hello.o -o hello\n","slug":"从源文件到可执行文件","date":"2021-04-21T03:22:39.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"8c5e835735464cb680ea7b5b166e5319","title":"解决hexo博客图片无法加载问题","content":"起初搭建好博客时，发现照片无法上传本地照片，\n\n根据网上的方法整了半天也没整好，最后还是室友告诉我通过下面的方法才可以引用本地照片\n1&lt;img src&#x3D;&quot;path&quot; height&#x3D;&quot;xxx&quot; width&#x3D;&quot;xxx&quot; &#x2F;&gt;\n\n但是用这个方法需要在source目录下创建一个目录来存储照片，后面写多了博客，发现这样会特别杂乱，而且最最重要的是虽然能在博客上显示，但是不能在本地显示，操作起来非常不方便。\n\n于是在网上找了半天，各种方法都是了一遍终于发现解决办法\n参考链接\n首先下载插件：\n1yarn add https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image\n\n之后修改博客根目录文件_config.yml中的 post_asset_folder: false，将其改成post_asset_folder: true（注意冒号后面有个空格）,然后就可以通过markdown语法正常上传照片了\n这个方法不仅支持使用markdown语法，而且写博客会创建一个同名文件夹来存放照片，非常方便，而且最重要的是可以在本地预览\n","slug":"解决hexo博客图片无法加载问题","date":"2021-04-20T08:51:23.000Z","categories_index":"问题","tags_index":"博客","author_index":"Krito"},{"id":"49b5f2dc0a9e31a5cb54c844157811ae","title":"Linux常见的保护机制","content":"checksec（gdb安装好就有）gdb动态调试软件，必备。\n安装：\n1apt-get install gdb\n\n用法作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。\n用法：checksec filename\n例子：\n123456gdb-peda$ checksec startCANARY    : disabled(这个选项表示栈保护功能有没有开启。)FORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : disabled\n\nCANNARY(栈保护)栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈中高危区插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。**\ngcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。\n因此在编译时可以控制是否开启栈保护以及程度，例如：\n123gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F;禁用栈保护gcc -fstack-protector -o test test.c   &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码\n\nFORTIFY(轻微的检查)fority其实是非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memepy,stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf， vsprintf，vsnprintf, gets以及宽字符的变体。FORTIFY_ SOURCE设为1,并且将编译器设置为优化1(gcc -01)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能。\n1234gcc -o test test.c &#x2F;&#x2F; 默认情况下，不会开这个检查 gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查 gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进⾏检查 (特别像某些头⽂件 #include &lt;str _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编 gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查 gcc -D_FORTIFY_SOURCE&#x3D;2 程序执⾏时也会有检查 (如果检查到缓冲区溢出，就终⽌程序) _FORTIFY_SOURCE设为2，有些检查功能会加⼊，但是这可能导致程序崩溃。\n\n\n\nNX（DEP）N X （ D E P）的基本原理是将数据所在内存⻚标识为不可执⾏,当程序溢出成功转⼊shellcode时，程序会尝试在数据⻚⾯上执⾏指令，此时CPU就会抛出异常 ,⽽不是去执⾏恶意指令 。 \n123gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护gcc -z execstack -o test test.c &#x2F;&#x2F; 禁⽤NX保护 gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护\n\n在Windows下，类似的概念为DEP（数据执行保护）,数据执⾏保护( D E P ) （ Data Execution Prevention ） 是⼀套软硬件技术，能 够 在 内 存上执⾏额外检查以帮助防⽌在系统上运⾏恶意代码 ,在最新版的Visual Studio中默认开启了DEP编译选项。\nPIE（ASLR）可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。PIE和ASLR不是一样的作用，ASLR只能对堆、栈,ibc和mmap随机化，而不能对代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。联系点在于在开启ASLR之后，PIE才会生效。\n12345gcc -o test test.c &#x2F;&#x2F; 默认情况下，不开启PIE gcc -fpie -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时强度为1 gcc -fPIE -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时为最⾼强度2 gcc -fpic -o test test.c &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIEgcc -fPIC -o test test.c &#x2F;&#x2F; 开启PIC，此时为最⾼强度2，不会开启PIE\n\n\n\nASLR (Address Space Layout Randomization)ASLR是⼀种针对缓冲区溢出的安全保护技术,通过对堆栈 、共享库映射等线性区布局的随机化，通过增加攻击者预测⽬的地址的难度,防⽌攻击者直接定位攻击代码位置,达到阻⽌溢出攻击的⽬的。 \n参考文章：https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/\n","slug":"linux程序的常⽤保护机制","date":"2021-04-09T13:14:59.000Z","categories_index":"PWN","tags_index":"基础知识","author_index":"Krito"},{"id":"4c0cb40856baa1e8384c37c457fb63f6","title":"指针","content":"\n\n\n\n\n\n\n\n\n指针，并不像一些书上写的只是用于存储地址，它是一种类型数据，存储什么都可以，并不是只能存储地址。\n指针大小常见的指针有：char *，int *，float * …，但char * * *，int * * *…同样也是指针(多级指针)，同时虽然指针类型有很多种，但是无论是什么指针，它的大小都是4字节\n\n\n\n可以看到没有声明指针时抬栈40字节，声明以后抬栈44字节，说明声明变量消耗0x50-0x44h也就是12字节，也就是说每个指针占4字节空间\n指针运算指针只能进行加减法运算，不能乘除运算，同时加法运算并不是普通加法运算，其中遵守着一些规则\n\n如上，左边的输出：101  101  101 ，右边输出：104  104  104，因为右边去掉一个* 还是指针类型数据，如果去掉 * 是char或者int等就是加或减那个类型的大小。\n12345678910#include&lt;stdio.h&gt;void main()&#123;\tint *a;         char *b;\ta=100;         b=100;        printf(&quot;%d &quot;,++a);        printf(&quot;%d &quot;,++b);&#125;\n\n输出结果：104 101\n实例12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#define N 10void swap1(int a,int b);void swap2(int *a,int *b);void swap3(int *a,int *b);int main()&#123;  int c=1,d=2;  swap1(c,d);  printf(&quot;%d %d\\n&quot;,c,d);  swap2(&amp;c,&amp;d);  printf(&quot;%d %d\\n&quot;,c,d);  swap3(&amp;c,&amp;d);  printf(&quot;%d %d\\n&quot;,c,d);  return 0;&#125;void swap1(int a,int b)&#123;  int t;  t=a;  a=b;  b=t;&#125;void swap2(int *a,int *b)&#123;  int t;  t=a;  a=b;  b=t;&#125;void swap3(int *a,int *b)&#123;  int t;  t=*a;  *a=*b;  *b=t;&#125;\n\n这段代码中就只有swap3成功交换了c与d的值，首先每个全局变量或者被调用的变量都有个地址，变量被修改其实就是变量对应的地址的值被修改，如果被修改的值不能返回到地址中，变量就不会改变。在swap1(c,d)中，c与d的值被压入栈中，swap1(c,d)只是处理栈中的值，被修改的值并不会返回到c和d的地址中，所以函数里面再怎么交换也不会影响变量c与d，而swap2(c,d)虽然可以运行，但是是错误的写法，int与int*不能相互赋值，系统并不会执行，同时还会产生警告\n\n而最后的swap3函数则是处理c与d的地址，先将a地址对应的值赋给t，在将b地址的值存入a地址中，最后向b地址存入t值（也就是a的值），符合编译器的调用约定，系统可以执行\n通过这个可知，如果只是将变量的值传入子函数中，并不会影响变量，要想通过子函数修改子函数外的变量，需要找出变量的地址，并将修改的值存入变量地址中。\n1234567891011121314151617#include&lt;stdio.h&gt;void add(int a[],int b,int c);int main()&#123;  int i,a[5]=&#123;1,2,3,4,5&#125;;  add(a,1,5);  for(i=0;i&lt;5;i++)    printf(&quot;%d&quot;,a[i]);  return 0;&#125;void add(int a[],int b,int c)&#123;  int i=0;  for (;i&lt;c;i++)    a[i]+=b;&#125;\n\n这段代码是处理数组的，子函数调用数组时，传入的其实就是该数组的首地址，所以会直接修改数组的值。（为了防止数组被函数修改，可以在调用数组前加const，只要函数修改数组，编译器就会报错。）\n","slug":"指针","date":"2021-03-28T02:54:43.000Z","categories_index":"C语言","tags_index":"收获","author_index":"Krito"},{"id":"0b2fb954c183833919bf074ef85f5195","title":"Assembly Language（32位）","content":"\n\n\n\n\n\n\n\n\n重新复习了一遍汇编，这次看的是32位的，有了一点点收获，就随便写写\n寄存器\n\nx86的寄存器包括8位、16位、32位，其中32位寄存器可以分为16位或者8位，如EAX可以分为16位AX或者8位AH、AL，但是EBX以后的寄存器就不可以了，虽然是通用寄存器但是每个通用寄存器都有一些特殊的用途\nEAXEAX与STOS指令相关，STOS会将EAX的值存进EDI指定的内存单元中，同时还经常存储计算结果\nECXECX与REP指令相关，用于记录指令循环次数\nEDI和ESIEDI和ESI用于做地址复制，将ESI指定的地址中的值赋值到EDI指定的地址中，与movs指令有很大关系\n\n\nESPESP用于存储当前栈堆用到的地址\nEFL（标志寄存器）EFI的第十位（DF）如果是零，使用push，pop指令后ESP会加相应数值，如果是一，则减去相应数值。\nEIPEIP用于存储计算机执行下一个指令的地址\n堆栈\n\n\n\n\n\n\n\n\n堆栈本质就是一段内存，在程序启动前就已经被分配好了，堆栈会存储程序重要的信息，被称为“程序的心脏”\n32位上的应用大部分采用小端模式，手机上的应用大部分采用大端模式\n小段模式从高地址开始存放，往低地址去\n大端模式从低地址开始存放，往高地址去\n指令MOV(移动指令)将指定的值移动指定位置（内存地址或寄存器）\nADD(加法指令)将指定的两个值相加，结果返回到指定位置（内存地址或寄存器）\nSUB(减法指令)将指定的两个值相减，结果返回到指定位置（内存地址或寄存器）\nAND(与运算指令)与运算：两个为一才为一\n将指定的两个值进行与运算，结果返回到指定位置（内存地址或寄存器）\nOR(或运算指令)或运算：有一就为一\n将指定的两个值进行或运算，结果返回到指定位置（内存地址或寄存器）\nXOR(异或运算指令)异或运算：不一样为一\n将指定的两个值进行异或运算，结果返回到指定位置（内存地址或寄存器）\nNOT(非运算指令)非运算：一为零，零为一\n将指定的一个值进行非运算，结果返回原位置（内存地址或寄存器）\nSHL(左移指令)shl（C语言：&lt;&lt;）\n高位丢弃,低位补零\n右移指令汇编 shr：高位补零，低位丢弃\n​         sar：高位补符号位，地位丢弃（就是补最高位的数字）\nC语言 &gt;&gt; 无符号数：高位补零，低位丢弃\n​                 有符号数：高位补符号位，低位丢弃\n","slug":"Assembly Language（32位）","date":"2021-03-22T12:41:01.000Z","categories_index":"基础知识","tags_index":"Assembly Language","author_index":"Krito"},{"id":"6555700b23ec65c00135060dc244ee5c","title":"SSH连接失败","content":"\n\n\n\n\n\n\n\n\n闲的无聊就整了一下博客，结果出大问题了，之前的备份又删了，所以不得不重建，这次重建花了整整一天，虽说浪费时间但是还是有所收获\n搭建博客视频网上一大堆，这里就不多讲了，这里就讲一下错误和如何解决\nssh: connect to host github.com port 22: Connection timed out这个问题烦了我几个小时，网上的解决方法参差不齐（反正我通过网上的方法没用解决），最后还是看官方的解决方法（还是官方的靠谱）Using SSH over the HTTPS port。\n出现这个问题是因为22端口被占用或者防火墙不允许ssh连接。解决方法是通过通过HTTPS启用SSH连接，命令：ssh -T -p 443 &#x67;&#x69;&#116;&#64;&#x73;&#x73;&#104;&#46;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;，运行时输入yes，这样可以强制连接，连接成功后就可以进行下一步操作了（不成功可以看官方给的故障排除指南），成功后，在.ssh文件夹中创建一个config文件（千万千万别加后缀名！）内容如下：\n1234Host github.com  Hostname ssh.github.com  Port 443  User git\n\n最后输入：ssh -T &#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;看是否成功连接\n成功连接如下：\n123$ ssh -T git@github.com&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not&gt; provide shell access.\n\n简单介绍一下SSH，博客上传时，如果没用通过ssh连接的话，需要输入密码，通过ssh远程连接以后就不需要了\n","slug":"SSH连接失败","date":"2021-03-15T13:29:03.000Z","categories_index":"问题","tags_index":"博客","author_index":"Krito"},{"id":"ffd87d4d875bb16286fecb1469508ba7","title":"bugku","content":"BUGKU misc部分1 这是一张单纯的图片先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样，\n\n\n直接丢winhex，拖至最底，发现是unicode加密\n\n\n发现是unicode加密，直接解码成ASCII，得到flag\n\n\n\n2 隐写看到题目就知道是图片隐写，对图片进行校验和，发现结果有问题，说明照片高度被修改了\n\n\n修改高度得到flag\n\n\n\n3 telnet下载附件后打开，直接追踪TCP流就得到了flag\n\n\n\n4 眼见非实打开后发现文件是损坏的而且出现了PK字符，猜测里面藏有压缩包，于是改成压缩包形式打开\n\n\n在word里面的document.xml里面发现了flag\n\n\n\n5 啊哒老规矩，打开照片看属性，发现照相机型号有东西，之后应该用得上\n\n\n用binwalk查看，发现里面藏有一个压缩包，用foremost进行分离得到压缩包，打开发现是加密的，尝试了照相机型号，发现密码错误，分析了一下那串照相机型号，发现是十六进制，之后解码得到密码\n\n\n打开得到flag\n\n\n\n6 ping用wireshark打开后发现十六进制旁边一个f，打开其它的发现组合起来是flag\n\n\n\n7 赛博朋克打开后发现就一个光秃秃的加密文件，不用猜都知道是伪加密，丢进winhex修改一下就可以打开了\n\n\n打开文件后发现是一堆乱码，丢进winhex发现是png格式照片\n\n\n修改一下后缀名图片就出来了，不过好像flag还没出来，属性里面也没什么东西，校验和也正确，binwalk也没查出问题\n\n\n\n\n最后推测一个是lsb隐写，果不其然，得到flag\n\n\n\n8 贝斯手打开介绍发现是对图片上人物介绍，刚想关闭发现最下面还有东西，发现密码是四位数和这个贝斯手有关\n\n\n懒得搜直接暴力破解\n\n\n打开后发现是一串加密字符，5+58应该加密方式MD5和base58\n\n\n解码得到flag\n\n\n\n\n\n9 又一张图片，还单纯吗打开属性发现没有有用的信息，丢进winhex里面也没发现什么，用binwalk查看发现照片里面有其它jpg照片，用forem分离\n\n\n发现图片里面有flag（不过这个flag有点长，有点离谱）\n\n\n\n10 猜签到题，百度识图，发现是刘亦菲，得到flag（注意flag格式）\n\n11 宽带信息泄露下载RouterPassView，用这个搜索username（用户名）\n\n\n\n12 隐写2直接丢进winhex，发现jpg图片结尾后面有压缩包的字符\n\n\n用foremost分离得到一个加密的文件和密码提示，解密（直接爆破，反正是三位数）得到一张图片\n\n\n老规矩丢winhex，发现最后有flag\n\n\n\n13 多种方法解决这道题提示说有二维码，打开附件发现是一个exe可执行文件（尝试打开发现无法运行），直接丢winhex\n\n\n发现是旁边是加密的图片编码，直接在线解码得到flag\n\n\n\n14 闪的好快emmmm，这道题挺简单的就是好烦，用Stegsolve.jar一帧一帧看，扫码，flag就出来了\n\n15 come_game打开后是个游戏，每次死亡都会多个文件，找到save1将它丢尽winhex里面，将2AC改成5AC在进游戏就可以得到flag，当然如果觉得能闯过去也应该能得到flag。（我没试过，不确定能不能行，提醒一下这个游戏打开了好像不能关闭）\n\n\n\n16 白哥的鸽子直接丢进winhex里面，发现照片结尾后面多出一些字符，分析一下就知道是栅栏加密\n\n\n解密（密匙我是一个一个试的，不过还好就是3，后面才知道那个提示“咕咕咕”好像就代表key=3）\n\n\n17 linux看到题目就知道要用Linux系统\n","slug":"bugku","date":"2021-02-02T13:24:11.000Z","categories_index":"MISC","tags_index":"wp","author_index":"Krito"},{"id":"ea7bb1240e1dab8cf5209f8a8c9f1924","title":"快乐周五","content":"\n\n\n\n\n\n\n\n\n这是这几个月最值得纪念的周五，体验了脱离学校的快乐\n2020.12.13\n  晚上和社团其它人一起谋划着“出校大计”，原本定在周六，但是由于学校要体测（挺佩服学校挑时间的能力🤬），不得不将时间改成周五，让快乐减少了一半😔\n2020.12.15\n  果然到了周末就会发现屁事很多😔，一个个周末都有事，只剩几个大男人可以出去，这次出校也变成了“罗汉出行”，照这样下去，不知道之后几天会发生什么😱\n2020.12.17\n  原本课上得好好的，突然一个朋友说周六体测取消了，改了时间，我直接当场爆炸🤬，没办法假条都上交了，时间也不能修改，只能认命\n2020.12.18\n  原本计划好的五个人，要走的时候最后一个人掉链子😔，最后变成四罗汉出行。\n开始打算看电影，但是觉得没什么好看的电影加上时间不够，所以改成了密室逃脱（补充一下，有个当地人带路非常重要😃）\n\n\n\n\n\n\n游戏体验还不错（除了那个怕鬼的师兄），还送了一个纪念品（下面的是买奶茶送的纪念品）😃\n\n\n最后去吃了碗拉面，味道还是相当不错的，就是价格有点小贵/(ㄒoㄒ)/~~\n饭后去逛了一下，带点东西给室友，最后打的回校\n\n\n  这次行程还是不错的（比呆在学校好多了），发现南昌还是蛮好玩的，但就是不知道下次出去是什么时候了😔\n","slug":"tuoli","date":"2020-12-19T02:48:28.000Z","categories_index":"生活","tags_index":"娱乐","author_index":"Krito"},{"id":"062329fe746a623bd0d6f959084d4dc0","title":"C语言基础知识","content":"初步认识C 语言是一种通用的、面向过程式的计算机程序设计语言，C 语言是一种通用的高级语言。C语言的特点有：\n\n易于学习\n结构化语言\n它产生高效率的程序\n它可以处理底层的活动\n它可以在多种计算机平台上编译\n\n\nC语言程序的结构C语言程序主要是有函数构成，函数是C语言程序的基本单位。一个C语言源程序必须有一个main函数（也叫主函数），其中可以包含一个main函数和若干个其他函数，但C语言程序主函数只能有1个。C程序中main()称之为主函数，是所有程序运行的入口。同时，程序执行总是从main函数开始，如果有有其他函数，则完成对其他函数的调用后再返回到主函数，最后由main函数结束整个程序。\n函数组成函数首部，函数体\n1234567891011121314151617#include &lt;stdio.h&gt;int main ()                  //主函数&#123;    int max(int x,int y);    //对调用函数max的声明    int x,y,z;               //定义整数型变量x,y,z    scanf(&quot;%d%d&quot;,&amp;x,&amp;y);      //输入变量x,y的值    z=max (x,y);             //调用函数max，将得到的值赋给z    printf(&quot;Max is %d\\n&quot;,z); //输出z    return 0;&#125;int max(int x,int y)         //定义max函数&#123;                            //定义变量z为整数型    int z;                   //如果x&gt;y，则将x的值赋给变量z    if (x&gt;y) z=x;            //否则，将y的值赋给变量z     else z=y;                //将z的值返回到主函数中调用函数的位置    return (z);&#125;\n\n\nint main()和int max(int x,int y)都是函数首部\n\n函数下面的{}内的部分是函数体。函数体包括声明部分和执行部分\n\n\n运行C程序的步骤1、上机输入和编辑源程序\n2、对源程序进行编译\n3、进行连接处理\n4、运行可执行程序，得到运行结果\n\n\n\n程序算法+数据结构=程序\n\n数据结构\n在程序中要指定用哪些数据和这些数据的类型以及数据的组织形式，这就是数据结构\n\n算法\n算法是解决“做什么”和“怎么做”的问题。程序中的操作语句，就是算法的体现\n表示算法的方法：自然语言、传统流程图、结构化流程图、伪代码等\n\n\n数型类型（64位）\n\n\n类型\n字节数\n取值范围\n\n\n\nchar(字符型)\n1\n\n\n\nfloat(浮点型)\n4\n\n\n\ndouble(浮点型)\n8\n\n\n\n[ signed] int (基本整型)\n4\n-2^31~2^31-1\n\n\nunsigned int (无符号基本整型)\n4\n0~2^31-1）\n\n\n[ signed ]short [ int ] (短整型)\n2\n-2^15~2^15-1\n\n\nunsigned short [ int ] (无符号短整型)\n2\n0~2^16-1\n\n\nlong [int] (长整型)\n4\n-2^31~2^31-1\n\n\nunsigned long [ int ] (无符号长整型)\n4\n0~4294967295\n\n\nlong long [ int ] (双长型)(c99支持)\n8\n-2^63~2^63-1\n\n\nunsigned long long [ int ] (无符号双长整型)\n8\n0~2^64-1\n\n\nlong int(long)和int的区别：虽然都是4字节没什么区别，但是这是在64位的标准，如果在16位或者在32位的电脑上面就不一定是都是4字节，16位机：int的取值位16位，long int的取值为32位；32位机：int的取值位32位，long int的取值为32位；64位机：int的取值位32位，long int的取值为32位，所以会满足下面的关系。\nlong≥int≥short\n格式化输入输出输出数据输出字符串需要%s (%5.2s其中5的意思是长度，2的意思是保留个数) //比如输出hello字符串，%5.2s就会输出：   he\n输出 char 类型数据需要  %c\n输出 float 类型数据需要  %f (默认是六位小数，如果想控制保留的位数需加“.x”x是所要保留的位数，如保留两位小数：%.2f)\n输出 double 类型数据需要  %f\n输出 int 类型数据需要  %d (如果d前面加数字意思时补位)\n输出 unsigned int 类型数据需要  %u\n输出 short 类型数据需要  %hd\n输出 unsigned short 类型数据需要  %u\n输出 long 类型数据需要  %ld(也可以使用%d，但是这会给程序移植到其他系统（这两种数据类型的长度不一样的系统）带来麻烦，所以建议使用%ld)\n输出 unsigned long 类型数据需要  %lu\n输出 long long 类型数据需要  %lld\n输出 unsigned long long 类型数据需要  %llu\n输出 变量地址需要%p\n*在%后面加 * 是指宽度（自己决定），例如：printf(“%d”,width,a)\nfloat 和 double 虽然类型都是浮点型，但是double双精度更为精确，但是double更占内存，所以要根据情况而定。\n不同位数计算机中数据类型所占字节数有些不同，上述所述为32位计算机\n如果规定输出格式，如输出的数据必须为八进制或十六进制则需要以下方式输出\n按特定格式输出八进制：%o  %#o(格式化)\n十六进制：%x  %#x(格式化)\n12345678910#include&lt;stdio.h&gt;int main()&#123;\tint a;\ta=100;\tprintf(&quot;%O  %#o \\n&quot;,a,a);\tprintf(&quot;%X  %#x&quot;,a,a);\tgetchar(); \treturn 0;&#125;\n\n输出\n\n\n特殊字符输出“ ？”：/？\n输出 “/” ：//\n输出 “%” ：%%\n断行（就是输出太多，一行放不下，需要另起一行）：/\n返回值printf返回值一般是用于检测是否打印错误，返回值是输出字符的个数（scanf的返回值也是如此）\n123456789#include&lt;stdio.h&gt;int main()&#123;    int rv;    rv=printf(&quot;Hello World\\n&quot;);    printf(&quot;%d&quot;,rv);    getchar();    return 0;&#125;\n\n输出\n\n\nrv=printf(“Hello World”)这一行的作用一是打印Hello World,而是将printf的返回值赋给rv（“\\n”算一个）\nscanf输入scanf用法和printf类似，要注意的是scanf读取一个数的时候要加地址符&amp;，但如果是数组则不需要加（因为数组的名字就是地址，不需要再寻找\n输入double时不是 ”%f“ 而是 ”%lf“，而float则是 “%f”\n输入时读取到空格和回车视为读取结束\n如果输入时一开始就是空格，那么计算机就会一直往后读取直到遇到数字或者符号（例外%c可以读取空格）\n%后面加 “ * ” 意思是丢弃不读入，如：scanf(“%*d %c”,&amp;a)，其中a的值是读入的%c，前面的直接被丢弃\n\n输入、输出函数前面讲了格式化输入输出，但发现仅仅使用格式化输入输出有时会显得十分繁琐，所以需要我们学习其它的输入输出函数\n字符输入输出（getchar/putchar）\n\n\n\n\n\n\n\n\n有些时候，仅仅为了在显示器屏幕上打印或从控制台获取一个字符，此时使用功能强大的printf与scanf函数，则显得过于繁琐，C提供了一个库函数putchar/getchar来完成这个简单的任务。\ngetchar()函数只能读取单个字符，有时只读取一个字符（注意是以字符的形式存储）时较为方便，例：a=getchar();scanf(“%c”,&amp;a);\nputchar()函数是字符输出函数， 其功能是在显示器上打印单个字符。putchar函数是一个标准的C语言库函数，它的函数原型在头文件“stdio.h”中。\nscanf与getchar\n首先，我们输入时，比没有直接被读取，而是先存放在缓冲区，在被读取。知道这个原理后就可以比较scanf和getchar，拿一个例子来讲解\n1234567891011#include &lt;stdio.h&gt;int main()&#123;    int a,b;    char c;    scanf(&quot;%d&quot;,&amp;a);    scanf(&quot;%d&quot;,&amp;b);    c=getchar();    printf(&quot;%d %d %c&quot;,a,b,c);    return 0;&#125;\n\n输入：1 &lt;回车&gt;2\n输出结果是：第一行：1 2  第二行： \n首先，输入1 回车后，1会存进变量a中，而回车还会停留在缓冲区，之后输入2，此时缓冲区存放了回车和2，但是scanf是无法读取回车，所以回车被跳过，2存进了变量b中，因为scanf可以读取回车（即换行），所以缓冲区的回车就会进入c中，最后就会输出如上结果\n字符串输入输出函数 （gets与puts）gets函数从标准输入设备读字符串函数。可以无限读取，不会判断上限，以回车结束读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。此函数在stdio.h头文件中定义的。当然，scanf也可以做到。例如：gets(a);scanf(“%[ ^\\n ]”,a)（其中a是数组）\nputs函数功能非常单一，在显示器屏幕上输出一个字符串，并换行。\ndefine\n\n\n\n\n\n\n\n\n之所以单独拿出来讲，是因为容易出错\n用法**#define 标识符 常量 ** //注意, 最后没有分号，同时标识符和常量间只有一个空格\n作用define作用类似于赋值，但它更加灵活，可以将用一些字符代替字符串，如：\n#define A “nihao”；#define A 0；#define A ‘a’\n因为nihao是字符串，所以需要加双引号，如果只是数字就不需要，如果是字符就需要单引号。除此之外，虽然没有硬性规定define后面定义的字符要大写，但一般都是要遵守的\n易错点12345678910#include&lt;stdio.h&gt;#define M 3+1int main()&#123;    int a;    a=M*M/2;    printf(&quot;%d&quot;,a);    getchar();    return 0;&#125;\n\n上面代码输出结果很容易被认为是8，但实际输出结果是6\n错误原因：\n首先，M被定义为3+1，在计算a前不会编译器不会先计算3+1而是直接将3+1带入进去，所以a=M * M/2就变成了a=3+1 * 3+1,之后因为M是整型数据，所以会把小数点后面的数丢弃所以最终答案为6\n与const的区别\n编译器处理方式不同 　#define宏是在预处理阶段展开。　const常量是编译运行阶段使用。\n\n\n类型和安全检查不同 　#define宏没有类型，不做任何类型检查，仅仅是展开。　const常量有具体的类型，在编译阶段会执行类型检查。\n\n\n存储方式不同 　#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）　const常量会在内存中分配(可以是堆中也可以是栈中)。\n\n\nconst  可以节省空间，避免不必要的内存分配。 例如： #define NUM 3.14159  //常量宏 const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 …… double i = Num; //此时为Pi分配内存，以后不再分配！ double  I= NUM; //编译期间进行宏替换，分配内存 double j = Num; //没有内存分配 double J = NUM; //再进行宏替换，又一次分配内存！ const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。\n提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。\n宏替换只作替换，不做计算，不做表达式求解; 宏预编译时就替换了，程序运行时，并不分配内存。\n\n运算符i++与++i的区别（i–和–i同理）：\n12345678910#include&lt;stdio.h&gt;int main()&#123;    int i;    i=1;    printf(&quot;%d %d&quot;,i++,++i);    printf(&quot;%d %d&quot;,i,i);    getchar();    return 0;&#125;\n\n输出：\n1 2\n2 2\ni++是运行这条指令后加一，而++i是运行前加一，所以会出现一开始输出1 2这种情况，同时，递增（递减）的运算优先级很高，只有圆括号比它高，所以使用时需注意，例如，a * b++不会等于a*b+1而是（a) * （b+1）。\n不同类型数据运算：\n不同类型数据进行计算时，编译器会将低精度数据转化为高精度，如\n123456789#include&lt;stdio.h&gt;int main()&#123;\tint a;    float b;    print(&quot;%d&quot;,a/b);    getchar();    return 0;&#125;\n\n在运算a/b时，a会自动升级为float型，当然，也可以强制转化，在a前面加（float）就可以使a转换为float型\n定义函数无参数有返回值如果函数不接收用户传递的数据，那么定义时可以不带参数。如下所示：\n1234dataType functionName()&#123;  &#x2F;&#x2F;body&#125;\n\n\ndataType 是返回值类型，它可以是C语言中的任意数据类型，例如 int、float、char 等。\n\nfunctionName 是函数名，它是标识符的一种，命名规则和标识符相同。函数名后面的括号( )不能少。\n\nbody 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由&#123; &#125;包围。\n\n如果有返回值，在函数体中使用 return 语句返回。return 出来的数据的类型要和 dataType 一样。\n例：\n12345678int sum()&#123;    int i, sum=0;    for(i=1; i&lt;=100; i++)&#123;        sum+=i;    &#125;    return sum;&#125;\n\n无返回值函数有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，例如：\n1234void hello()&#123;\tprintf (&quot;Hello,world \\n&quot;);    //没有返回值就不需要 return 语句&#125;\n\n有参函数的定义如果函数需要接收用户传递的数据，那么定义时就要带上参数。如下所示：\n1234dataType functionName( dataType1 param1, dataType2 param2 ... )&#123;  //body&#125;\n\ndataType1 param1, dataType2 param2 ...是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由,分隔。参数本质上也是变量，定义时要指明类型和名称。与无参函数的定义相比，有参函数的定义仅仅是多了一个参数列表。\n例：\n123456789101112131415161718192021#include &lt;stdio.h&gt;//计算从m加到n的值int sum(int m, int n) &#123;    int i;    for (i = m+1; i &lt;= n; ++i) &#123;        m += i;    &#125;    return m;&#125;int main() &#123;    int a, b, total;    printf(&quot;Input two numbers: &quot;);    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);    total = sum(a, b);    printf(&quot;a=%d, b=%d\\n&quot;, a, b);    printf(&quot;total=%d\\n&quot;, total);    return 0;\n\n函数定义处的 m、n 是形参，函数调用处的 a、b 是实参\n","slug":"C","date":"2020-12-10T02:18:47.000Z","categories_index":"基础知识","tags_index":"C","author_index":"Krito"},{"id":"663c77d5ec7d7de4374e915594360d5a","title":"Assembly Language","content":"学习目的通过用汇编语言进行编程而深入地理解计算机底层的基本工作机理，达到随心所欲地控制计算机的目的\n汇编语言的由来对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。\n汇编语言的特点\n机器相关性：\n一种面向机器的低级语言，几乎接近机器语言\n\n不可移植：\n不同类型的CPU有不同的机器指令系统，也就有不同的汇编语言\n\n操作对象：\n汇编语言是直接面向处理器（Processor）的程序设计语言，它所操作的对象不是具体的数据,而是寄存器或者存储器\n\n高速度和高效率：\n汇编语言保持了机器语言的优点，具有直接和简捷的特点，可有效地访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等，且占用内存少，执行速度快，是高效的程序设计语言\n\n编写和调试的复杂性\n由于是直接控制硬件，且简单的任务也需要很多汇编语言语句，因此在进行程序设计时必须面面俱到，需要考虑到一切可能的问题，合理调配和使用各种软、硬件资源。这样，就不可避免地加重了程序员的负担。与此相同，在程序调试时，一旦程序的运行出了问题，就很难发现\n\n\n汇编语言的组成汇编指令\n\n\n\n\n\n\n\n\n机器码的助记符，有对应的机器码，最终被cpu执行\n具体请参考网页链接\n伪指令\n\n\n\n\n\n\n\n\n没有对应的机器码，由编译器执行，计算机不执行\n其它符号\n\n\n\n\n\n\n\n\n如+、-、*、/等，由编译器识别，没有对应的机器码\n以下为一段简单的汇编语言源程序\n1234567891011assume cs:codesgcodesg segment       mov ax,0123H       mov bx,0456H       add ax,bx       add ax,ax              mov ax,4c00       int 21Hcodesg endsend\n\n\nXXX segment,XXX ends,end,assume都是伪指令\n\nmov,add，int 21H都是汇编指令\n\n补上一个注意细节：汇编语言时不允许数据用字母开头（重要！！）\n12mov AX, FFFFH\t;这是错误写法，会报错！！mov AX, 0FFFFH\t;这样写就对了，写个0为了使数据开头不是字母\n\n编译器编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。\n\n\n寄存器(8086CPU)\n\n\n\n\n\n\n\n\nCPU 还自带寄存器（register），用来储存最常用的数据。那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。\n\n所有寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW\n\nAX、BX、CX、DX\n\n存放一般性数据的通用寄存器\n可分为两部分，如AX可以为AH和AL\n\n\nCS、DS、SS、ES都是段寄存器\n\n在8086cpu中不支持将数据直接送入段寄存器中\n\n\nCS和IP\n\nCS为代码段寄存器\nIP为指令指针寄存器\nCS和IP使cpu读取指定单元\n\n\nDS\nDS通常用来存放要访问数据的段地址\n比如要读取10000H单元的数据，可以按如下程序段进行：\n12345mov bx,1000Hmov ds, bx(bx起中转作用)mov al,[0]([]代表一个内存单元，[]里面的数代表偏移地址，段地址默认为ds中的数据)\nSS和SP\n\n栈顶的段地址存放在段寄存器SS中\n栈顶的偏移地址存放在寄存器SP中\n任何时候，SS：SP指向栈顶元素\n当有元素入栈后，SP=SP－2；当有元素出栈后,SP=SP＋2\n执行t命令时，执行与ss相关的指令后自动执行与sp相关的指令\n\n\n\n内存模型\n\n\n\n\n\n\n\n\n寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。\nHeap（堆）\n\n\n\n\n\n\n\n\n用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。\nHeap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。\n程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。\n\n\n程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。\n\n\nStack(栈)\n\n\n\n\n\n\n\n\n除了内存模型 (Heap) 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。\n栈是一种具有特殊的访问方式的存储空间。特点为“先进后出，后进先出”\n栈顶超界问题当栈顶超过了栈空间，栈外面的数据将被覆盖\n\n\n栈段\n\n\n\n\n\n\n\n\n在编程时，可以根据需要，将一组内存单元定义为一个段\n一个栈段最大可设为64KB（因为一个栈段最多从0~FFFFH）\n数据宽度\n\n\n\n\n\n\n\n\n在计算机中，由于受硬件的制约，数据都是有长度限制的，超过最多宽度的数据会被丢弃\n\n计算机中常见的数据宽度\n\n位（bit）、字节（byte）、字（word）、双字（doubleword）\n\n存储范围\n\n字节：0~0×FF\n字：0~0×FFFF\n双字：0~0×FFFFFFFF\n(“0×”代表十六进制)\n存储单元\n电子计算机最小信息单位是bit,也就是一个二进制位\n\n存储单元可以存储1byte，即两个十六进制位\n\n存储单元从零开始顺序编号\n\n\n总线\n地址总线\n\nN根地址线，则地址总线的宽度为N，寻址能力为2^N Byte\n内存地址空间大小受cpu地址总线宽度的限制\n\n\n数据总线\nN根数据总线一次传输N个二进制位\n\n控制总线\n控制总线的宽度决定了cpu对外部器件的控制能力\n\n\n存储器\n\n\n\n\n\n\n\n\n从读写属性分类\n\n随机存储器(RAM)\n用于存放供cpu使用的绝大部分程序和数据(可随时读写，但一旦断电，数据就会消失)\n\n只读存储器(ROM)\n只能读出无法写入信息，信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器\n\n\ndebug命令\n\n\n\n\n\n\n\n\ndebug是一个DOS实用程序，是供程序员使用的程序调试工具，可以用它检查内存中任何地方的字节以及修改任何地方的字节。它可以用于逐指令执行某个程序以验证程序运行的正确性，也可以追踪执行过程、比较一个指令执行前后的值以及比较与移动内存中数据的范围，读写文件与磁盘\n具体请参考网页连接\n\n\n\n\n\n\n\n\n\n由于win10不再像win7可以直接进入debug模式，所以需要其它方法进入\n如何进入debug模式请参考我的另一篇文章\nwin64位系统进入debug\n程序从写出到执行的过程\n编写\n在上编写代码，结果是产生了一个存储源代码的文本文件\n编译器是一种特殊的程序，它可以把以特定编程语言写成的程序变为机器可以运行的机器码。\n\n编译链接\n\n编译\n编译的意思就是把程序语言写成机器可以运行的机器码的过程，此过程需要用到编译器。\n\n连接\n在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。\n对于连接的过程，可执行文件是我们要得到的最终结果\n其作用：\n\n当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件\n程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行 文件\n一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。\n\n\n\n\n执行\n操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化，然后由CPU执行程序\n\n\n","slug":"Assembly Language","date":"2020-12-08T12:45:27.000Z","categories_index":"基础知识","tags_index":"Assembly Language","author_index":"Krito"},{"id":"53611955a6f979c71a5255210a5666f4","title":"markdown语法","content":"\n\n\n\n\n\n\n\n\n搭建好博客后没有直接开始写文章是因为写文章时遇到了很多问题，之后去b站和百度上了解了一下，学到了一些关于markdown语法的使用方法，在此分享一下\n标题“#”一级标题\n“##”二级标题\n……（共六级标题，“#”后面要空一格）\n效果如图\n\n\n\n\n引用&lt;一级引用\n&lt;&lt;二级引用\n&lt;&lt;&lt;三级引用\n……(可不断嵌套）\n效果如图\n\n\n字体斜体要加粗的文字左右分别用两个*号包起来\n加粗要加粗的文字左右分别用两个*号包起来\n斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来\n删除线要加删除线的文字左右分别用两个~号包起来\n1234**这是加粗的文字***这是倾斜的文字*&#96;***这是斜体加粗的文字***~~这是加删除线的文字~~\n\n字体与颜色12345678&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;&lt;font color&#x3D;red&gt;我是红色&lt;&#x2F;font&gt;&lt;font color&#x3D;#008000&gt;我是绿色&lt;&#x2F;font&gt;&lt;font color&#x3D;Blue&gt;我是蓝色&lt;&#x2F;font&gt;&lt;font size&#x3D;5&gt;我是尺寸&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;黑体&quot; color&#x3D;green size&#x3D;5&gt;我是黑体，绿色，尺寸为5&lt;&#x2F;font&gt;\n\n\n\n分割线可用三个或三个以上“ - ”或者“ _ ”生成分割线（两个个效果都一样)\n隐藏内容(隐藏内容不会直接显示在博客主页，需要点进去看)\n1在&lt;!--more--&gt;输入的文章内容不会直接显示在博客页面\n\n\n\n\n\n图片引用链接引用在src=后面加入照片地址，width指照片宽度，height指照片高度\n例如\n1&lt;img src=&quot;http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg&quot; width=&quot;251&quot; height=&quot;350&quot; &gt;\n\n本地引用与链接引用类似，不过需要将网址改为路径（如果在相同目录里面，只需要将填写对应文件夹即可）\n1&lt;img src&#x3D;&quot;&#x2F;images&#x2F;1.jpg&quot; height&#x3D;&quot;400&quot; width&#x3D;&quot;350&quot; &#x2F;&gt;\n\n\n\n\n\n照片居中1&lt;div align&#x3D;right&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;pic11.photophoto.cn&#x2F;20090626&#x2F;0036036341009653_b.jpg&quot; width&#x3D;&quot;50%&quot; height&#x3D;&quot;50%&quot;&gt;&lt;&#x2F;div&gt;\n\n\n\n\n\n超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加\n\n\n\n\n\n列表无序列表12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格\n\n三个效果都一样\n有序列表数字加点\n列表嵌套上一级和下一级之间敲三个空格即可\n例如\n\n一级无序列表内容\n\n二级无序列表内容\n\n\n二级无序列表内容\n二级无序列表内容\n\n\n一级无序列表内容\n\n二级有序列表内容\n二级有序列表内容\n二级有序列表内容\n\n\n\n\n一级有序列表内容\n二级无序列表内容\n二级无序列表内容\n二级无序列表内容\n\n\n一级有序列表内容\n二级有序列表内容\n二级有序列表内容\n二级有序列表内容\n\n\n\n视频引用与照片引用类似\n12&lt;video src&#x3D;&#39;&#x2F;视频路径&#x2F;选择视频&#39; heigth&#x3D;&#39;高度&#39; controls&gt;例如：&lt;video src&#x3D;&#39;&#x2F;video&#x2F;1.mp4&#39; heigth&#x3D;&#39;500px&#39; controls&gt;\n\n\n\n\n\n","slug":"markdown","date":"2020-12-07T12:33:55.000Z","categories_index":"笔记","tags_index":"学习","author_index":"Krito"},{"id":"ebab8c4f399bfb20ac63ab99ee74d493","title":"debug安装与配置","content":"win64位系统进入debug\n\n\n\n\n\n\n\n\n最近一直在看汇编语言，想要实操，于是要进入debug模式，但是发现win64位系统无法直接进入，但最后经过几次尝试终于成功进入\n安装1、首先要下载安装DOSBox，也就是下面这个东西\n\n\n安装地址：链接：https://pan.baidu.com/s/1B0dzSc--Ok_ds67ai4flmQ     提取码：a7tp \n2、因为软件比较小，为了避免麻烦，我直接默认安装在C:\\Program Files (x86)中\n3、找到 debug.exe，并把你喜欢的位置上，记住目录（等会用到）这里我放在D:\\Debug目录下\n配置打开DOSBox.exe，输入以下指令\n123mount c d:\\debugc:debug\n\n\n\n之后就进入了debug模式\n调试如果嫌每次进入都需要输入很麻烦，可以在DOSBox 0.74 Options.bat的脚本文件进行修改，步骤如下：\n1、找到DOSBox 0.74 Options.bat，双击点开\n2、点开后拉至最底下输入\n12mount c d:\\debugc:\n\n3、保存退出\n\n\n注意开 DOSBox 会同时打开两个窗口，其中一个是黑色的控制台窗口，在控制台窗口中指明了配置文件的绝对路径\n","slug":"debug安装与配置","date":"2020-12-06T12:33:40.000Z","categories_index":"笔记","tags_index":"学习","author_index":"Krito"},{"id":"ce9156f0e3c852946bbfbbd9e0a335db","title":"我的第一篇文章","content":"新的开始这是本人第一次搭博客，走了许多弯路，经过了无数次的失败，浪费了大量的时间，但最终还是搭建完成。在这其中，我请教了石师兄和高师兄，借鉴了B站的视频，才最终成功。最后，我希望迈出这一小步后能够继续向前，并成为我想成为的人。\n\n\n音频测试照片\n\n音乐\n\n视频\n\n\n","slug":"My-First-Post","date":"2020-11-21T07:48:03.000Z","categories_index":"心得","tags_index":"感想","author_index":"Krito"}]