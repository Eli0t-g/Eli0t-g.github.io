<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CISCN复现</title>
      <link href="/post/CISCN%E5%A4%8D%E7%8E%B0.html"/>
      <url>/post/CISCN%E5%A4%8D%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>初次参加这种大型比赛，给我的感觉就是题目出的挺不错（一题都没做出来），但是这个比赛形式着实令人不解。不仅如此，在写完选择题后系统崩溃也是我没想得到（虽然没有停滞很久，但是感觉很意外，毕竟是国赛）。</p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="隔空传话"><a href="#隔空传话" class="headerlink" title="隔空传话"></a>隔空传话</h2><p>附件是一个txt文件，里面全是十六进制码，根据题目搜索发现是<a href="http://www.sendsms.cn/pdu/"><strong>PDU编码解码</strong></a>，解码发现前面四行得到有用的信息：flag前面一部分是15030442和w465。而后面则是一堆十六进制码，但是发现在第一行十六进制码的开头几个十六进制码正好是png十六进制文件头，猜测这些应该是png图片的十六进制码，利用脚本将其导出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开读取data.txt文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;../data.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">data = data.splitlines()[<span class="number">4</span>:]  <span class="comment"># 前四条不是十六进制</span></span><br><span class="line"><span class="comment"># 启动谷歌</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&quot;http://www.sendsms.cn/pdu/&quot;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">output = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 用于接收结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    browser.find_element_by_name(<span class="string">&quot;smsText2&quot;</span>).clear()  <span class="comment"># 清空转换框里面的内容</span></span><br><span class="line">    browser.find_element_by_name(<span class="string">&quot;smsText2&quot;</span>).send_keys(i)  <span class="comment"># 输入要翻译的内容</span></span><br><span class="line">    browser.find_element_by_xpath(<span class="string">&quot;//input[@name=&#x27;checkButton&#x27;]&quot;</span>).click()  <span class="comment"># 点击翻译</span></span><br><span class="line">    recv = browser.find_element_by_name(<span class="string">&quot;smsOut&quot;</span>).get_attribute(<span class="string">&#x27;value&#x27;</span>)  <span class="comment"># 获取翻译内容</span></span><br><span class="line">    recv = recv.split()  <span class="comment"># 将获得内容按空格分开</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> recv:  <span class="comment"># 读取需要的信息</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">3</span>:  <span class="comment"># 获取时间戳</span></span><br><span class="line">            txt += j</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">13</span>:</span><br><span class="line">            txt += j  <span class="comment"># 获取十六进制码</span></span><br><span class="line">            txt += <span class="string">&#x27;\n&#x27;</span>  <span class="comment"># 分行</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    output += txt</span><br><span class="line">browser.quit()  <span class="comment"># 退出浏览器</span></span><br><span class="line">output = output.splitlines()</span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">time = []</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> output:  <span class="comment"># 按时间戳进行排序</span></span><br><span class="line">    time.append(<span class="built_in">int</span>(i[<span class="number">3</span>:<span class="number">5</span>]) * <span class="number">60</span> + <span class="built_in">int</span>(i[<span class="number">6</span>:<span class="number">8</span>]) - <span class="number">1800</span>)</span><br><span class="line">    data.append(i[<span class="number">8</span>:])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">1200</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="keyword">if</span> i == time[j]:</span><br><span class="line">            result += data[j]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 将结果保存到out.txt文件中</span></span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure><p>之后导出图片，发现图片乱七八糟，想到之前w465应该是width465转成十六进制码就是1D1，得到图片</p><p><img src="https://i.loli.net/2021/05/18/du2PwMJRpSQLDyW.png" alt="未命名_1_.png"></p><p>结合前面得到flag：CISCN{15030442_b586_4c9e_b436_26def12293e4}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pygame使用</title>
      <link href="/post/pygame%E4%BD%BF%E7%94%A8.html"/>
      <url>/post/pygame%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>了解，学习一个第三方模块，最好是去官网学习，因为官方有第一手资料，而在其他人手里则是第二手，使用要学好还是得去<a href="https://www.pygame.org/wiki/GettingStarted">官网</a>。在这里我就直接拿实例讲pygame</p></blockquote><h1 id="安装pygame-windows"><a href="#安装pygame-windows" class="headerlink" title="安装pygame (windows)"></a>安装pygame (windows)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -U pygame --user</span><br></pre></td></tr></table></figure><p>可能的报错：</p><ul><li>输入python可能会报错，改成python3</li><li>无法下载，检查网络是否正常，确认无误还是无法下载，查看是否使用了梯子，如果使用就关闭。</li></ul><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>设计一个游戏必须先有思路，这里我引用了一个大佬的图片，基本思路差不多，接下来就根据这个思路开始设计这个游戏</p><p><img src="https://i.loli.net/2021/05/12/jgWlDs5pc1rQUVN.png" alt="图片链接https://blog.csdn.net/weixin_45634606/article/details/105574019"></p><p>首先，在设计时要明确游戏有哪些元素，从而创建对应的类。在飞机大战中，要创建以下几个类：</p><ul><li><p>用于管理游戏资源和行为的类（我是将它放在alien_invasion.py文件中，作为游戏的入口）</p></li><li><p>存储游戏设置的类（settings.py）</p></li><li><p>存储飞机的类（ship.py）</p></li><li><p>存储子弹的类（bullet.py）</p></li><li><p>存储敌机的类（Alien.py）</p></li><li><p>存储游戏初始数据的类（game_stats.py）</p></li><li><p>存储得分的类（scoreboard.py）</p></li><li><p>存储初始游戏界面的类（bottom.py）</p><h1 id="alien-invasion-py"><a href="#alien-invasion-py" class="headerlink" title="alien_invasion.py"></a>alien_invasion.py</h1><p>首先要初始化要显示的窗口或屏幕</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlienInvasion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>                            </span><br><span class="line">        pygame.init()                                                                                   <span class="comment">#pygame.init()安全地初始化了所有导入的pygame模块</span></span><br><span class="line">        self.screen = pygame.display.set_mode((<span class="number">1200</span>,<span class="number">800</span>))         <span class="comment">#初始屏幕，1200是屏幕宽度，800是屏幕高度</span></span><br><span class="line">        pygame.display.set_caption(<span class="string">&quot;Alien Invasion&quot;</span>)                      <span class="comment">#在屏幕边框上面添加游戏名Alien Invasion</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_game</span>(<span class="params">self</span>):</span>                                                                         <span class="comment">#游戏主循环，让游戏不断持续下去</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">                <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:                                          <span class="comment"># 如果用户输入q游戏就结束</span></span><br><span class="line">                    sys.exit()</span><br><span class="line">            pygame.display.flip()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    ai = AlienInvasion()</span><br><span class="line">    ai.run_game()</span><br></pre></td></tr></table></figure><p><strong>相关代码解释</strong>：</p><p>**if __ name __ == ‘ __ main <strong>： ‘**：</strong> name __ 是当前模块名，当模块被直接运行时模块名为 __ main __ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。（如果还是有疑惑查看<a href="https://www.sohu.com/a/426575177_671965">链接</a>）</p><p><strong>for event in pygame.event.get()：</strong>Pygame会接受用户的各种操作（比如按键盘，移动鼠标等）产生事件，事件随时可能发生，而且量也可能会很大，Pygame的做法是把一系列的事件存放一个队列里，逐个的处理。这行代码就是将事件逐一读取。</p><h1 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h1><p>存储游戏元素属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.screen_width = <span class="number">1200</span>                 <span class="comment">#屏幕宽度</span></span><br><span class="line">        self.screen_height = <span class="number">600</span>                 <span class="comment">#屏幕高度</span></span><br><span class="line">        self.bg_color = (<span class="number">230</span>, <span class="number">230</span>, <span class="number">230</span>)      <span class="comment">#背景颜色</span></span><br><span class="line">        self.ship_speed = <span class="number">1.5</span>                      <span class="comment">#飞船移动速度</span></span><br><span class="line">        self.bullet_speed = <span class="number">1.5</span>               <span class="comment">#子弹速度</span></span><br><span class="line">        self.bullet_width = <span class="number">3</span>                  <span class="comment">#子弹宽度</span></span><br><span class="line">        self.bullet_height = <span class="number">15</span>                 <span class="comment">#子弹长度</span></span><br><span class="line">        self.bullet_color = (<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span>)        <span class="comment">#子弹颜色</span></span><br><span class="line">        self.bullet_allowed = <span class="number">5</span>                <span class="comment">#子弹数量</span></span><br><span class="line">        self.alien_speed = <span class="number">1.0</span>                 <span class="comment">#外星人移动速度</span></span><br><span class="line">        self.fleet_drop_speed = <span class="number">10</span>           <span class="comment">#外星人设置</span></span><br><span class="line">        self.fleet_direction = <span class="number">1</span>               <span class="comment">#1是右移，-1是左移动</span></span><br><span class="line">        self.ship_limit = <span class="number">3</span>                           <span class="comment">#设置生命次数</span></span><br><span class="line">        self.speedup_scale = <span class="number">1.1</span>               <span class="comment">#游戏运行的速度</span></span><br><span class="line">        self.score_scale = <span class="number">1.5</span>                    <span class="comment">#根据游戏速度提高外星人的分数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_dynamic_settings</span>(<span class="params">self</span>):</span>                              <span class="comment">#初始化在整个游戏中更改的设置</span></span><br><span class="line">        self.ship_speed = <span class="number">1.5</span>                                                         <span class="comment">#飞船移动速度</span></span><br><span class="line">        self.bullet_speed = <span class="number">3.0</span>                                                     <span class="comment">#子弹移动速度</span></span><br><span class="line">        self.alien_speed = <span class="number">1.0</span>                                                       <span class="comment">#外星人移动速度</span></span><br><span class="line">        self.fleet_direction = <span class="number">1</span>                                                       <span class="comment">#外星人移动方向</span></span><br><span class="line">        self.alien_points = <span class="number">50</span>                                                         <span class="comment">#每个外星人的分数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_speed</span>(<span class="params">self</span>):</span>                                                                       <span class="comment">#提高速度设置和外星人分数</span></span><br><span class="line">        self.ship_speed *= self.speedup_scale</span><br><span class="line">        self.bullet_speed *= self.speedup_scale</span><br><span class="line">        self.alien_speed *= self.speedup_scale</span><br><span class="line"></span><br><span class="line">        self.alien_points = <span class="built_in">int</span>(self.alien_points * self.score_scale)</span><br></pre></td></tr></table></figure><h1 id="ship-py"><a href="#ship-py" class="headerlink" title="ship.py"></a>ship.py</h1></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,ai_game</span>):</span></span><br><span class="line">        <span class="comment"># 初始化小飞机并设置其初始位置</span></span><br><span class="line">        self.screen = ai_game.screen                                                              <span class="comment">#加载图像，并获得其矩形区域</span></span><br><span class="line">        self.settings = ai_game.settings                                                         <span class="comment">#读取设置里面的信息</span></span><br><span class="line">        self.img_plane = pygame.image.load(<span class="string">&quot;images/ship.bmp&quot;</span>)          <span class="comment">#加载飞船照片</span></span><br><span class="line">        self.screen_rect = ai_game.screen.get_rect()                              <span class="comment">#得到飞船的的矩形区域</span></span><br><span class="line">        self.screen_rect = self.screen.get_rect()                                        <span class="comment">#得到screen的矩形区域</span></span><br><span class="line">        self.rect.midbottom = self.screen_rect.midbottom                      <span class="comment"># 将飞船放到底部中央</span></span><br><span class="line">        self.x = <span class="built_in">float</span>(self.rect.x)                                                                        <span class="comment">#存储飞机的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blitme</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 在指定位置绘制小飞机</span></span><br><span class="line">        self.screen.blit(self.image, self.rect)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span>                                                                                                       <span class="comment">#根据运动标记更新飞船的位置</span></span><br><span class="line">        <span class="keyword">if</span> self.moving_right <span class="keyword">and</span> self.rect.right &lt; self.screen_rect.right:            <span class="comment">#如果飞船向右移动没有超过边界，飞船就向右移动x（x大小根据设置里面的飞船速度）</span></span><br><span class="line">            self.x += self.settings.ship_speed</span><br><span class="line">        <span class="keyword">if</span> self.moving_left <span class="keyword">and</span> self.rect.left &gt; <span class="number">0</span>:                                                        <span class="comment">#如果飞船向左移动没有超过边界，飞船就向左移动x </span></span><br><span class="line">            self.x -= self.settings.ship_speed </span><br><span class="line">            self.rect.x = self.x                                                                                             <span class="comment">#更新飞船位置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center_ship</span>(<span class="params">self</span>):</span>                                                                                 <span class="comment">#将飞船居中</span></span><br><span class="line">        self.rect.midbottom = self.screen_rect.midbottom                       <span class="comment">#定义飞船居中位置为屏幕下面底部中央</span></span><br><span class="line">        self.x = <span class="built_in">float</span>(self.rect.x)                                                                         <span class="comment">#更新飞船位置</span></span><br></pre></td></tr></table></figure><h1 id="bullet-py"><a href="#bullet-py" class="headerlink" title="bullet.py"></a>bullet.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Sprite</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span>(<span class="params">Sprite</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ai_game</span>):</span>                                                                   <span class="comment">#在舰船的当前位置创建一个子弹对象</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()                                                                                   <span class="comment">#继承</span></span><br><span class="line">        self.screen = ai_game.screen</span><br><span class="line">        self.settings = ai_game.settings</span><br><span class="line">        self.color = self.settings.bullet_color</span><br><span class="line">        self.rect = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, self.settings.bullet_width,self.settings.bullet_height)              <span class="comment">#创建一个子弹并放置在正确位置</span></span><br><span class="line">        self.rect.midtop = ai_game.ship.rect.midtop</span><br><span class="line">        self.y = <span class="built_in">float</span>(self.rect.y)                                                                          <span class="comment">#存储子弹的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span>                                                                                            <span class="comment">#更新子弹位置</span></span><br><span class="line">        self.y -= self.settings.bullet_speed</span><br><span class="line">        self.rect.y = self.y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_bullet</span>(<span class="params">self</span>):</span>                                                                                   <span class="comment">#在屏幕上绘制子弹</span></span><br><span class="line">        pygame.draw.rect(self.screen, self.color, self.rect)</span><br></pre></td></tr></table></figure><h1 id="game-stats-py"><a href="#game-stats-py" class="headerlink" title="game_stats.py"></a>game_stats.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameStats</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Track statistics for Alien Invasion.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ai_game</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize statistics.&quot;&quot;&quot;</span></span><br><span class="line">        self.settings = ai_game.settings</span><br><span class="line">        self.reset_stats()</span><br><span class="line">        self.game_active = <span class="literal">False</span>                                           <span class="comment">#自动开启游戏</span></span><br><span class="line">        self.high_score = <span class="number">0</span>       <span class="comment">#高分永远不要重置。</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset_stats</span>(<span class="params">self</span>):</span>    <span class="comment">#初始化游戏数据</span></span><br><span class="line">        self.ships_left = self.settings.ship_limit</span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        self.level = <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="scoreboard-py"><a href="#scoreboard-py" class="headerlink" title="scoreboard.py"></a>scoreboard.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame.font</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Group</span><br><span class="line"><span class="keyword">from</span> ship <span class="keyword">import</span> Ship</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scoreboard</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ai_game</span>):</span>                       <span class="comment">#初始化得分属性</span></span><br><span class="line">        self.ai_game = ai_game</span><br><span class="line">        self.screen = ai_game.screen</span><br><span class="line">        self.screen_rect = self.screen.get_rect()</span><br><span class="line">        self.settings = ai_game.settings</span><br><span class="line">        </span><br><span class="line">        self.stats = ai_game.stats                                      <span class="comment">#得分信息的字体设置</span></span><br><span class="line">        self.text_color = (<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">        self.font = pygame.font.SysFont(<span class="literal">None</span>, <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">        self.prep_score()                                                       <span class="comment">#初始乐谱图像</span></span><br><span class="line">        self.prep_high_score()</span><br><span class="line">        self.prep_level()</span><br><span class="line">        self.prep_ships()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Turn the score into a rendered image.&quot;&quot;&quot;</span></span><br><span class="line">        rounded_score = <span class="built_in">round</span>(self.stats.score, -<span class="number">1</span>)</span><br><span class="line">        score_str = <span class="string">&quot;&#123;:,&#125;&quot;</span>.<span class="built_in">format</span>(rounded_score)</span><br><span class="line">        self.score_image = self.font.render(score_str, <span class="literal">True</span>,</span><br><span class="line">                self.text_color, self.settings.bg_color)</span><br><span class="line">        </span><br><span class="line">        self.score_rect = self.score_image.get_rect()               <span class="comment">#在屏幕右上方显示分数</span></span><br><span class="line">        self.score_rect.right = self.screen_rect.right - <span class="number">20</span></span><br><span class="line">        self.score_rect.top = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_high_score</span>(<span class="params">self</span>):</span>                                                     <span class="comment">#将高分转换为图像</span></span><br><span class="line">        high_score = <span class="built_in">round</span>(self.stats.high_score, -<span class="number">1</span>)</span><br><span class="line">        high_score_str = <span class="string">&quot;&#123;:,&#125;&quot;</span>.<span class="built_in">format</span>(high_score)</span><br><span class="line">        self.high_score_image = self.font.render(high_score_str, <span class="literal">True</span>,</span><br><span class="line">                self.text_color, self.settings.bg_color)</span><br><span class="line">            </span><br><span class="line">        self.high_score_rect = self.high_score_image.get_rect()          <span class="comment">#将高分居中显示在屏幕顶部</span></span><br><span class="line">        self.high_score_rect.centerx = self.screen_rect.centerx</span><br><span class="line">        self.high_score_rect.top = self.score_rect.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_level</span>(<span class="params">self</span>):</span>                                                                      <span class="comment">#将等级转换为渲染的图像。</span></span><br><span class="line">        level_str = <span class="built_in">str</span>(self.stats.level)</span><br><span class="line">        self.level_image = self.font.render(level_str, <span class="literal">True</span>,</span><br><span class="line">                self.text_color, self.settings.bg_color)</span><br><span class="line">    </span><br><span class="line">        self.level_rect = self.level_image.get_rect()                 <span class="comment">#将级别定位在分数下方</span></span><br><span class="line">        self.level_rect.right = self.score_rect.right</span><br><span class="line">        self.level_rect.top = self.score_rect.bottom + <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_ships</span>(<span class="params">self</span>):</span>                                                                 <span class="comment">#显示生命值</span></span><br><span class="line">        self.ships = Group()</span><br><span class="line">        <span class="keyword">for</span> ship_number <span class="keyword">in</span> <span class="built_in">range</span>(self.stats.ships_left):</span><br><span class="line">            ship = Ship(self.ai_game)</span><br><span class="line">            ship.rect.x = <span class="number">10</span> + ship_number * ship.rect.width</span><br><span class="line">            ship.rect.y = <span class="number">10</span></span><br><span class="line">            self.ships.add(ship)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_high_score</span>(<span class="params">self</span>):</span>                                               <span class="comment">#检查是否有新高分</span></span><br><span class="line">        <span class="keyword">if</span> self.stats.score &gt; self.stats.high_score:</span><br><span class="line">            self.stats.high_score = self.stats.score</span><br><span class="line">            self.prep_high_score()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_score</span>(<span class="params">self</span>):</span>                                                            <span class="comment">#在屏幕上面绘制分数和其它信息</span></span><br><span class="line">        self.screen.blit(self.score_image, self.score_rect)</span><br><span class="line">        self.screen.blit(self.high_score_image, self.high_score_rect)</span><br><span class="line">        self.screen.blit(self.level_image, self.level_rect)</span><br><span class="line">        self.ships.draw(self.screen)</span><br></pre></td></tr></table></figure><h1 id="botto-py"><a href="#botto-py" class="headerlink" title="botto.py"></a>botto.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame.font</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ai_game, msg</span>):</span>                 <span class="comment">#初始化</span></span><br><span class="line">        self.screen = ai_game.screen</span><br><span class="line">        self.screen_rect = self.screen.get_rect()</span><br><span class="line">        </span><br><span class="line">        self.width, self.height = <span class="number">200</span>, <span class="number">50</span>               <span class="comment">#设置按钮的尺寸和属性</span></span><br><span class="line">        self.button_color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">        self.text_color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">        self.font = pygame.font.SysFont(<span class="literal">None</span>, <span class="number">48</span>)</span><br><span class="line">        </span><br><span class="line">        self.rect = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, self.width, self.height)    <span class="comment">#放置play图标</span></span><br><span class="line">        self.rect.center = self.screen_rect.center</span><br><span class="line">        </span><br><span class="line">        self._prep_msg(msg)                                  <span class="comment">#该按钮仅需准备一次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_prep_msg</span>(<span class="params">self, msg</span>):</span>                              <span class="comment">#将其转换为渲染的图像，然后在按钮上居中显示文本。</span></span><br><span class="line">        self.msg_image = self.font.render(msg, <span class="literal">True</span>, self.text_color,</span><br><span class="line">                self.button_color)</span><br><span class="line">        self.msg_image_rect = self.msg_image.get_rect()</span><br><span class="line">        self.msg_image_rect.center = self.rect.center</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_button</span>(<span class="params">self</span>):</span>                                     <span class="comment">#在屏幕上面绘制</span></span><br><span class="line">        self.screen.fill(self.button_color, self.rect)</span><br><span class="line">        self.screen.blit(self.msg_image, self.msg_image_rect)</span><br></pre></td></tr></table></figure><h1 id="重构alien-invasion-py"><a href="#重构alien-invasion-py" class="headerlink" title="重构alien_invasion.py"></a>重构alien_invasion.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> game_stats <span class="keyword">import</span> GameStats</span><br><span class="line"><span class="keyword">from</span> scoreboard <span class="keyword">import</span> Scoreboard</span><br><span class="line"><span class="keyword">from</span> button <span class="keyword">import</span> Button</span><br><span class="line"><span class="keyword">from</span> ship <span class="keyword">import</span> Ship</span><br><span class="line"><span class="keyword">from</span> bullet <span class="keyword">import</span> Bullet</span><br><span class="line"><span class="keyword">from</span> alien <span class="keyword">import</span> Alien</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlienInvasion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span></span><br><span class="line">        pygame.init()</span><br><span class="line">        self.settings = Settings()</span><br><span class="line"></span><br><span class="line">        self.screen = pygame.display.set_mode((<span class="number">0</span>, <span class="number">0</span>), pygame.FULLSCREEN)</span><br><span class="line">        self.settings.screen_width = self.screen.get_rect().width</span><br><span class="line">        self.settings.screen_height = self.screen.get_rect().height</span><br><span class="line">        pygame.display.set_caption(<span class="string">&quot;Alien Invasion&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建一个实例来存储游戏统计信息，并创建一个记分板。&quot;&quot;&quot;</span></span><br><span class="line">        self.stats = GameStats(self)</span><br><span class="line">        self.sb = Scoreboard(self)</span><br><span class="line"></span><br><span class="line">        self.ship = Ship(self)</span><br><span class="line">        self.bullets = pygame.sprite.Group()</span><br><span class="line">        self.aliens = pygame.sprite.Group()</span><br><span class="line"></span><br><span class="line">        self._create_fleet()</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置play&quot;&quot;&quot;</span></span><br><span class="line">        self.play_button = Button(self, <span class="string">&quot;Play&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;开启游戏并循环&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_game</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self._check_events()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.stats.game_active:</span><br><span class="line">                self.ship.update()</span><br><span class="line">                self._update_bullets()</span><br><span class="line">                self._update_aliens()</span><br><span class="line"></span><br><span class="line">            self._update_screen()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_events</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">                sys.exit()</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYDOWN:</span><br><span class="line">                self._check_keydown_events(event)</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYUP:</span><br><span class="line">                self._check_keyup_events(event)</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">                mouse_pos = pygame.mouse.get_pos()</span><br><span class="line">                self._check_play_button(mouse_pos)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;当玩家单击播放时开始新游戏&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_play_button</span>(<span class="params">self, mouse_pos</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start a new game when the player clicks Play.&quot;&quot;&quot;</span></span><br><span class="line">        button_clicked = self.play_button.rect.collidepoint(mouse_pos)</span><br><span class="line">        <span class="keyword">if</span> button_clicked <span class="keyword">and</span> <span class="keyword">not</span> self.stats.game_active:</span><br><span class="line">            <span class="comment">#重置游戏设置</span></span><br><span class="line">            self.settings.initialize_dynamic_settings()</span><br><span class="line"></span><br><span class="line">            <span class="comment">#重置游戏统计信息</span></span><br><span class="line">            self.stats.reset_stats()</span><br><span class="line">            self.stats.game_active = <span class="literal">True</span></span><br><span class="line">            self.sb.prep_score()</span><br><span class="line">            self.sb.prep_level()</span><br><span class="line">            self.sb.prep_ships()</span><br><span class="line"></span><br><span class="line">            <span class="comment">#摆脱任何剩余的外星人和子弹</span></span><br><span class="line">            self.aliens.empty()</span><br><span class="line">            self.bullets.empty()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#建立一个新的舰队并集中舰船</span></span><br><span class="line">            self._create_fleet()</span><br><span class="line">            self.ship.center_ship()</span><br><span class="line"></span><br><span class="line">            <span class="comment">#隐藏鼠标光标</span></span><br><span class="line">            pygame.mouse.set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;响应按键&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_keydown_events</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">            self.ship.moving_right = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_LEFT:</span><br><span class="line">            self.ship.moving_left = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_q:</span><br><span class="line">            sys.exit()</span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_SPACE:</span><br><span class="line">            self._fire_bullet()</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;释放按键&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_keyup_events</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">            self.ship.moving_right = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_LEFT:</span><br><span class="line">            self.ship.moving_left = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个新的项目符号并将其添加到项目符号组&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fire_bullet</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.bullets) &lt; self.settings.bullets_allowed:</span><br><span class="line">            new_bullet = Bullet(self)</span><br><span class="line">            self.bullets.add(new_bullet)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;更新项目符号的位置并摆脱旧项目符号&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_bullets</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 更新子弹位置</span></span><br><span class="line">        self.bullets.update()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 消除子弹</span></span><br><span class="line">        <span class="keyword">for</span> bullet <span class="keyword">in</span> self.bullets.copy():</span><br><span class="line">            <span class="keyword">if</span> bullet.rect.bottom &lt;= <span class="number">0</span>:</span><br><span class="line">                 self.bullets.remove(bullet)</span><br><span class="line"></span><br><span class="line">        self._check_bullet_alien_collisions()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;子弹与外星人的碰撞&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_bullet_alien_collisions</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 消除被打到的子弹和外星人</span></span><br><span class="line">        collisions = pygame.sprite.groupcollide(</span><br><span class="line">                self.bullets, self.aliens, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> collisions:</span><br><span class="line">            <span class="keyword">for</span> aliens <span class="keyword">in</span> collisions.values():</span><br><span class="line">                self.stats.score += self.settings.alien_points * <span class="built_in">len</span>(aliens)</span><br><span class="line">            self.sb.prep_score()</span><br><span class="line">            self.sb.check_high_score()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.aliens:</span><br><span class="line">            <span class="comment"># 销毁现有子弹并建立新的舰队</span></span><br><span class="line">            self.bullets.empty()</span><br><span class="line">            self._create_fleet()</span><br><span class="line">            self.settings.increase_speed()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Increase level.</span></span><br><span class="line">            self.stats.level += <span class="number">1</span></span><br><span class="line">            self.sb.prep_level()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查舰队是否处于边缘，然后更新舰队中所有外星人的位置。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_aliens</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._check_fleet_edges()</span><br><span class="line">        self.aliens.update()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寻找与外星人的碰撞</span></span><br><span class="line">        <span class="keyword">if</span> pygame.sprite.spritecollideany(self.ship, self.aliens):</span><br><span class="line">            self._ship_hit()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寻找外星人撞到屏幕底部</span></span><br><span class="line">        self._check_aliens_bottom()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查是否有任何外星人到达屏幕底部&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_aliens_bottom</span>(<span class="params">self</span>):</span></span><br><span class="line">        screen_rect = self.screen.get_rect()</span><br><span class="line">        <span class="keyword">for</span> alien <span class="keyword">in</span> self.aliens.sprites():</span><br><span class="line">            <span class="keyword">if</span> alien.rect.bottom &gt;= screen_rect.bottom:</span><br><span class="line">                <span class="comment"># Treat this the same as if the ship got hit.</span></span><br><span class="line">                self._ship_hit()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;被外星人击中&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_ship_hit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stats.ships_left &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 减少生命，并更新记分板.</span></span><br><span class="line">            self.stats.ships_left -= <span class="number">1</span></span><br><span class="line">            self.sb.prep_ships()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 摆脱任何剩余的外星人和子弹.</span></span><br><span class="line">            self.aliens.empty()</span><br><span class="line">            self.bullets.empty()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 建立一个新的舰队并集中舰船.</span></span><br><span class="line">            self._create_fleet()</span><br><span class="line">            self.ship.center_ship()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 暂停</span></span><br><span class="line">            sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stats.game_active = <span class="literal">False</span></span><br><span class="line">            pygame.mouse.set_visible(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;建立外星人的舰队&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_fleet</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 创建一个外星人并连续查找外星人的数量。</span></span><br><span class="line">        <span class="comment"># 每个外星人之间的间距等于一个外星人的宽度。</span></span><br><span class="line">        alien = Alien(self)</span><br><span class="line">        alien_width, alien_height = alien.rect.size</span><br><span class="line">        available_space_x = self.settings.screen_width - (<span class="number">2</span> * alien_width)</span><br><span class="line">        number_aliens_x = available_space_x // (<span class="number">2</span> * alien_width)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定适合屏幕的外星人行数</span></span><br><span class="line">        ship_height = self.ship.rect.height</span><br><span class="line">        available_space_y = (self.settings.screen_height -</span><br><span class="line">                                (<span class="number">3</span> * alien_height) - ship_height)</span><br><span class="line">        number_rows = available_space_y // (<span class="number">2</span> * alien_height)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 建立完整的外星人舰队.</span></span><br><span class="line">        <span class="keyword">for</span> row_number <span class="keyword">in</span> <span class="built_in">range</span>(number_rows):</span><br><span class="line">            <span class="keyword">for</span> alien_number <span class="keyword">in</span> <span class="built_in">range</span>(number_aliens_x):</span><br><span class="line">                self._create_alien(alien_number, row_number)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建外星人并将其放置在行中&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_alien</span>(<span class="params">self, alien_number, row_number</span>):</span></span><br><span class="line">        alien = Alien(self)</span><br><span class="line">        alien_width, alien_height = alien.rect.size</span><br><span class="line">        alien.x = alien_width + <span class="number">2</span> * alien_width * alien_number</span><br><span class="line">        alien.rect.x = alien.x</span><br><span class="line">        alien.rect.y = alien.rect.height + <span class="number">2</span> * alien.rect.height * row_number</span><br><span class="line">        self.aliens.add(alien)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;如果有任何外星人到达边缘，请做出适当的反应&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_fleet_edges</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> alien <span class="keyword">in</span> self.aliens.sprites():</span><br><span class="line">            <span class="keyword">if</span> alien.check_edges():</span><br><span class="line">                self._change_fleet_direction()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_change_fleet_direction</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;放下整个舰队并更改舰队的方向.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> alien <span class="keyword">in</span> self.aliens.sprites():</span><br><span class="line">            alien.rect.y += self.settings.fleet_drop_speed</span><br><span class="line">        self.settings.fleet_direction *= -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;更新屏幕上的图像，然后切换到新屏幕&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_screen</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update images on the screen, and flip to the new screen.&quot;&quot;&quot;</span></span><br><span class="line">        self.screen.fill(self.settings.bg_color)</span><br><span class="line">        self.ship.blitme()</span><br><span class="line">        <span class="keyword">for</span> bullet <span class="keyword">in</span> self.bullets.sprites():</span><br><span class="line">            bullet.draw_bullet()</span><br><span class="line">        self.aliens.draw(self.screen)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制分数信息.</span></span><br><span class="line">        self.sb.show_score()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#如果游戏处于非活动状态，请绘制播放按钮.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stats.game_active:</span><br><span class="line">            self.play_button.draw_button()</span><br><span class="line"></span><br><span class="line">        pygame.display.flip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 运行游戏</span></span><br><span class="line">    ai = AlienInvasion()</span><br><span class="line">    ai.run_game()</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在设计时是需要不断对每个模块进行重构，重构的目的一是为了使代码看起来更简洁，而是优化代码，减少不必要的代码。除此之外，还需要对项目进行不断检查，检查是否有bug，对bug要进行即使修改。还有，python虽然使用起来非常方便，但是需要记住的函数却很多，要熟练的使用，必须要能够熟悉相关的第三方库，这样才能做到游刃有余。</p>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝帽杯MISC</title>
      <link href="/post/%E8%93%9D%E5%B8%BD%E6%9D%AFMISC.html"/>
      <url>/post/%E8%93%9D%E5%B8%BD%E6%9D%AFMISC.html</url>
      
        <content type="html"><![CDATA[<h1 id="冰墩墩"><a href="#冰墩墩" class="headerlink" title="冰墩墩"></a>冰墩墩</h1><p>拿到附件拖进虚拟机中使用binwalk查看</p><p><img src="https://i.loli.net/2021/05/05/Fpan5DGMyYfHrZx.png" alt="图片1.png"></p><p>发现里面存在rar压缩包，使用foremost进行分离</p><p><img src="https://i.loli.net/2021/05/05/v8i7wY6kUMNRXxA.png" alt="图片2.png"></p><p><img src="https://i.loli.net/2021/05/05/WgwaT4hGJ9FlHYU.png" alt="图片3.png"></p><p>发现音频和提示<img src="https://i.loli.net/2021/05/05/hxJzEVyRfQGDrFo.png" alt="图片4.png"></p><p>将音频放进010，在结尾发现cipher<img src="https://i.loli.net/2021/05/06/ubNWz2AeCUgl7X8.png" alt="图片5.png"></p><p>将对应的十六进制码复制下来，搜索以0~F编码的加密方式，发现是url编码。<img src="https://i.loli.net/2021/05/05/Aj62JcfVHiRQXdl.png" alt="图片6.png"></p><p>对十六进制码进行处理<img src="https://i.loli.net/2021/05/05/IV5ekvFXmoO4R2d.png" alt="图片7.png"></p><p>解码后发现是一堆表情包<img src="https://i.loli.net/2021/05/05/MxWecuYztbjRVHk.png" alt="图片9.png"></p><p>对表情包进行解码发现无法翻译，搜索了一下发现可能是emoji-aes加密，但缺少密匙，之后回去在看mp3文件，想到misc里面有一个MP3stego的工具，但是还需要一个密码才有行，想到之前的eight numbers，加上题目名称，猜测可能是冬奥会举办日期20220204<img src="https://i.loli.net/2021/05/06/Ru2JVmP3pL4vnIl.png" alt="图片11.png"></p><p>得到一个txt文件，发现是python里面的一种编码方式<img src="https://i.loli.net/2021/05/06/zK19G53w4ZsJfBQ.png" alt="图片13.png"></p><p>发现是wingdings图标，在线解码，得到密匙How_6ad_c0uld_a_1cePeak_be?   之后进行emoji-aes解码得到flag<img src="https://i.loli.net/2021/05/06/Yeg6xybJDlq4GrQ.png" alt="图片15.png"></p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> write up </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养</title>
      <link href="/post/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html"/>
      <url>/post/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html</url>
      
        <content type="html"><![CDATA[<h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><p>基本思路使把一段与程序所需的内存空间大小的虚拟空间映射到某个地址空间。采用分段的方法可以解决以下几个问题</p><ul><li><p>地址空间不隔离。如果不同程序间地址连续很容易被恶意程序通过溢出手段使其它程序崩溃或者产生严重后果，而分段可以避免这种情况，比如此时有A,B两个程序，此时操作系统会分配两个虚拟地址，初始地址都是0x00000000，终止地址为程序的大小，一旦该程序访问超过了这个虚拟地址空间，操作系统就会抛出拒绝访问，如果正常访问，操作系统就会将虚拟地址映射到空闲物理地址中。</p><p><img src="https://i.loli.net/2021/05/05/xBaXR7tqjJcbWpl.png" alt="image-20210502230422504.png"></p></li><li><p>解决运行地址不确定。每次程序装载运行时，操作系统为其分配的空闲地址是不确定的，比如这次是0x00000000 ~ 0x00A00000，下一次可能就是0x00200000 ~ 0x00C00000，但是采用分段的方法，在虚拟内存中程序起始地址和终止地址不会发生改变，很好的解决了解决运行地址不确定这一问题。</p></li><li><p>对不同的段设置不同的权限。比如数据段就不会有执行权限，只读段只有读取的权限，有效的防止了溢出攻击，加大程序被攻破的难度</p></li><li><p>适应CPU的缓存体系。CPU缓存体系被分为数据缓存和指令缓存，采用分段的方法极大地提高了缓存的命中率。</p></li><li><p>有利于共享空间，节约内存。比如系统在运行某一个程序时，可能出现多个该程序的多个副本，这些副本代码是一样的且只可读，所以可以采取共享一个段的方法来节约内存。</p><p>当然，分段并不是完美无缺的，当内存不够时，操作系统会将一些在内存中进程存进磁盘，采用分段的方法，由于映射的单位是程序，所以换入换出的是整个程序，粒度较大，严重影响了运行速度</p></li></ul><h1 id="不要让CPU打盹"><a href="#不要让CPU打盹" class="headerlink" title="不要让CPU打盹"></a>不要让CPU打盹</h1><p>CPU的价值巨大，为了充分利用CPU，早期采用<strong>多道程序</strong>的方法利用CPU，就是当某个程序不再需要CPU时，监控程序就会将需要CPU的程序自动开启，虽然提高CPU利用率，但是不能很好满足用户需求，比如用户要启动一个程序，可能要等待上一个程序上一个程序完成才行，这是极为致命，所以改进为<strong>分时系统</strong>，分时系统能够较好的改良这个问题，如果有个程序在使用CPU，但此时用户要启动另一个程序，系统就会暂停这个程序，去完成用户指定的程序，但这个办法缺点是，如果有个程序霸占CPU，那么即使用户要启动另一个程序依旧要等待，因为所有的优先级是一样的，为了解决这个问题，改进为如今的<strong>多任务系统</strong>，这个系统中操作系统有了最高权限，接管了所有的硬件资源，且受硬件保护，应用程序都是以<strong>进程</strong>的运行，它们的权限会比操作系统低，同时，每个进程都会有<strong>独立的地址空间</strong>，让进程相互分开。不仅如此，每个进程都有有个优先级，能够有序的运行，万一优先级较高的进程霸占了CPU，操作系统就会“出手”暂停这个进程将CPU分给下一个进程，也就是所谓的<strong>抢占式</strong>。</p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p><strong>进程（Process）</strong>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。<strong>线程</strong>被称为<strong>轻量级进程</strong>是程序执行流的最小单元，由线程ID，当前指令指针，寄存器集合和堆栈组成。线程可以访问进程内存里面所有数据，甚至包括其他线程等等堆栈(要知道其他线程堆栈的地址，很少见的情况)，当然线程也有私有内存空间，如栈(并非完全私有)，线程局部存储，寄存器。而在Linux下没有线程与进程的概念，但是有类似作用的<strong>任务</strong>，任务相当于线程，但是任务之间可以选择共享内存空间，这些任务组合起来就相当于Windows下的进程。</p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a><strong>二元信号量</strong></h2><p>　　是最简单的一种锁，适合只能被唯一一个线程独占访问的资源；对于允许多个线程并发访问的资源，多元信号量简称信号量；</p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a><strong>互斥量</strong></h2><p>　　和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统可以被任意线程获取并释放；也就是说哪个线程锁的，要哪个线程解锁。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a><strong>临界区</strong></h2><p>　　是比互斥量更加严格的同步手段。在术语中，把临界区的获取称为进入临界区，而把锁的释放称为离开临界区。与互斥量和信号量的区别：</p><p>　　(1)互斥量和信号量字系统的任何进程都是可见的。</p><p>　　(2)临界区的作用范围仅限于本进程，其他进程无法获取该锁。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的自我修养 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数调用与常见调用约定</title>
      <link href="/post/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8E%E5%B8%B8%E8%A7%81%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A.html"/>
      <url>/post/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8E%E5%B8%B8%E8%A7%81%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>下面代码展示了一个简单的加法子函数调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span> <span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c;</span><br><span class="line">    c=plus(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入反汇编查看</p><p><img src="https://i.loli.net/2021/05/05/WinHfG98h6gNzVs.png" alt="image-20210425221051251.png"></p><p>首先，系统会将1，2分别移动到a，b对应的地址中，之后从右至左将b，a对应地址的值移动到eax，ecx中，之后进行跳转到plus函数的plt表</p><p><img src="https://i.loli.net/2021/05/05/fkHsWxKLNU9uXBb.png" alt="image-20210425221706739.png"></p><p>再跳转到plus函数的实际中</p><p><img src="https://i.loli.net/2021/05/05/K1Qb8IYfksJ6lUd.png" alt="image-20210425221830540.png"></p><p>子函数先是把ebp保存在栈中，之后通过mov指令将ebp指向esp指向的位置，esp再进行抬栈处理，然后保存现场（将ebx，esi，edi存储的值保存在堆栈中）,接下来把ebp-0ch对应的地址移动到edi中。之后向ecx赋30h，向eax赋0CCCCCCCCh，然后对es:edi对应的地址开始循环赋值（整个过程就是对缓冲区初始化）。（后面两个不知道是什么，太菜了😅）</p><p>补：缓冲区用于存储函数调用里面申请的变量，因为这些变量存放在缓冲区，当调用完成后缓冲区会被丢弃，所以函数调用里面的变量无法被函数外面访问到</p><p><img src="https://i.loli.net/2021/05/05/A2XJYcVMrRgTzaP.png" alt="image-20210426075548516.png"></p><p>接下来就是将a的值移动到eax中再加b的值，后面再恢复现场，再内平栈（add esp 0C0h）,之后比较esp，ebp是否相同，（如果相同我也不知道会怎么样，😅），然后将esp指向ebp指向的位置，将ebp返回到原来的地方。</p><p><img src="https://i.loli.net/2021/05/05/Cc6jF9qiHUAKoG7.png" alt="image-20210425222327010.png"></p><p>最后外平栈（add esp,8），将计算结果从eax移到变量c对应的地址中，至此完成函数调用</p><p><img src="https://i.loli.net/2021/05/05/CAj5SFWvYikT38l.png" alt="image-20210426075951991.png"></p><h1 id="常见的三种调用约定（32位）"><a href="#常见的三种调用约定（32位）" class="headerlink" title="常见的三种调用约定（32位）"></a>常见的三种调用约定（32位）</h1><p><img src="https://i.loli.net/2021/05/05/vaOVrxQuMnZfL4F.png" alt="image-20210426080234751.png"></p><p>第一种就是系统默认的调用约定，调用者清理栈，就是和上面外平栈（add esp,8）差不多</p><p>第二种就是在返回时对ret进行处理，使栈指针指向调用参数前的地址（如：ret 8）</p><p>第三种就是通过寄存器传参，但如果寄存器不够还是得借助栈来传参，因为cpu与寄存器之间传递相对于cpu与内存更快，所以第三种方法在参数较少时，更加高效。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收获 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>switch语句高效的原因</title>
      <link href="/post/switch%E8%AF%AD%E5%8F%A5%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0.html"/>
      <url>/post/switch%E8%AF%AD%E5%8F%A5%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0.html</url>
      
        <content type="html"><![CDATA[<p>switch语句和if语句都是条件判断语句，但是switch语句更加高效，因而许多公司在设计时大多采用switch语句</p><ul><li><p>当分支语句较少时，switch与if语句并没有什么区别都是先判断，之后再跳转</p><p><img src="https://i.loli.net/2021/05/05/JbqGPogxXlWz5Cy.png" alt="image-20210424220833029_1_.png"></p><p><img src="https://i.loli.net/2021/05/05/4PwV6MvuABhcRUG.png" alt="image-20210424221716230.png"></p></li><li><p>当分支较多时，switch语句就发生变化，并没有挨个判断再跳转，只跳转了一次</p><p><img src="https://i.loli.net/2021/05/05/ernR2PoyQKiG5Xp.png" alt="image-20210424220610926.png"></p><p><img src="https://i.loli.net/2021/05/05/75EbrqeRQwoDhI3.png" alt="image-20210425073459041.png"></p></li></ul><p>switch语句会维护一张跳转表，不管case判断语句的值是不是按照顺序的，内存中的地址表都会按照顺序进行排列。分析汇编代码会发现，编译器先是将x的值赋给ecx寄存器，之后ecx减去case中最小值并与case中最大值比较，大于就会跳转到default，不大于就会将ecx寄存器中的值移到edx中,之后跳转到edx * 4+14191Ch对应的地址，查看地址发现ABCD四个字符存放的位置就是相差4个字节。所以，当分支较多时，switch-case不用像if-else if那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位到分支。<strong>从数据结构与算法的角度来看，switch 语句相当于一个数组，其查询时间复杂度为 O(1)；而 if-lese 语句相当于一个链表，其时间复杂度为 O(n)</strong></p><p><img src="https://i.loli.net/2021/05/05/IskPjxBeu4i2RcF.png" alt="image-20210425073053511.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用switch语句时，程序首先判断switch变量是否大于（小于）最大（最小）case 常量，若大于（小于），则跳到default分支处理；否则取得索引号为switch变量大小的跳表项的地址（即跳表的起始地址＋表项大小＊索引号），程序接着跳到此地址执行，到此完成了分支的跳转。。即使case情况不连续或者case情况相差较大时，也能达到相应的效果。</p><p><img src="https://img-blog.csdnimg.cn/20191208162619834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pidzExODU=,size_16,color_FFFFFF,t_70"></p><p>参考文章：<a href="https://blog.csdn.net/zbw1185/article/details/103359426">https://blog.csdn.net/zbw1185/article/details/103359426</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收获 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源文件到可执行文件</title>
      <link href="/post/%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.html"/>
      <url>/post/%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h1><p>C源文件到可执行文件共经历了4个过程，包括<strong>预处理、编译、汇编、链接</strong>。这里在Linux环境下展示此过程，源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hello <span class="meta-string">&quot;Hello World&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(hello);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>在这个阶段，编译器会做以下事情：</p><ul><li>将所有的#define删除，并将宏定义展开。</li><li>处理一些条件预编译指令如#ifndef,#ifdef,#elif,#else,#endif等。将不必要的代码过滤掉。</li><li>处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，因为被包含的文件可能也包含其他文件。</li><li>预处理过程还会过滤掉所有注释/**/和//里面的内容。</li><li>另外还会添加行号和文件名标识。</li><li>最后会保留#pragma编译器指令，因为编译器需要使用它们。</li></ul><p>补充：#include&lt;&gt; ，<strong>从标准库中寻找头文件，</strong>#include””，<strong>从当前目录开始寻找头文件。</strong><br>查看预处理后的文件<br><img src="https://i.loli.net/2021/05/14/p4kwEuFWPHXhiqm.png" alt="image.png"><br>在.i文件中#include&lt;stdio.h&gt;展开，输出里面的宏定义hello也被替换成Hello World<img src="https://i.loli.net/2021/05/14/EQFnMI2eHVqJ4Ni.png" alt="image.png"></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译阶段，C语言每条语句都以一种标准的文件格式确切地描述了一条低级机器语言指令<br>生成编译后的文件</p><p><img src="https://i.loli.net/2021/05/14/P4VehmoKyF1Sp2k.png" alt="image.png"></p><p>可以看到C语言文件被翻译成汇编代码，每条语句都以一种标准的文件格式确切地描述了一条低级机器语言指令<img src="https://i.loli.net/2021/05/14/bwRGcPMFemIo35T.png" alt="image.png"></p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>汇编阶段，编译器将hello.s翻译成机器语言指令, 把这些指令打包成一种可重定位目标程序的格式, 并把结果保存在hello.o中, hello.o是一个二进制文件, 它的字节编码是机器语言指令, 而不是字符<br>通过以下指令查看汇编后的文件<br><img src="https://i.loli.net/2021/05/14/MSoJZqPhRXCVfc7.png" alt="image.png"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>在这个阶段，编译器会将含有调用函数的目标文件以某种方式合并起来生成可以执行文件（比如printf函数的目标文件就在printf.o），命令：gcc hello.o -o hello</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收获 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决hexo博客图片无法加载问题</title>
      <link href="/post/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98.html"/>
      <url>/post/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p>起初搭建好博客时，发现照片无法上传本地照片，</p><p><img src="https://i.loli.net/2021/05/05/eqIWLvuprdglSfw.png" alt="image-20210420170617857.png"></p><p>根据网上的方法整了半天也没整好，最后还是室友告诉我通过下面的方法才可以引用本地照片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;path&quot; height&#x3D;&quot;xxx&quot; width&#x3D;&quot;xxx&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>但是用这个方法需要在source目录下创建一个目录来存储照片，后面写多了博客，发现这样会特别杂乱，而且最最重要的是虽然能在博客上显示，但是不能在本地显示，操作起来非常不方便。</p><p><img src="https://i.loli.net/2021/05/05/3Wb1FxCKzS79j8I.png" alt="image-20210420171012258.png"></p><p>于是在网上找了半天，各种方法都是了一遍终于发现解决办法</p><p><a href="https://www.bilibili.com/video/BV1D7411U7Yk?p=1&share_medium=android&share_plat=android&share_source=QQ&share_tag=s_i&timestamp=1618877916&unique_k=WC367T">参考链接</a></p><p>首先下载插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image</span><br></pre></td></tr></table></figure><p>之后修改博客根目录文件_config.yml中的 <code>post_asset_folder: false</code>，将其改成<code>post_asset_folder: true</code>（注意冒号后面有个空格）,然后就可以通过markdown语法正常上传照片了</p><p>这个方法不仅支持使用markdown语法，而且写博客会创建一个同名文件夹来存放照片，非常方便，而且最重要的是可以在本地预览</p>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常见的保护机制</title>
      <link href="/post/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E2%BD%A4%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.html"/>
      <url>/post/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E2%BD%A4%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="checksec（gdb安装好就有）"><a href="#checksec（gdb安装好就有）" class="headerlink" title="checksec（gdb安装好就有）"></a>checksec（gdb安装好就有）</h1><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>动态调试软件，必备。</p><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gdb</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。</p><p>用法：checksec filename</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ checksec start</span><br><span class="line">CANARY    : disabled(这个选项表示栈保护功能有没有开启。)</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : disabled</span><br></pre></td></tr></table></figure><h1 id="CANNARY-栈保护"><a href="#CANNARY-栈保护" class="headerlink" title="CANNARY(栈保护)"></a>CANNARY(栈保护)</h1><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈中高危区插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。**</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F;禁用栈保护</span><br><span class="line">gcc -fstack-protector -o test test.c   &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure><h1 id="FORTIFY-轻微的检查"><a href="#FORTIFY-轻微的检查" class="headerlink" title="FORTIFY(轻微的检查)"></a>FORTIFY(轻微的检查)</h1><p>fority其实是非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memepy,stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf， vsprintf，vsnprintf, gets以及宽字符的变体。FORTIFY_ SOURCE设为1,并且将编译器设置为优化1(gcc -01)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c &#x2F;&#x2F; 默认情况下，不会开这个检查 </span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查 </span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进⾏检查 (特别像某些头⽂件 #include &lt;str _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编 </span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查 gcc -D_FORTIFY_SOURCE&#x3D;2 程序执⾏时也会有检查 (如果检查到缓冲区溢出，就终⽌程序) _FORTIFY_SOURCE设为2，有些检查功能会加⼊，但是这可能导致程序崩溃。</span><br></pre></td></tr></table></figure><h1 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h1><p>N X （ D E P）的基本原理是将数据所在内存⻚标识为不可执⾏,当程序溢出成功转⼊shellcode时，程序会尝试在数据⻚⾯上执⾏指令，此时CPU就会抛出异常 ,⽽不是去执⾏恶意指令 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c &#x2F;&#x2F; 禁⽤NX保护 </span><br><span class="line">gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护</span><br></pre></td></tr></table></figure><p>在Windows下，类似的概念为DEP（数据执行保护）,数据执⾏保护( D E P ) （ Data Execution Prevention ） 是⼀套软硬件技术，能 够 在 内 存上执⾏额外检查以帮助防⽌在系统上运⾏恶意代码 ,在最新版的Visual Studio中默认开启了DEP编译选项。</p><h1 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h1><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。PIE和ASLR不是一样的作用，ASLR只能对堆、栈,ibc和mmap随机化，而不能对代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。联系点在于在开启ASLR之后，PIE才会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c &#x2F;&#x2F; 默认情况下，不开启PIE </span><br><span class="line">gcc -fpie -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时强度为1 </span><br><span class="line">gcc -fPIE -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时为最⾼强度2 </span><br><span class="line">gcc -fpic -o test test.c &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c &#x2F;&#x2F; 开启PIC，此时为最⾼强度2，不会开启PIE</span><br></pre></td></tr></table></figure><h1 id="ASLR-Address-Space-Layout-Randomization"><a href="#ASLR-Address-Space-Layout-Randomization" class="headerlink" title="ASLR (Address Space Layout Randomization)"></a>ASLR (Address Space Layout Randomization)</h1><p>ASLR是⼀种针对缓冲区溢出的安全保护技术,通过对堆栈 、共享库映射等线性区布局的随机化，通过增加攻击者预测⽬的地址的难度,防⽌攻击者直接定位攻击代码位置,达到阻⽌溢出攻击的⽬的。 </p><p>参考文章：<a href="https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/post/%E6%8C%87%E9%92%88.html"/>
      <url>/post/%E6%8C%87%E9%92%88.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>指针，并不像一些书上写的只是用于存储地址，它是一种类型数据，存储什么都可以，并不是只能存储地址。</p></blockquote><h1 id="指针大小"><a href="#指针大小" class="headerlink" title="指针大小"></a>指针大小</h1><p>常见的指针有：char *，int *，float * …，但char * * *，int * * *…同样也是指针(多级指针)，同时虽然指针类型有很多种，但是无论是什么指针，它的大小都是4字节</p><p><img src="https://i.loli.net/2021/05/05/PmceYN9yIhqsuvS.png" alt="image-20210424091058737.png"></p><p><img src="https://i.loli.net/2021/05/05/DtRNdGF2SLETQVK.png" alt="image-20210424091147106.png"></p><p><img src="https://i.loli.net/2021/05/05/ojyaBueg5ivV1U8.png" alt="image-20210424091239641.png"></p><p>可以看到没有声明指针时抬栈40字节，声明以后抬栈44字节，说明声明变量消耗0x50-0x44h也就是12字节，也就是说每个指针占4字节空间</p><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h1><p>指针只能进行加减法运算，不能乘除运算，同时加法运算并不是普通加法运算，其中遵守着一些规则</p><p><img src="https://i.loli.net/2021/05/05/notVls4NRHmuh9O.png" alt="image-20210423211741031.png"></p><p>如上，左边的输出：101  101  101 ，右边输出：104  104  104，因为右边去掉一个* 还是指针类型数据，如果去掉 * 是char或者int等就是加或减那个类型的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">         <span class="keyword">char</span> *b;</span><br><span class="line">a=<span class="number">100</span>;</span><br><span class="line">         b=<span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,++a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,++b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：104 101</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c=<span class="number">1</span>,d=<span class="number">2</span>;</span><br><span class="line">  swap1(c,d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,c,d);</span><br><span class="line">  swap2(&amp;c,&amp;d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,c,d);</span><br><span class="line">  swap3(&amp;c,&amp;d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,c,d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t=a;</span><br><span class="line">  a=b;</span><br><span class="line">  b=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t=a;</span><br><span class="line">  a=b;</span><br><span class="line">  b=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t=*a;</span><br><span class="line">  *a=*b;</span><br><span class="line">  *b=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中就只有swap3成功交换了c与d的值，首先每个全局变量或者被调用的变量都有个地址，变量被修改其实就是变量对应的地址的值被修改，如果被修改的值不能返回到地址中，变量就不会改变。在swap1(c,d)中，c与d的值被压入栈中，swap1(c,d)只是处理栈中的值，被修改的值并不会返回到c和d的地址中，所以函数里面再怎么交换也不会影响变量c与d，而swap2(c,d)虽然可以运行，但是是错误的写法，int与int*不能相互赋值，系统并不会执行，同时还会产生警告</p><p><img src="https://i.loli.net/2021/05/05/FzDVMOpsdgXei6N.png" alt="image-20210423201704008.png"></p><p>而最后的swap3函数则是处理c与d的地址，先将a地址对应的值赋给t，在将b地址的值存入a地址中，最后向b地址存入t值（也就是a的值），符合编译器的调用约定，系统可以执行</p><p>通过这个可知，如果只是将变量的值传入子函数中，并不会影响变量，要想通过子函数修改子函数外的变量，需要找出变量的地址，并将修改的值存入变量地址中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  add(a,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;c;i++)</span><br><span class="line">    a[i]+=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是处理数组的，子函数调用数组时，传入的其实就是该数组的首地址，所以会直接修改数组的值。（为了防止数组被函数修改，可以在调用数组前加const，只要函数修改数组，编译器就会报错。）</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收获 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assembly Language（32位）</title>
      <link href="/post/Assembly%20Language%EF%BC%8832%E4%BD%8D%EF%BC%89.html"/>
      <url>/post/Assembly%20Language%EF%BC%8832%E4%BD%8D%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>重新复习了一遍汇编，这次看的是32位的，有了一点点收获，就随便写写</p></blockquote><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><img src="/images/58.png" height="400" width="350" /><p>x86的寄存器包括8位、16位、32位，其中32位寄存器可以分为16位或者8位，如EAX可以分为16位AX或者8位AH、AL，但是EBX以后的寄存器就不可以了，虽然是通用寄存器但是每个通用寄存器都有一些特殊的用途</p><h2 id="EAX"><a href="#EAX" class="headerlink" title="EAX"></a>EAX</h2><p>EAX与STOS指令相关，STOS会将EAX的值存进EDI指定的内存单元中，同时还经常存储计算结果</p><h2 id="ECX"><a href="#ECX" class="headerlink" title="ECX"></a>ECX</h2><p>ECX与REP指令相关，用于记录指令循环次数</p><h2 id="EDI和ESI"><a href="#EDI和ESI" class="headerlink" title="EDI和ESI"></a>EDI和ESI</h2><p>EDI和ESI用于做地址复制，将ESI指定的地址中的值赋值到EDI指定的地址中，与movs指令有很大关系</p><img src="/images/59.png" height="400" width="700" /><h2 id="ESP"><a href="#ESP" class="headerlink" title="ESP"></a>ESP</h2><p>ESP用于存储当前栈堆用到的地址</p><h2 id="EFL（标志寄存器）"><a href="#EFL（标志寄存器）" class="headerlink" title="EFL（标志寄存器）"></a>EFL（标志寄存器）</h2><p>EFI的第十位（DF）如果是零，使用push，pop指令后ESP会加相应数值，如果是一，则减去相应数值。</p><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><p>EIP用于存储计算机执行下一个指令的地址</p><h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>堆栈本质就是一段内存，在程序启动前就已经被分配好了，堆栈会存储程序重要的信息，被称为“程序的心脏”</p></blockquote><p>32位上的应用大部分采用小端模式，手机上的应用大部分采用大端模式</p><h2 id="小段模式"><a href="#小段模式" class="headerlink" title="小段模式"></a>小段模式</h2><p>从高地址开始存放，往低地址去</p><h2 id="大端模式"><a href="#大端模式" class="headerlink" title="大端模式"></a>大端模式</h2><p>从低地址开始存放，往高地址去</p><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="MOV-移动指令"><a href="#MOV-移动指令" class="headerlink" title="MOV(移动指令)"></a>MOV(移动指令)</h2><p>将指定的值移动指定位置（内存地址或寄存器）</p><h2 id="ADD-加法指令"><a href="#ADD-加法指令" class="headerlink" title="ADD(加法指令)"></a>ADD(加法指令)</h2><p>将指定的两个值相加，结果返回到指定位置（内存地址或寄存器）</p><h2 id="SUB-减法指令"><a href="#SUB-减法指令" class="headerlink" title="SUB(减法指令)"></a>SUB(减法指令)</h2><p>将指定的两个值相减，结果返回到指定位置（内存地址或寄存器）</p><h2 id="AND-与运算指令"><a href="#AND-与运算指令" class="headerlink" title="AND(与运算指令)"></a>AND(与运算指令)</h2><p>与运算：两个为一才为一</p><p>将指定的两个值进行与运算，结果返回到指定位置（内存地址或寄存器）</p><h2 id="OR-或运算指令"><a href="#OR-或运算指令" class="headerlink" title="OR(或运算指令)"></a>OR(或运算指令)</h2><p>或运算：有一就为一</p><p>将指定的两个值进行或运算，结果返回到指定位置（内存地址或寄存器）</p><h2 id="XOR-异或运算指令"><a href="#XOR-异或运算指令" class="headerlink" title="XOR(异或运算指令)"></a>XOR(异或运算指令)</h2><p>异或运算：不一样为一</p><p>将指定的两个值进行异或运算，结果返回到指定位置（内存地址或寄存器）</p><h2 id="NOT-非运算指令"><a href="#NOT-非运算指令" class="headerlink" title="NOT(非运算指令)"></a>NOT(非运算指令)</h2><p>非运算：一为零，零为一</p><p>将指定的一个值进行非运算，结果返回原位置（内存地址或寄存器）</p><h2 id="SHL-左移指令"><a href="#SHL-左移指令" class="headerlink" title="SHL(左移指令)"></a>SHL(左移指令)</h2><p>shl（C语言：&lt;&lt;）</p><p>高位丢弃,低位补零</p><h2 id="右移指令"><a href="#右移指令" class="headerlink" title="右移指令"></a>右移指令</h2><p>汇编 shr：高位补零，低位丢弃</p><p>​         sar：高位补符号位，地位丢弃（就是补最高位的数字）</p><p>C语言 &gt;&gt; 无符号数：高位补零，低位丢弃</p><p>​                 有符号数：高位补符号位，低位丢弃</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Assembly Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH连接失败</title>
      <link href="/post/SSH%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5.html"/>
      <url>/post/SSH%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>闲的无聊就整了一下博客，结果出大问题了，之前的备份又删了，所以不得不重建，这次重建花了整整一天，虽说浪费时间但是还是有所收获</p></blockquote><p>搭建博客视频网上一大堆，这里就不多讲了，这里就讲一下错误和如何解决</p><h1 id="ssh-connect-to-host-github-com-port-22-Connection-timed-out"><a href="#ssh-connect-to-host-github-com-port-22-Connection-timed-out" class="headerlink" title="ssh: connect to host github.com port 22: Connection timed out"></a>ssh: connect to host github.com port 22: Connection timed out</h1><p>这个问题烦了我几个小时，网上的解决方法参差不齐（反正我通过网上的方法没用解决），最后还是看官方的解决方法（还是官方的靠谱）<a href="https://docs.github.com/en/github/authenticating-to-github/using-ssh-over-the-https-port">Using SSH over the HTTPS port</a>。</p><p>出现这个问题是因为22端口被占用或者防火墙不允许ssh连接。解决方法是通过通过HTTPS启用SSH连接，命令：ssh -T -p 443 <a href="mailto:&#x67;&#x69;&#116;&#64;&#x73;&#x73;&#104;&#46;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#x69;&#116;&#64;&#x73;&#x73;&#104;&#46;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>，运行时输入yes，这样可以强制连接，连接成功后就可以进行下一步操作了（不成功可以看官方给的<a href="https://docs.github.com/en/articles/error-permission-denied-publickey">故障排除指南</a>），成功后，在.ssh文件夹中创建一个config文件（千万千万别加后缀名！）内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br><span class="line">  User git</span><br></pre></td></tr></table></figure><p>最后输入：ssh -T <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>看是否成功连接</p><p>成功连接如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not</span><br><span class="line">&gt; provide shell access.</span><br></pre></td></tr></table></figure><p>简单介绍一下<a href="https://ru.wikipedia.org/wiki/SSH">SSH</a>，博客上传时，如果没用通过ssh连接的话，需要输入密码，通过ssh远程连接以后就不需要了</p>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bugku</title>
      <link href="/post/bugku.html"/>
      <url>/post/bugku.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUGKU-misc部分"><a href="#BUGKU-misc部分" class="headerlink" title="BUGKU misc部分"></a>BUGKU misc部分</h1><h2 id="1-这是一张单纯的图片"><a href="#1-这是一张单纯的图片" class="headerlink" title="1 这是一张单纯的图片"></a>1 这是一张单纯的图片</h2><p>先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样，</p><img src="/images/21.png" height="500" width="600" /><p>直接丢winhex，拖至最底，发现是unicode加密</p><img src="/images/22.png" height="500" width="600" /><p>发现是unicode加密，直接解码成ASCII，得到flag</p><img src="/images/23.png" height="500" width="600" /><hr><h2 id="2-隐写"><a href="#2-隐写" class="headerlink" title="2 隐写"></a>2 隐写</h2><p>看到题目就知道是图片隐写，对图片进行校验和，发现结果有问题，说明照片高度被修改了</p><img src="/images/24.png" height="500" width="600" /><p>修改高度得到flag</p><img src="/images/25.png" height="400" width="300" /><hr><h2 id="3-telnet"><a href="#3-telnet" class="headerlink" title="3 telnet"></a>3 telnet</h2><p>下载附件后打开，直接追踪TCP流就得到了flag</p><img src="/images/26.png" height="500" width="600" /><hr><h2 id="4-眼见非实"><a href="#4-眼见非实" class="headerlink" title="4 眼见非实"></a>4 眼见非实</h2><p>打开后发现文件是损坏的而且出现了PK字符，猜测里面藏有压缩包，于是改成压缩包形式打开</p><img src="/images/27.png" height="500" width="600" /><p>在word里面的document.xml里面发现了flag</p><img src="/images/28.png" height="500" width="600" /><hr><h2 id="5-啊哒"><a href="#5-啊哒" class="headerlink" title="5 啊哒"></a>5 啊哒</h2><p>老规矩，打开照片看属性，发现照相机型号有东西，之后应该用得上</p><img src="/images/29.png" height="600" width="600" /><p>用binwalk查看，发现里面藏有一个压缩包，用foremost进行分离得到压缩包，打开发现是加密的，尝试了照相机型号，发现密码错误，分析了一下那串照相机型号，发现是十六进制，之后解码得到密码</p><img src="/images/30.png" height="600" width="600" /><p>打开得到flag</p><img src="/images/31.png" height="600" width="600" /><hr><h2 id="6-ping"><a href="#6-ping" class="headerlink" title="6 ping"></a>6 ping</h2><p>用wireshark打开后发现十六进制旁边一个f，打开其它的发现组合起来是flag</p><img src="/images/32.png" height="600" width="500" /><hr><h2 id="7-赛博朋克"><a href="#7-赛博朋克" class="headerlink" title="7 赛博朋克"></a>7 赛博朋克</h2><p>打开后发现就一个光秃秃的加密文件，不用猜都知道是伪加密，丢进winhex修改一下就可以打开了</p><img src="/images/33.png" height="600" width="500" /><p>打开文件后发现是一堆乱码，丢进winhex发现是png格式照片</p><img src="/images/34.png" height="600" width="400" /><p>修改一下后缀名图片就出来了，不过好像flag还没出来，属性里面也没什么东西，校验和也正确，binwalk也没查出问题</p><img src="/images/35.png" height="600" width="400" /><img src="/images/36.png" height="400" width="600" /><p>最后推测一个是lsb隐写，果不其然，得到flag</p><img src="/images/37.png" height="500" width="600" /><hr><h2 id="8-贝斯手"><a href="#8-贝斯手" class="headerlink" title="8 贝斯手"></a>8 贝斯手</h2><p>打开介绍发现是对图片上人物介绍，刚想关闭发现最下面还有东西，发现密码是四位数和这个贝斯手有关</p><img src="/images/38.png" height="500" width="600" /><p>懒得搜直接暴力破解</p><img src="/images/39.png" height="500" width="600" /><p>打开后发现是一串加密字符，5+58应该加密方式MD5和base58</p><img src="/images/40.png" height="500" width="600" /><p>解码得到flag</p><img src="/images/41.png" height="500" width="500" /><img src="/images/42.png" height="500" width="600" /><hr><h2 id="9-又一张图片，还单纯吗"><a href="#9-又一张图片，还单纯吗" class="headerlink" title="9 又一张图片，还单纯吗"></a>9 又一张图片，还单纯吗</h2><p>打开属性发现没有有用的信息，丢进winhex里面也没发现什么，用binwalk查看发现照片里面有其它jpg照片，用forem分离</p><img src="/images/43.png" height="500" width="600" /><p>发现图片里面有flag（不过这个flag有点长，有点离谱）</p><img src="/images/44.png" height="500" width="600" /><hr><h2 id="10-猜"><a href="#10-猜" class="headerlink" title="10 猜"></a>10 猜</h2><p>签到题，百度识图，发现是刘亦菲，得到flag（注意flag格式）</p><hr><h2 id="11-宽带信息泄露"><a href="#11-宽带信息泄露" class="headerlink" title="11 宽带信息泄露"></a>11 宽带信息泄露</h2><p>下载RouterPassView，用这个搜索username（用户名）</p><img src="/images/53.png" height="500" width="600" /><hr><h2 id="12-隐写2"><a href="#12-隐写2" class="headerlink" title="12 隐写2"></a>12 隐写2</h2><p>直接丢进winhex，发现jpg图片结尾后面有压缩包的字符</p><img src="/images/45.png" height="500" width="600" /><p>用foremost分离得到一个加密的文件和密码提示，解密（直接爆破，反正是三位数）得到一张图片</p><img src="/images/46.png" height="500" width="600" /><p>老规矩丢winhex，发现最后有flag</p><img src="/images/47.png" height="500" width="600" /><hr><h2 id="13-多种方法解决"><a href="#13-多种方法解决" class="headerlink" title="13 多种方法解决"></a>13 多种方法解决</h2><p>这道题提示说有二维码，打开附件发现是一个exe可执行文件（尝试打开发现无法运行），直接丢winhex</p><img src="/images/48.png" height="500" width="600" /><p>发现是旁边是加密的图片编码，直接在线解码得到flag</p><img src="/images/49.png" height="500" width="600" /><hr><h2 id="14-闪的好快"><a href="#14-闪的好快" class="headerlink" title="14 闪的好快"></a>14 闪的好快</h2><p>emmmm，这道题挺简单的就是好烦，用Stegsolve.jar一帧一帧看，扫码，flag就出来了</p><hr><h2 id="15-come-game"><a href="#15-come-game" class="headerlink" title="15 come_game"></a>15 come_game</h2><p>打开后是个游戏，每次死亡都会多个文件，找到save1将它丢尽winhex里面，将2AC改成5AC在进游戏就可以得到flag，当然如果觉得能闯过去也应该能得到flag。（我没试过，不确定能不能行，提醒一下这个游戏打开了好像不能关闭）</p><img src="/images/50.png" height="500" width="600" /><hr><h2 id="16-白哥的鸽子"><a href="#16-白哥的鸽子" class="headerlink" title="16 白哥的鸽子"></a>16 白哥的鸽子</h2><p>直接丢进winhex里面，发现照片结尾后面多出一些字符，分析一下就知道是栅栏加密</p><img src="/images/51.png" height="500" width="600" /><p>解密（密匙我是一个一个试的，不过还好就是3，后面才知道那个提示“咕咕咕”好像就代表key=3）</p><img src="/images/52.png" height="500" width="600" /><h2 id="17-linux"><a href="#17-linux" class="headerlink" title="17 linux"></a>17 linux</h2><p>看到题目就知道要用Linux系统</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐周五</title>
      <link href="/post/tuoli.html"/>
      <url>/post/tuoli.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>这是这几个月最值得纪念的周五，体验了脱离学校的快乐</p></blockquote><p>2020.12.13</p><p>  晚上和社团其它人一起谋划着“出校大计”，原本定在周六，但是由于学校要体测（挺佩服学校挑时间的能力🤬），不得不将时间改成周五，让快乐减少了一半😔</p><p>2020.12.15</p><p>  果然到了周末就会发现屁事很多😔，一个个周末都有事，只剩几个大男人可以出去，这次出校也变成了“罗汉出行”，照这样下去，不知道之后几天会发生什么😱</p><p>2020.12.17</p><p>  原本课上得好好的，突然一个朋友说周六体测取消了，改了时间，我直接当场爆炸🤬，没办法假条都上交了，时间也不能修改，只能认命</p><p>2020.12.18</p><p>  原本计划好的五个人，要走的时候最后一个人掉链子😔，最后变成四罗汉出行。</p><p>开始打算看电影，但是觉得没什么好看的电影加上时间不够，所以改成了密室逃脱（补充一下，有个当地人带路非常重要😃）</p><img src="/images/17.jpg" height="400" width="350" /><img src="/images/16.jpg" height="400" width="350" /><img src="/images/15.jpg" height="400" width="350" /><p>游戏体验还不错（除了那个怕鬼的师兄），还送了一个纪念品（下面的是买奶茶送的纪念品）😃</p><img src="/images/20.jpg" height="400" width="350" /><p>最后去吃了碗拉面，味道还是相当不错的，就是价格有点小贵/(ㄒoㄒ)/~~</p><p>饭后去逛了一下，带点东西给室友，最后打的回校</p><img src="/images/19.jpg" height="400" width="350" /><p>  这次行程还是不错的（比呆在学校好多了），发现南昌还是蛮好玩的，但就是不知道下次出去是什么时候了😔</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 娱乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础知识</title>
      <link href="/post/C.html"/>
      <url>/post/C.html</url>
      
        <content type="html"><![CDATA[<h1 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h1><p>C 语言是一种通用的、面向过程式的计算机程序设计语言，C 语言是一种通用的高级语言。C语言的特点有：</p><ul><li>易于学习</li><li>结构化语言</li><li>它产生高效率的程序</li><li>它可以处理底层的活动</li><li>它可以在多种计算机平台上编译</li></ul><hr><h1 id="C语言程序的结构"><a href="#C语言程序的结构" class="headerlink" title="C语言程序的结构"></a>C语言程序的结构</h1><p><strong>C语言程序主要是有函数构成，函数是C语言程序的基本单位。</strong>一个C语言源程序必须有一个main函数（也叫主函数），其中可以包含一个main函数和若干个其他函数，但<strong>C语言程序主函数只能有1个。C程序中main()称之为主函数，是所有程序运行的入口。</strong>同时，<strong>程序执行总是从main函数开始，如果有有其他函数，则完成对其他函数的调用后再返回到主函数，最后由main函数结束整个程序。</strong></p><h2 id="函数组成"><a href="#函数组成" class="headerlink" title="函数组成"></a>函数组成</h2><p>函数首部，函数体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                  <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;    <span class="comment">//对调用函数max的声明</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;               <span class="comment">//定义整数型变量x,y,z</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);      <span class="comment">//输入变量x,y的值</span></span><br><span class="line">    z=max (x,y);             <span class="comment">//调用函数max，将得到的值赋给z</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max is %d\n&quot;</span>,z); <span class="comment">//输出z</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>         <span class="comment">//定义max函数</span></span></span><br><span class="line"><span class="function"></span>&#123;                            <span class="comment">//定义变量z为整数型</span></span><br><span class="line">    <span class="keyword">int</span> z;                   <span class="comment">//如果x&gt;y，则将x的值赋给变量z</span></span><br><span class="line">    <span class="keyword">if</span> (x&gt;y) z=x;            <span class="comment">//否则，将y的值赋给变量z </span></span><br><span class="line">    <span class="keyword">else</span> z=y;                <span class="comment">//将z的值返回到主函数中调用函数的位置</span></span><br><span class="line">    <span class="keyword">return</span> (z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>int main()和int max(int x,int y)都是函数首部</p></li><li><p>函数下面的{}内的部分是函数体。函数体包括<strong>声明部分</strong>和<strong>执行部分</strong></p></li></ul><h1 id="运行C程序的步骤"><a href="#运行C程序的步骤" class="headerlink" title="运行C程序的步骤"></a>运行C程序的步骤</h1><p>1、上机输入和编辑源程序</p><p>2、对源程序进行编译</p><p>3、进行连接处理</p><p>4、运行可执行程序，得到运行结果</p><img src="/images/14.jpg" height="500" width="350"/><hr><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><strong>算法+数据结构=程序</strong></p><ul><li><p><strong>数据结构</strong></p><p>在程序中要指定用哪些数据和这些数据的类型以及数据的组织形式，这就是数据结构</p></li><li><p><strong>算法</strong></p><p>算法是解决“做什么”和“怎么做”的问题。程序中的操作语句，就是算法的体现</p><p>表示算法的方法：自然语言、传统流程图、结构化流程图、伪代码等</p></li></ul><h1 id="数型类型（64位）"><a href="#数型类型（64位）" class="headerlink" title="数型类型（64位）"></a>数型类型（64位）</h1><table><thead><tr><th align="left">类型</th><th>字节数</th><th>取值范围</th></tr></thead><tbody><tr><td align="left">char(字符型)</td><td>1</td><td></td></tr><tr><td align="left">float(浮点型)</td><td>4</td><td></td></tr><tr><td align="left">double(浮点型)</td><td>8</td><td></td></tr><tr><td align="left">[ signed] int (基本整型)</td><td>4</td><td>-2^31~2^31-1</td></tr><tr><td align="left">unsigned int (无符号基本整型)</td><td>4</td><td>0~2^31-1）</td></tr><tr><td align="left">[ signed ]short [ int ] (短整型)</td><td>2</td><td>-2^15~2^15-1</td></tr><tr><td align="left">unsigned short [ int ] (无符号短整型)</td><td>2</td><td>0~2^16-1</td></tr><tr><td align="left">long [int] (长整型)</td><td>4</td><td>-2^31~2^31-1</td></tr><tr><td align="left">unsigned long [ int ] (无符号长整型)</td><td>4</td><td>0~4294967295</td></tr><tr><td align="left">long long [ int ] (双长型)(c99支持)</td><td>8</td><td>-2^63~2^63-1</td></tr><tr><td align="left">unsigned long long [ int ] (无符号双长整型)</td><td>8</td><td>0~2^64-1</td></tr></tbody></table><p><em>long int(long)和int的区别：虽然都是4字节没什么区别，但是这是在64位的标准，如果在16位或者在32位的电脑上面就不一定是都是4字节，16位机：int的取值位16位，long int的取值为32位；32位机：int的取值位32位，long int的取值为32位；64位机：int的取值位32位，long int的取值为32位，所以会满足下面的关系</em>。</p><p><strong>long≥int≥short</strong></p><h1 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h1><h2 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h2><p>输出字符串需要%s (%5.2s其中5的意思是长度，2的意思是保留个数) //比如输出hello字符串，%5.2s就会输出：   he</p><p>输出 char 类型数据需要  %c</p><p>输出 float 类型数据需要  %f (默认是六位小数，如果想控制保留的位数需加“.x”x是所要保留的位数，如保留两位小数：%.2f)</p><p>输出 double 类型数据需要  %f</p><p>输出 int 类型数据需要  %d (如果d前面加数字意思时补位)</p><p>输出 unsigned int 类型数据需要  %u</p><p>输出 short 类型数据需要  %hd</p><p>输出 unsigned short 类型数据需要  %u</p><p>输出 long 类型数据需要  %ld(也可以使用%d，但是这会给程序移植到其他系统（这两种数据类型的长度不一样的系统）带来麻烦，所以建议使用%ld)</p><p>输出 unsigned long 类型数据需要  %lu</p><p>输出 long long 类型数据需要  %lld</p><p>输出 unsigned long long 类型数据需要  %llu</p><p>输出 变量地址需要%p</p><p>*<em>在%后面加 * 是指宽度（自己决定），例如：printf(“%<em>d”,width,a)</em></em></p><p><strong>float 和 double 虽然类型都是浮点型，但是double双精度更为精确，但是double更占内存，所以要根据情况而定。</strong></p><p><strong>不同位数计算机中数据类型所占字节数有些不同，上述所述为32位计算机</strong></p><p><strong>如果规定输出格式，如输出的数据必须为八进制或十六进制则需要以下方式输出</strong></p><h2 id="按特定格式输出"><a href="#按特定格式输出" class="headerlink" title="按特定格式输出"></a>按特定格式输出</h2><p>八进制：%o  %#o(格式化)</p><p>十六进制：%x  %#x(格式化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">a=<span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%O  %#o \n&quot;</span>,a,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%X  %#x&quot;</span>,a,a);</span><br><span class="line">getchar(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><img src="/images/56.png" height="400" width="400" /><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>输出“ ？”：/？</p><p>输出 “/” ：//</p><p>输出 “%” ：%%</p><p>断行（就是输出太多，一行放不下，需要另起一行）：/</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>printf返回值一般是用于检测是否打印错误，返回值是输出字符的个数（scanf的返回值也是如此）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv;</span><br><span class="line">    rv=<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,rv);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><img src="/images/57.png" height="300" width="400" /><p>rv=printf(“Hello World”)这一行的作用一是打印Hello World,而是将printf的返回值赋给rv（“\n”算一个）</p><h2 id="scanf输入"><a href="#scanf输入" class="headerlink" title="scanf输入"></a>scanf输入</h2><p>scanf用法和printf类似，要注意的是scanf读取一个数的时候要加地址符&amp;，<strong>但如果是数组则不需要加（因为数组的名字就是地址，不需要再寻找</strong></p><p><strong>输入double时不是 ”%f“ 而是 ”%lf“，而float则是 “%f”</strong></p><p><strong>输入时读取到空格和回车视为读取结束</strong></p><p>如果输入时一开始就是空格，那么计算机就会一直往后读取直到遇到数字或者符号（例外%c可以读取空格）</p><p>%后面加 “ * ” 意思是丢弃不读入，如：scanf(“%*d %c”,&amp;a)，其中a的值是读入的%c，前面的直接被丢弃</p><hr><h1 id="输入、输出函数"><a href="#输入、输出函数" class="headerlink" title="输入、输出函数"></a>输入、输出函数</h1><p>前面讲了格式化输入输出，但发现仅仅使用格式化输入输出有时会显得十分繁琐，所以需要我们学习其它的输入输出函数</p><h2 id="字符输入输出（getchar-putchar）"><a href="#字符输入输出（getchar-putchar）" class="headerlink" title="字符输入输出（getchar/putchar）"></a>字符输入输出（getchar/putchar）</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>有些时候，仅仅为了在显示器屏幕上打印或从控制台获取一个字符，此时使用功能强大的printf与scanf函数，则显得过于繁琐，C提供了一个库函数putchar/getchar来完成这个简单的任务。</p></blockquote><p>getchar()函数只能读取单个字符，有时只读取一个字符（注意是以字符的形式存储）时较为方便，例：a=getchar();scanf(“%c”,&amp;a);</p><p>putchar()函数是字符输出函数， 其功能是在显示器上打印单个字符。putchar函数是一个标准的C语言库函数，它的函数原型在头文件“stdio.h”中。</p><p><strong>scanf与getchar</strong></p><p>首先，我们输入时，比没有直接被读取，而是先存放在缓冲区，在被读取。知道这个原理后就可以比较scanf和getchar，拿一个例子来讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">    c=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %c&quot;</span>,a,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：1 &lt;回车&gt;2</p><p>输出结果是：第一行：1 2  第二行： </p><p>首先，输入1 回车后，1会存进变量a中，而回车还会停留在缓冲区，之后输入2，此时缓冲区存放了回车和2，但是scanf是无法读取回车，所以回车被跳过，2存进了变量b中，因为scanf可以读取回车（即换行），所以缓冲区的回车就会进入c中，最后就会输出如上结果</p><h2 id="字符串输入输出函数-（gets与puts）"><a href="#字符串输入输出函数-（gets与puts）" class="headerlink" title="字符串输入输出函数 （gets与puts）"></a>字符串输入输出函数 （gets与puts）</h2><p>gets函数从标准输入设备读字符串函数。可以无限读取，不会判断上限，以回车结束读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。此函数在stdio.h头文件中定义的。当然，scanf也可以做到。例如：gets(a);scanf(“%[ ^\n ]”,a)（其中a是数组）</p><p>puts函数功能非常单一，在显示器屏幕上输出一个字符串，并换行。</p><h1 id="define"><a href="#define" class="headerlink" title="define"></a>define</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>之所以单独拿出来讲，是因为容易出错</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>**#define 标识符 常量 ** //注意, 最后没有分号，同时标识符和常量间只有一个空格</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>define作用类似于赋值，但它更加灵活，可以将用一些字符代替字符串，如：</p><p>#define A “nihao”；#define A 0；#define A ‘a’</p><p><strong>因为nihao是字符串，所以需要加双引号，如果只是数字就不需要，如果是字符就需要单引号。除此之外，虽然没有硬性规定define后面定义的字符要大写，但一般都是要遵守的</strong></p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=M*M/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码输出结果很容易被认为是8，但实际输出结果是6</p><p>错误原因：</p><p>首先，M被定义为3+1，在计算a前不会编译器不会先计算3+1而是直接将3+1带入进去，所以a=M * M/2就变成了a=3+1 * 3+1,之后因为M是整型数据，所以会把小数点后面的数丢弃所以最终答案为6</p><h2 id="与const的区别"><a href="#与const的区别" class="headerlink" title="与const的区别"></a>与const的区别</h2><ul><li>编译器处理方式不同<br> 　#define宏是在预处理阶段展开。<pre><code>　const常量是编译运行阶段使用。</code></pre></li><li>类型和安全检查不同<br> 　#define宏没有类型，不做任何类型检查，仅仅是展开。<pre><code>　const常量有具体的类型，在编译阶段会执行类型检查。</code></pre></li><li>存储方式不同<br> 　#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）<pre><code>　const常量会在内存中分配(可以是堆中也可以是栈中)。</code></pre></li><li>const  可以节省空间，避免不必要的内存分配。 例如：<br> #define NUM 3.14159  //常量宏<br> const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ……<br> double i = Num; //此时为Pi分配内存，以后不再分配！<br> double  I= NUM; //编译期间进行宏替换，分配内存<br> double j = Num; //没有内存分配<br> double J = NUM; //再进行宏替换，又一次分配内存！<br> const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。</li><li>提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</li><li>宏替换只作替换，不做计算，不做表达式求解;<br> 宏预编译时就替换了，程序运行时，并不分配内存。</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>i++与++i的区别（i–和–i同理）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i++,++i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,i);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>1 2</p><p>2 2</p><p>i++是运行这条指令后加一，而++i是运行前加一，所以会出现一开始输出1 2这种情况，同时，递增（递减）的运算优先级很高，只有圆括号比它高，所以使用时需注意，例如，<strong>a * b++不会等于a*b+1而是（a) * （b+1）</strong>。</p><p>不同类型数据运算：</p><p>不同类型数据进行计算时，编译器会将低精度数据转化为高精度，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    print(<span class="string">&quot;%d&quot;</span>,a/b);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运算a/b时，a会自动升级为float型，当然，也可以强制转化，在a前面加（float）就可以使a转换为float型</p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><h2 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h2><h3 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h3><p>如果函数不接收用户传递的数据，那么定义时可以不带参数。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataType functionName()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>dataType 是返回值类型，它可以是C语言中的任意数据类型，例如 int、float、char 等。</p></li><li><p>functionName 是函数名，它是<a href="http://c.biancheng.net/cpp/html/2927.html">标识符</a>的一种，命名规则和标识符相同。函数名后面的括号<code>( )</code>不能少。</p></li><li><p>body 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由<code>&#123; &#125;</code>包围。</p></li><li><p>如果有返回值，在函数体中使用 return 语句返回。return 出来的数据的类型要和 dataType 一样。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;Hello,world \n&quot;</span>);    <span class="comment">//没有返回值就不需要 return 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="有参函数的定义"><a href="#有参函数的定义" class="headerlink" title="有参函数的定义"></a>有参函数的定义</h2><p>如果函数需要接收用户传递的数据，那么定义时就要带上参数。如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dataType <span class="title">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dataType1 param1, dataType2 param2 ...</code>是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由<code>,</code>分隔。参数本质上也是变量，定义时要指明类型和名称。与无参函数的定义相比，有参函数的定义仅仅是多了一个参数列表。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从m加到n的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = m+<span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        m += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, total;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    total = sum(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total=%d\n&quot;</span>, total);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数定义处的 m、n 是形参，函数调用处的 a、b 是实参</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assembly Language</title>
      <link href="/post/Assembly%20Language.html"/>
      <url>/post/Assembly%20Language.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h1><p>通过用汇编语言进行编程而深入地理解计算机底层的基本工作机理，达到随心所欲地控制计算机的目的</p><h1 id="汇编语言的由来"><a href="#汇编语言的由来" class="headerlink" title="汇编语言的由来"></a>汇编语言的由来</h1><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p><h1 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h1><ul><li><p>机器相关性：</p><p>一种面向机器的低级语言，几乎接近机器语言</p></li><li><p>不可移植：</p><p>不同类型的CPU有不同的机器指令系统，也就有不同的汇编语言</p></li><li><p>操作对象：</p><p>汇编语言是直接面向处理器（Processor）的程序设计语言，它所操作的对象不是具体的数据,而是寄存器或者存储器</p></li><li><p>高速度和高效率：</p><p>汇编语言保持了机器语言的优点，具有直接和简捷的特点，可有效地访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等，且占用内存少，执行速度快，是高效的程序设计语言</p></li><li><p>编写和调试的复杂性</p><p>由于是直接控制硬件，且简单的任务也需要很多汇编语言语句，因此在进行程序设计时必须面面俱到，需要考虑到一切可能的问题，合理调配和使用各种软、硬件资源。这样，就不可避免地加重了程序员的负担。与此相同，在程序调试时，一旦程序的运行出了问题，就很难发现</p></li></ul><h1 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h1><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>机器码的助记符，有对应的机器码，最终被cpu执行</p></blockquote><p>具体请参考<a href="https://blog.csdn.net/bjbz_cxy/article/details/79467688">网页链接</a></p><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>没有对应的机器码，由编译器执行，计算机不执行</p></blockquote><h2 id="其它符号"><a href="#其它符号" class="headerlink" title="其它符号"></a>其它符号</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>如+、-、*、/等，由编译器识别，没有对应的机器码</p></blockquote><p>以下为一段简单的汇编语言源程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">       mov ax,0123H</span><br><span class="line">       mov bx,0456H</span><br><span class="line">       add ax,bx</span><br><span class="line">       add ax,ax</span><br><span class="line">       </span><br><span class="line">       mov ax,4c00</span><br><span class="line">       int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><p>XXX segment,XXX ends,end,assume都是伪指令</p></li><li><p>mov,add，int 21H都是汇编指令</p></li><li><p><strong>补上一个注意细节：汇编语言时不允许数据用字母开头（重要！！）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AX, FFFFH;这是错误写法，会报错！！</span><br><span class="line">mov AX, 0FFFFH;这样写就对了，写个0为了使数据开头不是字母</span><br></pre></td></tr></table></figure></li></ul><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p><img src="/images/9.jpg" height="400" width="350" /><h1 id="寄存器-8086CPU"><a href="#寄存器-8086CPU" class="headerlink" title="寄存器(8086CPU)"></a>寄存器(8086CPU)</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>CPU 还自带寄存器（register），用来储存最常用的数据。那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p></blockquote><ul><li><p>所有寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW</p></li><li><p>AX、BX、CX、DX</p><ul><li>存放一般性数据的通用寄存器</li><li>可分为两部分，如AX可以为AH和AL</li></ul></li><li><p>CS、DS、SS、ES都是段寄存器</p><ul><li>在8086cpu中不支持将数据直接送入段寄存器中</li></ul></li><li><p>CS和IP</p><ul><li>CS为代码段寄存器</li><li>IP为指令指针寄存器</li><li>CS和IP使cpu读取指定单元</li></ul></li><li><p>DS</p><p>DS通常用来存放要访问数据的段地址</p><p>比如要读取10000H单元的数据，可以按如下程序段进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line"></span><br><span class="line">mov ds, bx(bx起中转作用)</span><br><span class="line"></span><br><span class="line">mov al,[0]([]代表一个内存单元，[]里面的数代表偏移地址，段地址默认为ds中的数据)</span><br></pre></td></tr></table></figure></li><li><p>SS和SP</p><ul><li>栈顶的段地址存放在段寄存器SS中</li><li>栈顶的偏移地址存放在寄存器SP中</li><li>任何时候，SS：SP指向栈顶元素</li><li>当有元素入栈后，SP=SP－2；当有元素出栈后,SP=SP＋2</li><li>执行t命令时，执行与ss相关的指令后自动执行与sp相关的指令</li></ul></li></ul><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p></blockquote><h2 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。</p><p>Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p></blockquote><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p><img src="/images/10.jpg" height="600" width="400" /><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><img src="/images/11.jpg" height="600" width="400" /><h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack(栈)"></a>Stack(栈)</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>除了内存模型 (Heap) 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p>栈是一种具有特殊的访问方式的存储空间。特点为“先进后出，后进先出”</p></blockquote><h3 id="栈顶超界问题"><a href="#栈顶超界问题" class="headerlink" title="栈顶超界问题"></a>栈顶超界问题</h3><p>当栈顶超过了栈空间，栈外面的数据将被覆盖</p><img src="/images/4.jpg" height="400" width="350" /><h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在编程时，可以根据需要，将一组内存单元定义为一个段</p></blockquote><p>一个栈段最大可设为64KB（因为一个栈段最多从0~FFFFH）</p><h1 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在计算机中，由于受硬件的制约，数据都是有长度限制的，超过最多宽度的数据会被丢弃</p></blockquote><ul><li>计算机中常见的数据宽度</li></ul><p>位（bit）、字节（byte）、字（word）、双字（doubleword）</p><ul><li>存储范围</li></ul><p>字节：0~0×FF</p><p>字：0~0×FFFF</p><p>双字：0~0×FFFFFFFF</p><p>(“0×”代表十六进制)</p><h1 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h1><ul><li><p>电子计算机最小信息单位是bit,也就是一个二进制位</p></li><li><p>存储单元可以存储1byte，即两个十六进制位</p></li><li><p>存储单元从零开始顺序编号</p></li></ul><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><ul><li><p>地址总线</p><ul><li>N根地址线，则地址总线的宽度为N，寻址能力为2^N Byte</li><li>内存地址空间大小受cpu地址总线宽度的限制</li></ul></li><li><p>数据总线</p><p>N根数据总线一次传输N个二进制位</p></li><li><p>控制总线</p><p>控制总线的宽度决定了cpu对外部器件的控制能力</p></li></ul><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>从读写属性分类</p></blockquote><ul><li><p>随机存储器(RAM)</p><p>用于存放供cpu使用的绝大部分程序和数据(可随时读写，但一旦断电，数据就会消失)</p></li><li><p>只读存储器(ROM)</p><p>只能读出无法写入信息，信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器</p></li></ul><h1 id="debug命令"><a href="#debug命令" class="headerlink" title="debug命令"></a>debug命令</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>debug是一个DOS实用程序，是供程序员使用的程序调试工具，可以用它检查内存中任何地方的字节以及修改任何地方的字节。它可以用于逐指令执行某个程序以验证程序运行的正确性，也可以追踪执行过程、比较一个指令执行前后的值以及比较与移动内存中数据的范围，读写文件与磁盘</p></blockquote><p>具体请参考<a href="https://blog.csdn.net/liuer2004_82/article/details/52638516">网页连接</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>由于win10不再像win7可以直接进入debug模式，所以需要其它方法进入</p></blockquote><p>如何进入debug模式请参考我的另一篇文章</p><p><a href="https://eli0t-g.github.io/2020/12/07/dos/">win64位系统进入debug</a></p><h1 id="程序从写出到执行的过程"><a href="#程序从写出到执行的过程" class="headerlink" title="程序从写出到执行的过程"></a>程序从写出到执行的过程</h1><ul><li><p>编写</p><p>在<!--编译器-->上编写代码，结果是产生了一个存储源代码的文本文件</p><p><strong>编译器是一种特殊的程序，它可以把以特定编程语言写成的程序变为机器可以运行的机器码。</strong></p></li><li><p>编译链接</p><ul><li><p>编译</p><p>编译的意思就是把程序语言写成机器可以运行的机器码的过程，此过程需要用到编译器。</p></li><li><p>连接</p><p>在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。</p><p><strong>对于连接的过程，可执行文件是我们要得到的最终结果</strong></p><p>其作用：</p><ul><li>当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件</li><li>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行 文件</li><li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li></ul></li></ul></li><li><p>执行</p><p>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化，然后由CPU执行程序</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Assembly Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/post/markdown.html"/>
      <url>/post/markdown.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>搭建好博客后没有直接开始写文章是因为写文章时遇到了很多问题，之后去b站和百度上了解了一下，学到了一些关于markdown语法的使用方法，在此分享一下</p></blockquote><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>“#”一级标题</p><p>“##”二级标题</p><p>……（共六级标题，“#”后面要空一格）</p><p>效果如图</p><img src="/images/12.jpg" height="400" width="350" /><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>&lt;一级引用</p><p>&lt;&lt;二级引用</p><p>&lt;&lt;&lt;三级引用</p><p>……(可不断嵌套）</p><p>效果如图</p><img src="/images/13.jpg" height="550" width="500" /><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>要加粗的文字左右分别用两个*号包起来</p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>要加粗的文字左右分别用两个*号包起来</p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>要加删除线的文字左右分别用两个~号包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><h3 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;red&gt;我是红色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;#008000&gt;我是绿色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;Blue&gt;我是蓝色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font size&#x3D;5&gt;我是尺寸&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;黑体&quot; color&#x3D;green size&#x3D;5&gt;我是黑体，绿色，尺寸为5&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>可用三个或三个以上“ - ”或者“ _ ”生成分割线（两个个效果都一样)</p><h1 id="隐藏内容"><a href="#隐藏内容" class="headerlink" title="隐藏内容"></a>隐藏内容</h1><p><em>(隐藏内容不会直接显示在博客主页，需要点进去看)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在&lt;!--more--&gt;输入的文章内容不会直接显示在博客页面</span><br></pre></td></tr></table></figure><h1 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h1><h3 id="链接引用"><a href="#链接引用" class="headerlink" title="链接引用"></a>链接引用</h3><p>在src=后面加入照片地址，width指照片宽度，height指照片高度</p><p>例如</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg&quot;</span> width=<span class="string">&quot;251&quot;</span> height=<span class="string">&quot;350&quot;</span> &gt;</span><br></pre></td></tr></table></figure><h3 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h3><p>与链接引用类似，不过需要将网址改为路径（如果在相同目录里面，只需要将填写对应文件夹即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;1.jpg&quot; height&#x3D;&quot;400&quot; width&#x3D;&quot;350&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h1 id="照片居中"><a href="#照片居中" class="headerlink" title="照片居中"></a>照片居中</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;right&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;pic11.photophoto.cn&#x2F;20090626&#x2F;0036036341009653_b.jpg&quot; width&#x3D;&quot;50%&quot; height&#x3D;&quot;50%&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><p>三个效果都一样</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>数字加点</p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>上一级和下一级之间敲三个空格即可</p><p>例如</p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li></ul><ul><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li>一级有序列表内容<ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li>一级有序列表内容<ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ol><h1 id="视频引用"><a href="#视频引用" class="headerlink" title="视频引用"></a>视频引用</h1><p>与照片引用类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src&#x3D;&#39;&#x2F;视频路径&#x2F;选择视频&#39; heigth&#x3D;&#39;高度&#39; controls&gt;</span><br><span class="line">例如：&lt;video src&#x3D;&#39;&#x2F;video&#x2F;1.mp4&#39; heigth&#x3D;&#39;500px&#39; controls&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debug安装与配置</title>
      <link href="/post/debug%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html"/>
      <url>/post/debug%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="win64位系统进入debug"><a href="#win64位系统进入debug" class="headerlink" title="win64位系统进入debug"></a>win64位系统进入debug</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>最近一直在看汇编语言，想要实操，于是要进入debug模式，但是发现win64位系统无法直接进入，但最后经过几次尝试终于成功进入</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、首先要下载安装DOSBox，也就是下面这个东西</p><img src="/images/5.jpg" height="400" width="350" /><p>安装地址：链接：<a href="https://pan.baidu.com/s/1B0dzSc--Ok_ds67ai4flmQ">https://pan.baidu.com/s/1B0dzSc--Ok_ds67ai4flmQ</a>     提取码：a7tp </p><p>2、因为软件比较小，为了避免麻烦，我直接默认安装在C:\Program Files (x86)中</p><p>3、找到 <strong>debug.exe</strong>，并把你喜欢的位置上，记住目录（等会用到）这里我放在<strong>D:\Debug</strong>目录下</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>打开DOSBox.exe，输入以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount c d:\debug</span><br><span class="line">c:</span><br><span class="line">debug</span><br></pre></td></tr></table></figure><img src="/images/6.jpg" height="600" width="600" /><p>之后就进入了debug模式</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>如果嫌每次进入都需要输入很麻烦，可以在<strong>DOSBox 0.74 Options.bat</strong>的脚本文件进行修改，步骤如下：</p><p>1、找到<strong>DOSBox 0.74 Options.bat</strong>，双击点开</p><p>2、点开后拉至最底下输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount c d:\debug</span><br><span class="line">c:</span><br></pre></td></tr></table></figure><p>3、保存退出</p><img src="/images/7.jpg" height="600" width="600" /><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>开 <strong>DOSBox</strong> 会同时打开两个窗口，其中一个是黑色的控制台窗口，在控制台窗口中指明了配置文件的绝对路径</p><img src="/images/8.jpg" height="600" width="600" />]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/post/My-First-Post.html"/>
      <url>/post/My-First-Post.html</url>
      
        <content type="html"><![CDATA[<h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h2><p><em>这是本人第一次搭博客，走了许多弯路，经过了无数次的失败，浪费了大量的时间，但最终还是搭建完成。在这其中，我请教了石师兄和高师兄，借鉴了B站的视频，才最终成功。最后，我希望迈出这一小步后能够继续向前，并成为我想成为的人。</em></p><span id="more"></span><h3 id="音频测试"><a href="#音频测试" class="headerlink" title="音频测试"></a>音频测试</h3><h4 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h4><img src="/images/1.jpg" height="400" width="350" /><h4 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=400 height=86 src="//music.163.com/outchain/player?type=2&id=1477539203&auto=1&height=66"></iframe><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><video src='/video/1.mp4' heigth='500px' controls>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
