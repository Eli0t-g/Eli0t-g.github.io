<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>checksec及其保护机制</title>
      <link href="2021/04/09/PWN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/04/09/PWN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="checksec（gdb安装好就有）"><a href="#checksec（gdb安装好就有）" class="headerlink" title="checksec（gdb安装好就有）"></a>checksec（gdb安装好就有）</h1><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>动态调试软件，必备。</p><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gdb</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。</p><p>用法：checksec filename</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ checksec start</span><br><span class="line">CANARY    : disabled(这个选项表示栈保护功能有没有开启。)</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : disabled</span><br></pre></td></tr></table></figure><p><strong>CANNARY(栈保护)</strong></p><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。**</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F;禁用栈保护</span><br><span class="line">gcc -fstack-protector -o test test.c   &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure><p><strong>FORTIFY</strong></p><p>这个保护机制查了很久都没有个很好的汉语形容，根据我的理解它其实和栈保护都是gcc的新的为了增强保护的一种机制，防止缓冲区溢出攻击。并不是太常见。</p><p><strong>NX（DEP）</strong></p><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z execstack -o test test.c</span><br></pre></td></tr></table></figure><p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p><p><strong>PIE（ASLR）</strong></p><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p>参考文章：<a href="https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> checksec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="2021/03/28/%E6%8C%87%E9%92%88/"/>
      <url>2021/03/28/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>今天学习C语言的指针的时候，被一个问题难住了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c=<span class="number">1</span>,d=<span class="number">2</span>;</span><br><span class="line">  swap1(c,d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,c,d);</span><br><span class="line">  swap2(&amp;c,&amp;d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,c,d);</span><br><span class="line">  swap3(&amp;c,&amp;d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,c,d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t=a;</span><br><span class="line">  a=b;</span><br><span class="line">  b=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t=a;</span><br><span class="line">  a=b;</span><br><span class="line">  b=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t=*a;</span><br><span class="line">  *a=*b;</span><br><span class="line">  *b=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中就只有swap3成功交换了c与d的值，之后我询问了一下同学看了一些资料，明白了为什么会这样</p><p>首先swap1(c,d)是将c与d的值复制进函数，c与d本身是没有进入的，所以函数里面再怎么交换也不会影响的c与d的值</p><p>同样也是如此，只不过是复制了c与d的地址而已，c与d本身是不受影响的</p><p>而最后的swap3虽然也是复制了c与d的地址，但*a则是同过地址找到了a(也就是c)，相当于通过地址找到了本身(也就是把c揪出来了)，找到了本身以后接下来的操作自然就会作用在本身上了，所以swap3可以交换c与d的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  add(a,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;c;i++)</span><br><span class="line">    a[i]+=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是处理数组的，虽然没有用到指针，但会发现数组依旧被改变了。这是因为编译器在处理C语言数组时不会创建副本，而是直接在数组本身进行修改，所以会导致数组发生变化。（为了防止数组被函数修改，可以使用const，只要函数要修改数组，编译器就会报错。）</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收获 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assembly Language（32位）</title>
      <link href="2021/03/22/huibian32/"/>
      <url>2021/03/22/huibian32/</url>
      
        <content type="html"><![CDATA[<blockquote><p>重新复习了一遍汇编，这次看的是32位的，有了一点点收获，就随便写写</p></blockquote><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><img src="/images/58.png" height="400" width="350" /><p>x86的寄存器包括8位、16位、32位，其中32位寄存器可以分为16位或者8位，如EAX可以分为16位AX或者8位AH、AL，但是EBX以后的寄存器就不可以了，虽然是通用寄存器但是每个通用寄存器都有一些特殊的用途</p><h2 id="EAX"><a href="#EAX" class="headerlink" title="EAX"></a>EAX</h2><p>EAX与STOS指令相关，STOS会将EAX的值存进EDI指定的内存单元中，同时还经常存储计算结果</p><h2 id="ECX"><a href="#ECX" class="headerlink" title="ECX"></a>ECX</h2><p>ECX与REP指令相关，用于记录指令循环次数</p><h2 id="EDI和ESI"><a href="#EDI和ESI" class="headerlink" title="EDI和ESI"></a>EDI和ESI</h2><p>EDI和ESI用于做地址复制，将ESI指定的地址中的值赋值到EDI指定的地址中，与movs指令有很大关系</p><img src="/images/59.png" height="400" width="700" /><h2 id="ESP"><a href="#ESP" class="headerlink" title="ESP"></a>ESP</h2><p>ESP用于存储当前栈堆用到的地址</p><h2 id="EFL（标志寄存器）"><a href="#EFL（标志寄存器）" class="headerlink" title="EFL（标志寄存器）"></a>EFL（标志寄存器）</h2><p>EFI的第十位（DF）如果是零，使用push，pop指令后ESP会加相应数值，如果是一，则减去相应数值。</p><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><p>EIP用于存储计算机执行下一个指令的地址</p><h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><blockquote><p>堆栈本质就是一段内存，在程序启动前就已经被分配好了，堆栈会存储程序重要的信息，被称为“程序的心脏”</p></blockquote><p>32位上的应用大部分采用小端模式，手机上的应用大部分采用大端模式</p><h2 id="小段模式"><a href="#小段模式" class="headerlink" title="小段模式"></a>小段模式</h2><p>从高地址开始存放，往低地址去</p><h2 id="大端模式"><a href="#大端模式" class="headerlink" title="大端模式"></a>大端模式</h2><p>从低地址开始存放，往高地址去</p><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="MOV-移动指令"><a href="#MOV-移动指令" class="headerlink" title="MOV(移动指令)"></a>MOV(移动指令)</h2><p>将指定的值移动指定位置（内存地址或寄存器）</p><h2 id="ADD-加法指令"><a href="#ADD-加法指令" class="headerlink" title="ADD(加法指令)"></a>ADD(加法指令)</h2><p>将指定的两个值相加，结果返回到指定位置（内存地址或寄存器）</p><h2 id="SUB-减法指令"><a href="#SUB-减法指令" class="headerlink" title="SUB(减法指令)"></a>SUB(减法指令)</h2><p>将指定的两个值相减，结果返回到指定位置（内存地址或寄存器）</p><h2 id="AND-与运算指令"><a href="#AND-与运算指令" class="headerlink" title="AND(与运算指令)"></a>AND(与运算指令)</h2><p>与运算：两个为一才为一</p><p>将指定的两个值进行与运算，结果返回到指定位置（内存地址或寄存器）</p><h2 id="OR-或运算指令"><a href="#OR-或运算指令" class="headerlink" title="OR(或运算指令)"></a>OR(或运算指令)</h2><p>或运算：有一就为一</p><p>将指定的两个值进行或运算，结果返回到指定位置（内存地址或寄存器）</p><h2 id="XOR-异或运算指令"><a href="#XOR-异或运算指令" class="headerlink" title="XOR(异或运算指令)"></a>XOR(异或运算指令)</h2><p>异或运算：不一样为一</p><p>将指定的两个值进行异或运算，结果返回到指定位置（内存地址或寄存器）</p><h2 id="NOT-非运算指令"><a href="#NOT-非运算指令" class="headerlink" title="NOT(非运算指令)"></a>NOT(非运算指令)</h2><p>非运算：一为零，零为一</p><p>将指定的一个值进行非运算，结果返回原位置（内存地址或寄存器）</p><h2 id="SHL-左移指令"><a href="#SHL-左移指令" class="headerlink" title="SHL(左移指令)"></a>SHL(左移指令)</h2><p>shl（C语言：&lt;&lt;）</p><p>高位丢弃,低位补零</p><h2 id="右移指令"><a href="#右移指令" class="headerlink" title="右移指令"></a>右移指令</h2><p>汇编 shr：高位补零，低位丢弃</p><p>​         sar：高位补符号位，地位丢弃（就是补最高位的数字）</p><p>C语言 &gt;&gt; 无符号数：高位补零，低位丢弃</p><p>​                 有符号数：高位补符号位，低位丢弃</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Assembly Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH连接失败及hexo命令失效</title>
      <link href="2021/03/15/SSH%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%E5%8F%8Ahexo%E5%91%BD%E4%BB%A4%E5%A4%B1%E6%95%88/"/>
      <url>2021/03/15/SSH%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%E5%8F%8Ahexo%E5%91%BD%E4%BB%A4%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>闲的无聊就整了一下博客，结果出大问题了，之前的备份又删了，所以不得不重建，这次重建花了整整一天，虽说浪费时间但是还是有所收获</p></blockquote><p>搭建博客视频网上一大堆，这里就不多讲了，这里就讲一些错误和如何解决</p><h1 id="ssh-connect-to-host-github-com-port-22-Connection-timed-out"><a href="#ssh-connect-to-host-github-com-port-22-Connection-timed-out" class="headerlink" title="ssh: connect to host github.com port 22: Connection timed out"></a>ssh: connect to host github.com port 22: Connection timed out</h1><p>这个问题烦了我几个小时，网上的解决方法参差不齐（反正我通过网上的方法没用解决），最后还是看官方的解决方法（官方是真的牛逼）<a href="https://docs.github.com/en/github/authenticating-to-github/using-ssh-over-the-https-port">Using SSH over the HTTPS port</a>。</p><p>出现这个问题是因为22端口被占用或者防火墙不允许ssh连接。解决方法是通过通过HTTPS启用SSH连接，命令：ssh -T -p 443 <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x73;&#x73;&#104;&#46;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#109;">&#x67;&#x69;&#x74;&#x40;&#x73;&#x73;&#104;&#46;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#109;</a>，运行时输入yes，这样可以强制连接，连接成功后就可以进行下一步操作了（不成功可以看官方给的<a href="https://docs.github.com/en/articles/error-permission-denied-publickey">故障排除指南</a>），成功后，在.ssh文件夹中创建一个config文件（千万千万别加后缀名！）内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br><span class="line">  User git</span><br></pre></td></tr></table></figure><p>最后输入：ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;">&#103;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;</a>看是否成功连接</p><p>成功连接如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not</span><br><span class="line">&gt; provide shell access.</span><br></pre></td></tr></table></figure><p>简单介绍一下<a href="https://ru.wikipedia.org/wiki/SSH">SSH</a>，博客上传时，如果没用通过ssh连接的话，需要输入密码，通过ssh远程连接以后就不需要了</p><h1 id="hexo命令失效"><a href="#hexo命令失效" class="headerlink" title="hexo命令失效"></a>hexo命令失效</h1><p>原本搭建好了但是不知道为什么突然hexo一些命令失效了，在网上找了发现可能有几种原因：</p><ol><li>检查<code>_config.yml</code>中的内容<code>:</code>后面没有有一个空格。</li><li>`package.json’，没有添加hexo信息用来标识这是一个hexo目录：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实在不行就重新进行<code>hexo init</code>（最有效最直接的方法）</p><h1 id="hexo-d命令报错-ERROR-Deployer-not-found-git"><a href="#hexo-d命令报错-ERROR-Deployer-not-found-git" class="headerlink" title="hexo d命令报错 ERROR Deployer not found: git"></a>hexo d命令报错 ERROR Deployer not found: git</h1><p>上网搜了一下，就是没安装好<code>hexo-deployer-git</code>插件，重新安装一下就好了。（命令：npm install hexo-deployer-git –save）</p>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习心得</title>
      <link href="2021/02/16/python/"/>
      <url>2021/02/16/python/</url>
      
        <content type="html"><![CDATA[<blockquote><p>寒假学习python是我没想到的，但是的确学到了不少知识。在这里分享一下我所学到的与我总结一些的关于python内置函数的知识</p></blockquote><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="与字符相关的函数"><a href="#与字符相关的函数" class="headerlink" title="与字符相关的函数"></a>与字符相关的函数</h2><p>isinstance() </p><p>作用：判断一个对象是否是一个已知的类型，类似 type()。</p><p>用法：isinstance(object, classinfo)</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span> (a,<span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span> (a,<span class="built_in">str</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span> (a,(<span class="built_in">str</span>,<span class="built_in">int</span>,<span class="built_in">list</span>))    <span class="comment"># 是元组中的一个返回 True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><p>divmod()  </p><p>作用：输入除数和余数，返回商和余数  </p><p>用法：divmod(number,number)</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">7</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><p>ord()  </p><p>作用：返回指定对象的ASCII码对应的十进制  </p><p>用法：ord(object)</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) </span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><h2 id="与字符串相关的函数"><a href="#与字符串相关的函数" class="headerlink" title="与字符串相关的函数"></a>与字符串相关的函数</h2><p>eval()</p><p>作用：用来执行一个字符串表达式，并返回表达式的值</p><p>用法：eval(string)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">eval</span>(<span class="string">&#x27;5+3&#x27;</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><hr><p>format() 函数</p><p>作用：格式化字符串  </p><p>用法：str.format()</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)<span class="string">&quot;)   # 不设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;print(&quot;</span>&#123;<span class="number">1</span>&#125; &#123;<span class="number">0</span>&#125; &#123;<span class="number">1</span>&#125;<span class="string">&quot;.format(&quot;</span>hello<span class="string">&quot;, &quot;</span>world<span class="string">&quot;)&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span>  </span><br><span class="line">&gt;&gt;&gt;print(<span class="string">&#x27;Hello &#123;w&#125;&#x27;</span>.<span class="built_in">format</span>(w=<span class="string">&#x27;World&#x27;</span>)) <span class="comment"># 指定参数</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="与列表相关的函数"><a href="#与列表相关的函数" class="headerlink" title="与列表相关的函数"></a>与列表相关的函数</h2><p>enumerate()  函数</p><p>作用：遍历的数据对象组合为一个索引序列，同时列出数据和数据下标  </p><p>用法：enumerate(sequence, [start=0])</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">    print(x,y)</span><br></pre></td></tr></table></figure><p>输出：</p><p>0 a</p><p>1 b</p><p>2 c</p><hr><p>sort() 函数</p><p>作用：列表进行排序，如果指定参数，则使用比较函数指定的比较函数</p><p>用法：list.sort(key=None, reverse=False)</p><ul><li>key：主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse – 排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）</li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeSecond</span>(<span class="params">elem</span>):</span></span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定第二个元素排序</span></span><br><span class="line">random.sort(key=takeSecond)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出类别</span></span><br><span class="line">print(<span class="string">&#x27;排序列表：&#x27;</span>)</span><br><span class="line">print(random)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序列表：</span><br><span class="line">[(4, 1), (2, 2), (1, 3), (3, 4)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表</span></span><br><span class="line">vowels = [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 降序</span></span><br><span class="line">vowels.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">print(<span class="string">&#x27;降序输出:&#x27;</span>)</span><br><span class="line">print( vowels )</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">降序输出:</span><br><span class="line">[&#39;u&#39;, &#39;o&#39;, &#39;i&#39;, &#39;e&#39;, &#39;a&#39;]</span><br></pre></td></tr></table></figure><hr><p>zip()</p><p>作用：用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p><p>用法：zip(iterable, …)</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped = <span class="built_in">zip</span>(a,b)     <span class="comment"># 打包为元组的列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(a,c)              <span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(*zipped)          <span class="comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><hr><p>all()</p><p>作用：用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。</p><p>用法：all(iterable)</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])  <span class="comment"># 列表list，元素都不为空或0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])   <span class="comment"># 列表list，存在一个为空的元素</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="number">0</span>, <span class="number">1</span>，<span class="number">2</span>, <span class="number">3</span>])          <span class="comment"># 列表list，存在一个为0的元素</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>))  <span class="comment"># 元组tuple，元素都不为空或0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;d&#x27;</span>))   <span class="comment"># 元组tuple，存在一个为空的元素</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>((<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))          <span class="comment"># 元组tuple，存在一个为0的元素</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([])             <span class="comment"># 空列表</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>(())             <span class="comment"># 空元组</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><p>sort()和sorted()</p><p>作用：对所有可迭代的对象进行排序操作。</p><p>用法：sorted(iterable, cmp=None, key=None, reverse=False)(sort也是一样)</p><p>区别：sort会改变原对象的序列而sorted不会</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">sorted</span>(a)       <span class="comment"># 保留原列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a </span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L=[(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>),(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>),(<span class="string">&#x27;d&#x27;</span>,<span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(L, cmp=<span class="keyword">lambda</span> x,y:cmp(x[<span class="number">1</span>],y[<span class="number">1</span>]))   <span class="comment"># 利用cmp函数</span></span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(L, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])               <span class="comment"># 利用key</span></span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students = [(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>), (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> s: s[<span class="number">2</span>])            <span class="comment"># 按年龄排序</span></span><br><span class="line">[(<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>), (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> s: s[<span class="number">2</span>], reverse=<span class="literal">True</span>)       <span class="comment"># 按降序</span></span><br><span class="line">[(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>), (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><hr><p>set()</p><p>作用：删除列表里面重复的元素，（不会改变原有序列）</p><p>用法：set(iterable)</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;zhang&#x27;</span>,<span class="string">&#x27;kang&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">list2=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">s1=<span class="built_in">set</span>(list1)</span><br><span class="line">s2=<span class="built_in">set</span>(list2)</span><br><span class="line">print(s1)</span><br><span class="line">print(s2)</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;kang&#x27;</span>, <span class="string">&#x27;zhang&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;zhang&#x27;</span>, <span class="string">&#x27;kang&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bugku</title>
      <link href="2021/02/02/bugku/"/>
      <url>2021/02/02/bugku/</url>
      
        <content type="html"><![CDATA[<h1 id="BUGKU-misc部分"><a href="#BUGKU-misc部分" class="headerlink" title="BUGKU misc部分"></a>BUGKU misc部分</h1><h2 id="1-这是一张单纯的图片"><a href="#1-这是一张单纯的图片" class="headerlink" title="1 这是一张单纯的图片"></a>1 这是一张单纯的图片</h2><p>先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样，</p><img src="/images/21.png" height="500" width="600" /><p>直接丢winhex，拖至最底，发现是unicode加密</p><img src="/images/22.png" height="500" width="600" /><p>发现是unicode加密，直接解码成ASCII，得到flag</p><img src="/images/23.png" height="500" width="600" /><hr><h2 id="2-隐写"><a href="#2-隐写" class="headerlink" title="2 隐写"></a>2 隐写</h2><p>看到题目就知道是图片隐写，对图片进行校验和，发现结果有问题，说明照片高度被修改了</p><img src="/images/24.png" height="500" width="600" /><p>修改高度得到flag</p><img src="/images/25.png" height="400" width="300" /><hr><h2 id="3-telnet"><a href="#3-telnet" class="headerlink" title="3 telnet"></a>3 telnet</h2><p>下载附件后打开，直接追踪TCP流就得到了flag</p><img src="/images/26.png" height="500" width="600" /><hr><h2 id="4-眼见非实"><a href="#4-眼见非实" class="headerlink" title="4 眼见非实"></a>4 眼见非实</h2><p>打开后发现文件是损坏的而且出现了PK字符，猜测里面藏有压缩包，于是改成压缩包形式打开</p><img src="/images/27.png" height="500" width="600" /><p>在word里面的document.xml里面发现了flag</p><img src="/images/28.png" height="500" width="600" /><hr><h2 id="5-啊哒"><a href="#5-啊哒" class="headerlink" title="5 啊哒"></a>5 啊哒</h2><p>老规矩，打开照片看属性，发现照相机型号有东西，之后应该用得上</p><img src="/images/29.png" height="600" width="600" /><p>用binwalk查看，发现里面藏有一个压缩包，用foremost进行分离得到压缩包，打开发现是加密的，尝试了照相机型号，发现密码错误，分析了一下那串照相机型号，发现是十六进制，之后解码得到密码</p><img src="/images/30.png" height="600" width="600" /><p>打开得到flag</p><img src="/images/31.png" height="600" width="600" /><hr><h2 id="6-ping"><a href="#6-ping" class="headerlink" title="6 ping"></a>6 ping</h2><p>用wireshark打开后发现十六进制旁边一个f，打开其它的发现组合起来是flag</p><img src="/images/32.png" height="600" width="500" /><hr><h2 id="7-赛博朋克"><a href="#7-赛博朋克" class="headerlink" title="7 赛博朋克"></a>7 赛博朋克</h2><p>打开后发现就一个光秃秃的加密文件，不用猜都知道是伪加密，丢进winhex修改一下就可以打开了</p><img src="/images/33.png" height="600" width="500" /><p>打开文件后发现是一堆乱码，丢进winhex发现是png格式照片</p><img src="/images/34.png" height="600" width="400" /><p>修改一下后缀名图片就出来了，不过好像flag还没出来，属性里面也没什么东西，校验和也正确，binwalk也没查出问题</p><img src="/images/35.png" height="600" width="400" /><img src="/images/36.png" height="400" width="600" /><p>最后推测一个是lsb隐写，果不其然，得到flag</p><img src="/images/37.png" height="500" width="600" /><hr><h2 id="8-贝斯手"><a href="#8-贝斯手" class="headerlink" title="8 贝斯手"></a>8 贝斯手</h2><p>打开介绍发现是对图片上人物介绍，刚想关闭发现最下面还有东西，发现密码是四位数和这个贝斯手有关</p><img src="/images/38.png" height="500" width="600" /><p>懒得搜直接暴力破解</p><img src="/images/39.png" height="500" width="600" /><p>打开后发现是一串加密字符，5+58应该加密方式MD5和base58</p><img src="/images/40.png" height="500" width="600" /><p>解码得到flag</p><img src="/images/41.png" height="500" width="500" /><img src="/images/42.png" height="500" width="600" /><hr><h2 id="9-又一张图片，还单纯吗"><a href="#9-又一张图片，还单纯吗" class="headerlink" title="9 又一张图片，还单纯吗"></a>9 又一张图片，还单纯吗</h2><p>打开属性发现没有有用的信息，丢进winhex里面也没发现什么，用binwalk查看发现照片里面有其它jpg照片，用forem分离</p><img src="/images/43.png" height="500" width="600" /><p>发现图片里面有flag（不过这个flag有点长，有点离谱）</p><img src="/images/44.png" height="500" width="600" /><hr><h2 id="10-猜"><a href="#10-猜" class="headerlink" title="10 猜"></a>10 猜</h2><p>签到题，百度识图，发现是刘亦菲，得到flag（注意flag格式）</p><hr><h2 id="11-宽带信息泄露"><a href="#11-宽带信息泄露" class="headerlink" title="11 宽带信息泄露"></a>11 宽带信息泄露</h2><p>下载RouterPassView，用这个搜索username（用户名）</p><img src="/images/53.png" height="500" width="600" /><hr><h2 id="12-隐写2"><a href="#12-隐写2" class="headerlink" title="12 隐写2"></a>12 隐写2</h2><p>直接丢进winhex，发现jpg图片结尾后面有压缩包的字符</p><img src="/images/45.png" height="500" width="600" /><p>用foremost分离得到一个加密的文件和密码提示，解密（直接爆破，反正是三位数）得到一张图片</p><img src="/images/46.png" height="500" width="600" /><p>老规矩丢winhex，发现最后有flag</p><img src="/images/47.png" height="500" width="600" /><hr><h2 id="13-多种方法解决"><a href="#13-多种方法解决" class="headerlink" title="13 多种方法解决"></a>13 多种方法解决</h2><p>这道题提示说有二维码，打开附件发现是一个exe可执行文件（尝试打开发现无法运行），直接丢winhex</p><img src="/images/48.png" height="500" width="600" /><p>发现是旁边是加密的图片编码，直接在线解码得到flag</p><img src="/images/49.png" height="500" width="600" /><hr><h2 id="14-闪的好快"><a href="#14-闪的好快" class="headerlink" title="14 闪的好快"></a>14 闪的好快</h2><p>emmmm，这道题挺简单的就是好烦，用Stegsolve.jar一帧一帧看，扫码，flag就出来了</p><hr><h2 id="15-come-game"><a href="#15-come-game" class="headerlink" title="15 come_game"></a>15 come_game</h2><p>打开后是个游戏，每次死亡都会多个文件，找到save1将它丢尽winhex里面，将2AC改成5AC在进游戏就可以得到flag，当然如果觉得能闯过去也应该能得到flag。（我没试过，不确定能不能行，提醒一下这个游戏打开了好像不能关闭）</p><img src="/images/50.png" height="500" width="600" /><hr><h2 id="16-白哥的鸽子"><a href="#16-白哥的鸽子" class="headerlink" title="16 白哥的鸽子"></a>16 白哥的鸽子</h2><p>直接丢进winhex里面，发现照片结尾后面多出一些字符，分析一下就知道是栅栏加密</p><img src="/images/51.png" height="500" width="600" /><p>解密（密匙我是一个一个试的，不过还好就是3，后面才知道那个提示“咕咕咕”好像就代表key=3）</p><img src="/images/52.png" height="500" width="600" /><h2 id="17-linux"><a href="#17-linux" class="headerlink" title="17 linux"></a>17 linux</h2><p>看到题目就知道要用Linux系统</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐周五</title>
      <link href="2020/12/19/tuoli/"/>
      <url>2020/12/19/tuoli/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是这几个月最值得纪念的周五，体验了脱离学校的快乐</p></blockquote><p>2020.12.13</p><p>  晚上和社团其它人一起谋划着“出校大计”，原本定在周六，但是由于学校要体测（挺佩服学校挑时间的能力🤬），不得不将时间改成周五，让快乐减少了一半😔</p><p>2020.12.15</p><p>  果然到了周末就会发现屁事很多😔，一个个周末都有事，只剩几个大男人可以出去，这次出校也变成了“罗汉出行”，照这样下去，不知道之后几天会发生什么😱</p><p>2020.12.17</p><p>  原本课上得好好的，突然一个朋友说周六体测取消了，改了时间，我直接当场爆炸🤬，没办法假条都上交了，时间也不能修改，只能认命</p><p>2020.12.18</p><p>  原本计划好的五个人，要走的时候最后一个人掉链子😔，最后变成四罗汉出行。</p><p>开始打算看电影，但是觉得没什么好看的电影加上时间不够，所以改成了密室逃脱（补充一下，有个当地人带路非常重要😃）</p><img src="/images/17.jpg" height="400" width="350" /><img src="/images/16.jpg" height="400" width="350" /><img src="/images/15.jpg" height="400" width="350" /><p>游戏体验还不错（除了那个怕鬼的师兄），还送了一个纪念品（下面的是买奶茶送的纪念品）😃</p><img src="/images/20.jpg" height="400" width="350" /><p>最后去吃了碗拉面，味道还是相当不错的，就是价格有点小贵/(ㄒoㄒ)/~~</p><p>饭后去逛了一下，带点东西给室友，最后打的回校</p><img src="/images/19.jpg" height="400" width="350" /><p>  这次行程还是不错的（比呆在学校好多了），发现南昌还是蛮好玩的，但就是不知道下次出去是什么时候了😔</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 娱乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础知识</title>
      <link href="2020/12/10/C/"/>
      <url>2020/12/10/C/</url>
      
        <content type="html"><![CDATA[<p><em>原本早就开始学习C语言，但是因为过于心急直接开始实操（如果只是对C语言感兴趣或者想要了解一下C语言，个人推荐《啊哈C》），最后发现学习难以进行下去，于是重新开始再学一遍。在学习C语言之前，个人建议先学习汇编语言，汇编语言可以加深对计算机的理解，方便日后的学习。</em></p><h1 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h1><p>C 语言是一种通用的、面向过程式的计算机程序设计语言，C 语言是一种通用的高级语言。C语言的特点有：</p><ul><li>易于学习</li><li>结构化语言</li><li>它产生高效率的程序</li><li>它可以处理底层的活动</li><li>它可以在多种计算机平台上编译</li></ul><hr><h1 id="C语言程序的结构"><a href="#C语言程序的结构" class="headerlink" title="C语言程序的结构"></a>C语言程序的结构</h1><p><strong>C语言程序主要是有函数构成，函数是C语言程序的基本单位。</strong>一个C语言源程序必须有一个main函数（也叫主函数），其中可以包含一个main函数和若干个其他函数，但<strong>C语言bai程序主函数只能有1个。C程序中main()称之为主函数，是所有程序运行的入口。</strong>同时，<strong>程序执行总是从main函数开始，如果有有其他函数，则完成对其他函数的调用后再返回到主函数，最后由main函数结束整个程序。</strong></p><h2 id="函数组成"><a href="#函数组成" class="headerlink" title="函数组成"></a>函数组成</h2><p>函数首部，函数体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                  <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;    <span class="comment">//对调用函数max的声明</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;               <span class="comment">//定义整数型变量x,y,z</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);      <span class="comment">//输入变量x,y的值</span></span><br><span class="line">    z=max (x,y);             <span class="comment">//调用函数max，将得到的值赋给z</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max is %d\n&quot;</span>,z); <span class="comment">//输出z</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>         <span class="comment">//定义max函数</span></span></span><br><span class="line"><span class="function"></span>&#123;                            <span class="comment">//定义变量z为整数型</span></span><br><span class="line">    <span class="keyword">int</span> z;                   <span class="comment">//如果x&gt;y，则将x的值赋给变量z</span></span><br><span class="line">    <span class="keyword">if</span> (x&gt;y) z=x;            <span class="comment">//否则，将y的值赋给变量z </span></span><br><span class="line">    <span class="keyword">else</span> z=y;                <span class="comment">//将z的值返回到主函数中调用函数的位置</span></span><br><span class="line">    <span class="keyword">return</span> (z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>int main()和int max(int x,int y)都是函数首部</p></li><li><p>函数下面的{}内的部分是函数体。函数体包括<strong>声明部分</strong>和<strong>执行部分</strong></p><hr></li></ul><h1 id="运行C程序的步骤"><a href="#运行C程序的步骤" class="headerlink" title="运行C程序的步骤"></a>运行C程序的步骤</h1><p>1、上机输入和编辑源程序</p><p>2、对源程序进行编译</p><p>3、进行连接处理</p><p>4、运行可执行程序，得到运行结果</p><img src="/images/14.jpg" height="500" width="350"/><hr><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><strong>算法+数据结构=程序</strong></p><ul><li><p><strong>数据结构</strong></p><p>在程序中要指定用哪些数据和这些数据的类型以及数据的组织形式，这就是数据结构</p></li><li><p><strong>算法</strong></p><p>算法是解决“做什么”和“怎么做”的问题。程序中的操作语句，就是算法的体现</p><p>表示算法的方法：自然语言、传统流程图、结构化流程图、伪代码等</p></li></ul><h1 id="数型类型"><a href="#数型类型" class="headerlink" title="数型类型"></a>数型类型</h1><table><thead><tr><th align="left">类型</th><th>字节数</th><th>取值范围</th></tr></thead><tbody><tr><td align="left">char(字符型)</td><td>1</td><td></td></tr><tr><td align="left">float(浮点型)</td><td>4</td><td></td></tr><tr><td align="left">double(浮点型)</td><td>8</td><td></td></tr><tr><td align="left">[ signed] int (基本整型)</td><td>4</td><td>-2^31~2^31-1</td></tr><tr><td align="left">unsigned int (无符号基本整型)</td><td>4</td><td>0~2^31-1）</td></tr><tr><td align="left">[ signed ]short [ int ] (短整型)</td><td>2</td><td>-2^15~2^15-1</td></tr><tr><td align="left">unsigned short [ int ] (无符号短整型)</td><td>2</td><td>0~2^16-1</td></tr><tr><td align="left">long [int] (长整型)</td><td>4</td><td>-2^31~2^31-1</td></tr><tr><td align="left">unsigned long [ int ] (无符号长整型)</td><td>4</td><td>0~4294967295</td></tr><tr><td align="left">long long [ int ] (双长型)(c99支持)</td><td>8</td><td>-2^63~2^63-1</td></tr><tr><td align="left">unsigned long long [ int ] (无符号双长整型)</td><td>8</td><td>0~2^64-1</td></tr></tbody></table><h1 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h1><h2 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h2><p>输出字符串需要%s (%5.2s其中5的意思是长度，2的意思是保留个数)</p><p>输出 char 类型数据需要  %c</p><p>输出 float 类型数据需要  %f (默认是六位小数，如果想控制保留的位数需加“.x”x是所要保留的位数，如保留两位小数：%.2f)</p><p>输出 double 类型数据需要  %f (输出时同float)</p><p>输出 int 类型数据需要  %d (如果d前面加数字意思时补位)</p><p>输出 unsigned int 类型数据需要  %u</p><p>输出 short 类型数据需要  %hd</p><p>输出 unsigned short 类型数据需要  %u</p><p>输出 long 类型数据需要  %ld(也可以使用%d，但是这会给程序移植到其他系统（这两种数据类型的长度不一样的系统）带来麻烦，所以建议使用%ld)</p><p>输出 unsigned long 类型数据需要  %lu</p><p>输出 long long 类型数据需要  %lld</p><p>输出 unsigned long long 类型数据需要  %llu</p><p>输出 变量地址需要%p</p><p>*<em>在%后面加 * 是指宽度（自己决定），例如：printf(“%<em>d”,width,a)</em></em></p><p><strong>float 和 double 虽然类型都是浮点型，但是double双精度更为精确，但是double更占内存，所以要根据情况而定。</strong></p><p><strong>不同位数计算机中数据类型所占字节数有些不同，上述所述为32位计算机</strong></p><p><strong>如果规定输出格式，如输出的数据必须为八进制或十六进制则需要以下方式输出</strong></p><h2 id="按特定格式输出"><a href="#按特定格式输出" class="headerlink" title="按特定格式输出"></a>按特定格式输出</h2><p>八进制：%o  %#o(格式化)</p><p>十六进制：%x  %#x(格式化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">a=<span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%O  %#o \n&quot;</span>,a,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%X  %#x&quot;</span>,a,a);</span><br><span class="line">getchar(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><img src="/images/56.png" height="400" width="400" /><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>输出 ？：/？</p><p>输出 / ：//</p><p>输出 % ：%%</p><p>断行（就是输出太多，一行放不下，需要另起一行）：/</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>printf返回值一般是用于检测是否打印错误，返回值是输出字符的个数（scanf的返回值也是如此）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv;</span><br><span class="line">    rv=<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,rv);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><img src="/images/56.png" height="300" width="400" /><p>rv=printf(“Hello World”)这一行的作用一是打印Hello World,而是将printf的返回值赋给rv（“\n”算一个）</p><h2 id="scanf输入"><a href="#scanf输入" class="headerlink" title="scanf输入"></a>scanf输入</h2><p>scanf用法和printf类似，要注意的是scanf读取一个数的时候要加地址符&amp;，<strong>但如果是数组则不需要加（因为数组的名字就是地址，不需要再寻找）&amp;</strong></p><p><strong>输入double时不是 ”%f“ 而是 ”%lf“，而float则是 “%f”</strong></p><p><strong>输入时读取到空格和回车视为读取结束</strong></p><p>如果输入时一开始就是空格，那么计算机就会一直往后读取直到遇到数字或者符号（例外%c可以读取空格）</p><p>%后面加 “ * ” 意思是丢弃不读入，如：scanf(“%*d %c”,&amp;a)，其中a的值是读入的%c，前面的直接被丢弃</p><hr><h1 id="输入、输出函数"><a href="#输入、输出函数" class="headerlink" title="输入、输出函数"></a>输入、输出函数</h1><p>前面讲了格式化输入输出，但发现仅仅使用格式化输入输出有时会显得十分繁琐，所以需要我们学习其它的输入输出函数</p><h2 id="字符输入输出（getchar-putchar）"><a href="#字符输入输出（getchar-putchar）" class="headerlink" title="字符输入输出（getchar/putchar）"></a>字符输入输出（getchar/putchar）</h2><blockquote><p>有些时候，仅仅为了在显示器屏幕上打印或从控制台获取一个字符，此时使用功能强大的printf与scanf函数，则显得过于繁琐，C提供了一个库函数putchar/getchar来完成这个简单的任务。</p></blockquote><p>getchar()函数只能读取单个字符，有时只读取一个字符（注意是以字符的形式存储）时较为方便,例：a=getchar();scanf(“%c”,&amp;a);</p><p>putchar()函数是字符输出函数， 其功能是在显示器上打印单个字符。putchar函数是一个标准的C语言库函数，它的函数原型在头文件“stdio.h”中。</p><h2 id="字符串输入输出函数-（gets与puts）"><a href="#字符串输入输出函数-（gets与puts）" class="headerlink" title="字符串输入输出函数 （gets与puts）"></a>字符串输入输出函数 （gets与puts）</h2><p>gets函数从标准输入设备读字符串函数。可以无限读取，不会判断上限，以回车结束读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。此函数在stdio.h头文件中定义的。当然，scanf也可以做到。例如：gets(a);scanf(“%[ ^\n ]”,a)（其中a是数组）</p><p>puts函数功能非常单一，在显示器屏幕上输出一个字符串，并换行。</p><h1 id="define"><a href="#define" class="headerlink" title="define"></a>define</h1><blockquote><p>之所以单独拿出来讲，是因为容易出错</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>**#define 标识符 常量 ** //注意, 最后没有分号，同时标识符和常量间只有一个空格</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>define作用类似于赋值，但它更加灵活，可以将用一些字符代替字符串，如：</p><p>#define A “nihao”；#define A 0；#define A ‘a’</p><p><strong>因为nihao是字符串，所以需要加双引号，如果只是数字就不需要，如果是字符就需要单引号。除此之外，虽然没有硬性规定define后面定义的字符要大写，但一般都是要遵守的</strong></p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=M*M/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码输出结果很容易被认为是8，但实际输出结果是6</p><p>错误原因：</p><p>首先，M被定义为3+1，在计算a前不会编译器不会先计算3+1而是直接将3+1带入进去，所以a=M * M/2就变成了a=3+1 * 3+1,之后因为M是整型数据，所以会把小数点后面的数丢弃所以最终答案为6</p><h2 id="与const的区别"><a href="#与const的区别" class="headerlink" title="与const的区别"></a>与const的区别</h2><ul><li>编译器处理方式不同<br> 　#define宏是在预处理阶段展开。<pre><code>　const常量是编译运行阶段使用。</code></pre></li><li>类型和安全检查不同<br> 　#define宏没有类型，不做任何类型检查，仅仅是展开。<pre><code>　const常量有具体的类型，在编译阶段会执行类型检查。</code></pre></li><li>存储方式不同<br> 　#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）<pre><code>　const常量会在内存中分配(可以是堆中也可以是栈中)。</code></pre></li><li>const  可以节省空间，避免不必要的内存分配。 例如：<br> #define NUM 3.14159  //常量宏<br> const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ……<br> double i = Num; //此时为Pi分配内存，以后不再分配！<br> double  I= NUM; //编译期间进行宏替换，分配内存<br> double j = Num; //没有内存分配<br> double J = NUM; //再进行宏替换，又一次分配内存！<br> const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。</li><li>提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</li><li>宏替换只作替换，不做计算，不做表达式求解;<br> 宏预编译时就替换了，程序运行时，并不分配内存。</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>i++与++i的区别（i–和–i同理）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i++,++i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,i);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>1 2</p><p>2 2</p><p>i++是运行这条指令后加一，而++i是运行前加一，所以会出现一开始输出1 2这种情况，同时，递增（递减）的运算优先级很高，只有圆括号比它高，所以使用时需注意，例如，<strong>a * b++不会等于a*b+1而是（a) * （b+1）</strong>。</p><p>不同类型数据运算：</p><p>不同类型数据进行计算时，编译器会将低精度数据转化为高精度，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    print(<span class="string">&quot;%d&quot;</span>,a/b);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运算a/b时，a会自动升级为float型，当然，也可以强制转化，在a前面加（float）就可以使a转换为float型</p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><h2 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h2><h3 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h3><p>如果函数不接收用户传递的数据，那么定义时可以不带参数。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataType functionName()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>dataType 是返回值类型，它可以是C语言中的任意数据类型，例如 int、float、char 等。</p></li><li><p>functionName 是函数名，它是<a href="http://c.biancheng.net/cpp/html/2927.html">标识符</a>的一种，命名规则和标识符相同。函数名后面的括号<code>( )</code>不能少。</p></li><li><p>body 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由<code>&#123; &#125;</code>包围。</p></li><li><p>如果有返回值，在函数体中使用 return 语句返回。return 出来的数据的类型要和 dataType 一样。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;Hello,world \n&quot;</span>);    <span class="comment">//没有返回值就不需要 return 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="有参函数的定义"><a href="#有参函数的定义" class="headerlink" title="有参函数的定义"></a>有参函数的定义</h2><p>如果函数需要接收用户传递的数据，那么定义时就要带上参数。如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dataType <span class="title">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dataType1 param1, dataType2 param2 ...</code>是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由<code>,</code>分隔。参数本质上也是变量，定义时要指明类型和名称。与无参函数的定义相比，有参函数的定义仅仅是多了一个参数列表。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从m加到n的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = m+<span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        m += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, total;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    total = sum(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total=%d\n&quot;</span>, total);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数定义处的 m、n 是形参，函数调用处的 a、b 是实参</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assembly Language</title>
      <link href="2020/12/08/Assembly%20Language/"/>
      <url>2020/12/08/Assembly%20Language/</url>
      
        <content type="html"><![CDATA[<h1 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h1><p>通过用汇编语言进行编程而深入地理解计算机底层的基本工作机理，达到随心所欲地控制计算机的目的</p><h1 id="汇编语言的由来"><a href="#汇编语言的由来" class="headerlink" title="汇编语言的由来"></a>汇编语言的由来</h1><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p><hr><h1 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h1><ul><li><p>机器相关性：</p><p>一种面向机器的低级语言，几乎接近机器语言</p></li><li><p>不可移植：</p><p>不同类型的CPU有不同的机器指令系统，也就有不同的汇编语言</p></li><li><p>操作对象：</p><p>汇编语言是直接面向处理器（Processor）的程序设计语言，它所操作的对象不是具体的数据,而是寄存器或者存储器</p></li><li><p>高速度和高效率：</p><p>汇编语言保持了机器语言的优点，具有直接和简捷的特点，可有效地访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等，且占用内存少，执行速度快，是高效的程序设计语言</p></li><li><p>编写和调试的复杂性</p><p>由于是直接控制硬件，且简单的任务也需要很多汇编语言语句，因此在进行程序设计时必须面面俱到，需要考虑到一切可能的问题，合理调配和使用各种软、硬件资源。这样，就不可避免地加重了程序员的负担。与此相同，在程序调试时，一旦程序的运行出了问题，就很难发现</p></li></ul><hr><h1 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h1><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><blockquote><p>机器码的助记符，有对应的机器码，最终被cpu执行</p></blockquote><p>具体请参考<a href="https://blog.csdn.net/bjbz_cxy/article/details/79467688">网页链接</a></p><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><blockquote><p>没有对应的机器码，由编译器执行，计算机不执行</p></blockquote><h2 id="其它符号"><a href="#其它符号" class="headerlink" title="其它符号"></a>其它符号</h2><blockquote><p>如+、-、*、/等，由编译器识别，没有对应的机器码</p></blockquote><p>以下为一段简单的汇编语言源程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">       mov ax,0123H</span><br><span class="line">       mov bx,0456H</span><br><span class="line">       add ax,bx</span><br><span class="line">       add ax,ax</span><br><span class="line">       </span><br><span class="line">       mov ax,4c00</span><br><span class="line">       int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><p>XXX segment,XXX ends,end,assume都是伪指令</p></li><li><p>mov,add，int 21H都是汇编指令</p></li><li><p><strong>补上一个注意细节：汇编语言时不允许数据用字母开头（重要！！）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AX, FFFFH;这是错误写法，会报错！！</span><br><span class="line">mov AX, 0FFFFH;这样写就对了，写个0为了使数据开头不是字母</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p><img src="/images/9.jpg" height="400" width="350" /><hr><h1 id="寄存器-8086CPU"><a href="#寄存器-8086CPU" class="headerlink" title="寄存器(8086CPU)"></a>寄存器(8086CPU)</h1><blockquote><p>CPU 还自带寄存器（register），用来储存最常用的数据。那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p></blockquote><ul><li><p>所有寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW</p></li><li><p>AX、BX、CX、DX</p><ul><li>存放一般性数据的通用寄存器</li><li>可分为两部分，如AX可以为AH和AL</li></ul></li><li><p>CS、DS、SS、ES都是段寄存器</p><ul><li>在8086cpu中不支持将数据直接送入段寄存器中</li></ul></li><li><p>CS和IP</p><ul><li>CS为代码段寄存器</li><li>IP为指令指针寄存器</li><li>CS和IP使cpu读取指定单元</li></ul></li><li><p>DS</p><p>DS通常用来存放要访问数据的段地址</p><p>比如要读取10000H单元的数据，可以按如下程序段进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line"></span><br><span class="line">mov ds, bx(bx起中转作用)</span><br><span class="line"></span><br><span class="line">mov al,[0]([]代表一个内存单元，[]里面的数代表偏移地址，段地址默认为ds中的数据)</span><br></pre></td></tr></table></figure></li><li><p>SS和SP</p><ul><li>栈顶的段地址存放在段寄存器SS中</li><li>栈顶的偏移地址存放在寄存器SP中</li><li>任何时候，SS：SP指向栈顶元素</li><li>当有元素入栈后，SP=SP－2；当有元素出栈后,SP=SP＋2</li><li>执行t命令时，执行与ss相关的指令后自动执行与sp相关的指令</li></ul></li></ul><hr><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><blockquote><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p></blockquote><h2 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h2><blockquote><p>用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。</p><p>Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p></blockquote><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p><img src="/images/10.jpg" height="600" width="400" /><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><img src="/images/11.jpg" height="600" width="400" /><h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack(栈)"></a>Stack(栈)</h2><blockquote><p>除了内存模型 (Heap) 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p>栈是一种具有特殊的访问方式的存储空间。特点为“先进后出，后进先出”</p></blockquote><h3 id="栈顶超界问题"><a href="#栈顶超界问题" class="headerlink" title="栈顶超界问题"></a>栈顶超界问题</h3><p>当栈顶超过了栈空间，栈外面的数据将被覆盖</p><img src="/images/4.jpg" height="400" width="350" /><h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><blockquote><p>在编程时，可以根据需要，将一组内存单元定义为一个段</p></blockquote><p>一个栈段最大可设为64KB（因为一个栈段最多从0~FFFFH）</p><hr><h1 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h1><blockquote><p>在计算机中，由于受硬件的制约，数据都是有长度限制的，超过最多宽度的数据会被丢弃</p></blockquote><ul><li>计算机中常见的数据宽度</li></ul><p>位（bit）、字节（byte）、字（word）、双字（doubleword）</p><ul><li>存储范围</li></ul><p>字节：0~0×FF</p><p>字：0~0×FFFF</p><p>双字：0~0×FFFFFFFF</p><p>(“0×”代表十六进制)</p><hr><h1 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h1><ul><li><p>电子计算机最小信息单位是bit,也就是一个二进制位</p></li><li><p>存储单元可以存储1byte，即两个十六进制位</p></li><li><p>存储单元从零开始顺序编号</p></li></ul><hr><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><ul><li><p>地址总线</p><ul><li>N根地址线，则地址总线的宽度为N，寻址能力为2^N Byte</li><li>内存地址空间大小受cpu地址总线宽度的限制</li></ul></li><li><p>数据总线</p><p>N根数据总线一次传输N个二进制位</p></li><li><p>控制总线</p><p>控制总线的宽度决定了cpu对外部器件的控制能力</p></li></ul><hr><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><blockquote><p>从读写属性分类</p></blockquote><ul><li><p>随机存储器(RAM)</p><p>用于存放供cpu使用的绝大部分程序和数据(可随时读写，但一旦断电，数据就会消失)</p></li><li><p>只读存储器(ROM)</p><p>只能读出无法写入信息，信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器</p></li></ul><hr><h1 id="debug命令"><a href="#debug命令" class="headerlink" title="debug命令"></a>debug命令</h1><blockquote><p>debug是一个DOS实用程序，是供程序员使用的程序调试工具，可以用它检查内存中任何地方的字节以及修改任何地方的字节。它可以用于逐指令执行某个程序以验证程序运行的正确性，也可以追踪执行过程、比较一个指令执行前后的值以及比较与移动内存中数据的范围，读写文件与磁盘</p></blockquote><p>具体请参考<a href="https://blog.csdn.net/liuer2004_82/article/details/52638516">网页连接</a></p><blockquote><p>由于win10不再像win7可以直接进入debug模式，所以需要其它方法进入</p></blockquote><p>如何进入debug模式请参考我的另一篇文章</p><p><a href="https://eli0t-g.github.io/2020/12/07/dos/">win64位系统进入debug</a></p><hr><h1 id="程序从写出到执行的过程"><a href="#程序从写出到执行的过程" class="headerlink" title="程序从写出到执行的过程"></a>程序从写出到执行的过程</h1><ul><li><p>编写</p><p>在<!--编译器-->上编写代码，结果是产生了一个存储源代码的文本文件</p><p><strong>编译器是一种特殊的程序，它可以把以特定编程语言写成的程序变为机器可以运行的机器码。</strong></p></li><li><p>编译链接</p><ul><li><p>编译</p><p>编译的意思就是把程序语言写成机器可以运行的机器码的过程，此过程需要用到编译器。</p></li><li><p>连接</p><p>在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。</p><p><strong>对于连接的过程，可执行文件是我们要得到的最终结果</strong></p><p>其作用：</p><ul><li>当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件</li><li>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行 文件</li><li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li></ul></li></ul></li><li><p>执行</p><p>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化，然后由CPU执行程序</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Assembly Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="2020/12/07/markdown/"/>
      <url>2020/12/07/markdown/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搭建好博客后没有直接开始写文章是因为写文章时遇到了很多问题，之后去b站和百度上了解了一下，学到了一些关于markdown语法的使用方法，在此分享一下</p></blockquote><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>“#”一级标题</p><p>“##”二级标题</p><p>……（共六级标题，“#”后面要空一格）</p><p>效果如图</p><img src="/images/12.jpg" height="400" width="350" /><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>&lt;一级引用</p><p>&lt;&lt;二级引用</p><p>&lt;&lt;&lt;三级引用</p><p>……(可不断嵌套）</p><p>效果如图</p><img src="/images/13.jpg" height="550" width="500" /><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>要加粗的文字左右分别用两个*号包起来</p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>要加粗的文字左右分别用两个*号包起来</p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>要加删除线的文字左右分别用两个~号包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><h3 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;red&gt;我是红色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;#008000&gt;我是绿色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;Blue&gt;我是蓝色&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font size&#x3D;5&gt;我是尺寸&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;黑体&quot; color&#x3D;green size&#x3D;5&gt;我是黑体，绿色，尺寸为5&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>可用三个或三个以上“ - ”或者“ _ ”生成分割线（两个个效果都一样)</p><h1 id="隐藏内容"><a href="#隐藏内容" class="headerlink" title="隐藏内容"></a>隐藏内容</h1><p><em>(隐藏内容不会直接显示在博客主页，需要点进去看)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在&lt;!--more--&gt;输入的文章内容不会直接显示在博客页面</span><br></pre></td></tr></table></figure><h1 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h1><h3 id="链接引用"><a href="#链接引用" class="headerlink" title="链接引用"></a>链接引用</h3><p>在src=后面加入照片地址，width指照片宽度，height指照片高度</p><p>例如</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg&quot;</span> width=<span class="string">&quot;251&quot;</span> height=<span class="string">&quot;350&quot;</span> &gt;</span><br></pre></td></tr></table></figure><h3 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h3><p>与链接引用类似，不过需要将网址改为路径（如果在相同目录里面，只需要将填写对应文件夹即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;1.jpg&quot; height&#x3D;&quot;400&quot; width&#x3D;&quot;350&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h1 id="照片居中"><a href="#照片居中" class="headerlink" title="照片居中"></a>照片居中</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;right&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;pic11.photophoto.cn&#x2F;20090626&#x2F;0036036341009653_b.jpg&quot; width&#x3D;&quot;50%&quot; height&#x3D;&quot;50%&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><p>三个效果都一样</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>数字加点</p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>上一级和下一级之间敲三个空格即可</p><p>例如</p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li></ul><ul><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li>一级有序列表内容<ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li>一级有序列表内容<ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ol><h1 id="视频引用"><a href="#视频引用" class="headerlink" title="视频引用"></a>视频引用</h1><p>与照片引用类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src&#x3D;&#39;&#x2F;视频路径&#x2F;选择视频&#39; heigth&#x3D;&#39;高度&#39; controls&gt;</span><br><span class="line">例如：&lt;video src&#x3D;&#39;&#x2F;video&#x2F;1.mp4&#39; heigth&#x3D;&#39;500px&#39; controls&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debug安装与配置</title>
      <link href="2020/12/06/debug%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>2020/12/06/debug%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="win64位系统进入debug"><a href="#win64位系统进入debug" class="headerlink" title="win64位系统进入debug"></a>win64位系统进入debug</h1><blockquote><p>最近一直在看汇编语言，想要实操，于是要进入debug模式，但是发现win64位系统无法直接进入，但最后经过几次尝试终于成功进入</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、首先要下载安装DOSBox，也就是下面这个东西</p><img src="/images/5.jpg" height="400" width="350" /><p>安装地址：链接：<a href="https://pan.baidu.com/s/1B0dzSc--Ok_ds67ai4flmQ">https://pan.baidu.com/s/1B0dzSc--Ok_ds67ai4flmQ</a>     提取码：a7tp </p><p>2、因为软件比较小，为了避免麻烦，我直接默认安装在C:\Program Files (x86)中</p><p>3、找到 <strong>debug.exe</strong>，并把你喜欢的位置上，记住目录（等会用到）这里我放在<strong>D:\Debug</strong>目录下</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>打开DOSBox.exe，输入以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount c d:\debug</span><br><span class="line">c:</span><br><span class="line">debug</span><br></pre></td></tr></table></figure><img src="/images/6.jpg" height="600" width="600" /><p>之后就进入了debug模式</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>如果嫌每次进入都需要输入很麻烦，可以在<strong>DOSBox 0.74 Options.bat</strong>的脚本文件进行修改，步骤如下：</p><p>1、找到<strong>DOSBox 0.74 Options.bat</strong>，双击点开</p><p>2、点开后拉至最底下输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount c d:\debug</span><br><span class="line">c:</span><br></pre></td></tr></table></figure><p>3、保存退出</p><img src="/images/7.jpg" height="600" width="600" /><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>开 <strong>DOSBox</strong> 会同时打开两个窗口，其中一个是黑色的控制台窗口，在控制台窗口中指明了配置文件的绝对路径</p><img src="/images/8.jpg" height="600" width="600" />]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="2020/11/21/My-First-Post/"/>
      <url>2020/11/21/My-First-Post/</url>
      
        <content type="html"><![CDATA[<h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h2><p><em>这是本人第一次搭博客，走了许多弯路，经过了无数次的失败，浪费了大量的时间，但最终还是搭建完成。在这其中，我请教了石师兄和高师兄，借鉴了B站的视频，才最终成功。最后，我希望迈出这一小步后能够继续向前，并成为我想成为的人。</em></p><span id="more"></span><h3 id="音频测试"><a href="#音频测试" class="headerlink" title="音频测试"></a>音频测试</h3><h4 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h4><img src="/images/1.jpg" height="400" width="350" /><h4 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=400 height=86 src="//music.163.com/outchain/player?type=2&id=1477539203&auto=1&height=66"></iframe><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><video src='/video/1.mp4' heigth='500px' controls>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
